<?php
/**
 * IndianApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NamSor API v2
 *
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!
 *
 * The version of the OpenAPI document: 2.0.29
 * Contact: contact@namsor.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Namsor\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Namsor\Client\ApiException;
use Namsor\Client\Configuration;
use Namsor\Client\HeaderSelector;
use Namsor\Client\ObjectSerializer;

/**
 * IndianApi Class Doc Comment
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class IndianApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'casteIndianBatch' => [
            'application/json',
        ],
        'castegroupIndian' => [
            'application/json',
        ],
        'castegroupIndianBatch' => [
            'application/json',
        ],
        'castegroupIndianFull' => [
            'application/json',
        ],
        'castegroupIndianFullBatch' => [
            'application/json',
        ],
        'castegroupIndianHindu' => [
            'application/json',
        ],
        'religion' => [
            'application/json',
        ],
        'religion1' => [
            'application/json',
        ],
        'religionIndianBatch' => [
            'application/json',
        ],
        'religionIndianFullBatch' => [
            'application/json',
        ],
        'subclassificationIndian' => [
            'application/json',
        ],
        'subclassificationIndianBatch' => [
            'application/json',
        ],
        'subclassificationIndianFull' => [
            'application/json',
        ],
        'subclassificationIndianFullBatch' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation casteIndianBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of up to 100 personal Indian Hindu names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['casteIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameCasteOut
     */
    public function casteIndianBatch($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['casteIndianBatch'][0])
    {
        list($response) = $this->casteIndianBatchWithHttpInfo($batch_first_last_name_geo_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation casteIndianBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of up to 100 personal Indian Hindu names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['casteIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameCasteOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function casteIndianBatchWithHttpInfo($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['casteIndianBatch'][0])
    {
        $request = $this->casteIndianBatchRequest($batch_first_last_name_geo_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameCasteOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameCasteOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameCasteOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameCasteOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameCasteOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation casteIndianBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of up to 100 personal Indian Hindu names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['casteIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function casteIndianBatchAsync($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['casteIndianBatch'][0])
    {
        return $this->casteIndianBatchAsyncWithHttpInfo($batch_first_last_name_geo_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation casteIndianBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of up to 100 personal Indian Hindu names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['casteIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function casteIndianBatchAsyncWithHttpInfo($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['casteIndianBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameCasteOut';
        $request = $this->casteIndianBatchRequest($batch_first_last_name_geo_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'casteIndianBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['casteIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function casteIndianBatchRequest($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['casteIndianBatch'][0])
    {



        $resourcePath = '/api2/json/casteIndianBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_subdivision_in));
            } else {
                $httpBody = $batch_first_last_name_geo_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation castegroupIndian
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a first / last name.
     *
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndian'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameCastegroupOut
     */
    public function castegroupIndian($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndian'][0])
    {
        list($response) = $this->castegroupIndianWithHttpInfo($sub_division_iso31662, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation castegroupIndianWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a first / last name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndian'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameCastegroupOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function castegroupIndianWithHttpInfo($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndian'][0])
    {
        $request = $this->castegroupIndianRequest($sub_division_iso31662, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameCastegroupOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameCastegroupOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameCastegroupOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameCastegroupOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameCastegroupOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation castegroupIndianAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a first / last name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndian'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianAsync($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndian'][0])
    {
        return $this->castegroupIndianAsyncWithHttpInfo($sub_division_iso31662, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation castegroupIndianAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a first / last name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndian'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianAsyncWithHttpInfo($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndian'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameCastegroupOut';
        $request = $this->castegroupIndianRequest($sub_division_iso31662, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'castegroupIndian'
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndian'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function castegroupIndianRequest($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndian'][0])
    {

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling castegroupIndian'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling castegroupIndian'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling castegroupIndian'
            );
        }


        $resourcePath = '/api2/json/castegroupIndian/{subDivisionIso31662}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation castegroupIndianBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal first / last names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameCastegroupOut
     */
    public function castegroupIndianBatch($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianBatch'][0])
    {
        list($response) = $this->castegroupIndianBatchWithHttpInfo($batch_first_last_name_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation castegroupIndianBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal first / last names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameCastegroupOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function castegroupIndianBatchWithHttpInfo($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianBatch'][0])
    {
        $request = $this->castegroupIndianBatchRequest($batch_first_last_name_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameCastegroupOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameCastegroupOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameCastegroupOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameCastegroupOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameCastegroupOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation castegroupIndianBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal first / last names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianBatchAsync($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianBatch'][0])
    {
        return $this->castegroupIndianBatchAsyncWithHttpInfo($batch_first_last_name_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation castegroupIndianBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal first / last names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianBatchAsyncWithHttpInfo($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameCastegroupOut';
        $request = $this->castegroupIndianBatchRequest($batch_first_last_name_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'castegroupIndianBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function castegroupIndianBatchRequest($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianBatch'][0])
    {



        $resourcePath = '/api2/json/castegroupIndianBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_subdivision_in));
            } else {
                $httpBody = $batch_first_last_name_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation castegroupIndianFull
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a personal full name.
     *
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameCastegroupOut
     */
    public function castegroupIndianFull($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['castegroupIndianFull'][0])
    {
        list($response) = $this->castegroupIndianFullWithHttpInfo($sub_division_iso31662, $personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation castegroupIndianFullWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a personal full name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameCastegroupOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function castegroupIndianFullWithHttpInfo($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['castegroupIndianFull'][0])
    {
        $request = $this->castegroupIndianFullRequest($sub_division_iso31662, $personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameCastegroupOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameCastegroupOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameCastegroupOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameCastegroupOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameCastegroupOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation castegroupIndianFullAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a personal full name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianFullAsync($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['castegroupIndianFull'][0])
    {
        return $this->castegroupIndianFullAsyncWithHttpInfo($sub_division_iso31662, $personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation castegroupIndianFullAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of a personal full name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianFullAsyncWithHttpInfo($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['castegroupIndianFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameCastegroupOut';
        $request = $this->castegroupIndianFullRequest($sub_division_iso31662, $personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'castegroupIndianFull'
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function castegroupIndianFullRequest($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['castegroupIndianFull'][0])
    {

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling castegroupIndianFull'
            );
        }

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling castegroupIndianFull'
            );
        }


        $resourcePath = '/api2/json/castegroupIndianFull/{subDivisionIso31662}/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation castegroupIndianFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal full names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameCastegroupOut
     */
    public function castegroupIndianFullBatch($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianFullBatch'][0])
    {
        list($response) = $this->castegroupIndianFullBatchWithHttpInfo($batch_personal_name_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation castegroupIndianFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal full names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameCastegroupOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function castegroupIndianFullBatchWithHttpInfo($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianFullBatch'][0])
    {
        $request = $this->castegroupIndianFullBatchRequest($batch_personal_name_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameCastegroupOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameCastegroupOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameCastegroupOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameCastegroupOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameCastegroupOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation castegroupIndianFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal full names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianFullBatchAsync($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianFullBatch'][0])
    {
        return $this->castegroupIndianFullBatchAsyncWithHttpInfo($batch_personal_name_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation castegroupIndianFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name castegroup of up to 100 personal full names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianFullBatchAsyncWithHttpInfo($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameCastegroupOut';
        $request = $this->castegroupIndianFullBatchRequest($batch_personal_name_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'castegroupIndianFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function castegroupIndianFullBatchRequest($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['castegroupIndianFullBatch'][0])
    {



        $resourcePath = '/api2/json/castegroupIndianFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_subdivision_in));
            } else {
                $httpBody = $batch_personal_name_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation castegroupIndianHindu
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of a personal Hindu name.
     *
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianHindu'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameCasteOut
     */
    public function castegroupIndianHindu($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndianHindu'][0])
    {
        list($response) = $this->castegroupIndianHinduWithHttpInfo($sub_division_iso31662, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation castegroupIndianHinduWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of a personal Hindu name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianHindu'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameCasteOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function castegroupIndianHinduWithHttpInfo($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndianHindu'][0])
    {
        $request = $this->castegroupIndianHinduRequest($sub_division_iso31662, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameCasteOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameCasteOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameCasteOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameCasteOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameCasteOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation castegroupIndianHinduAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of a personal Hindu name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianHindu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianHinduAsync($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndianHindu'][0])
    {
        return $this->castegroupIndianHinduAsyncWithHttpInfo($sub_division_iso31662, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation castegroupIndianHinduAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian name caste of a personal Hindu name.
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianHindu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function castegroupIndianHinduAsyncWithHttpInfo($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndianHindu'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameCasteOut';
        $request = $this->castegroupIndianHinduRequest($sub_division_iso31662, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'castegroupIndianHindu'
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['castegroupIndianHindu'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function castegroupIndianHinduRequest($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['castegroupIndianHindu'][0])
    {

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling castegroupIndianHindu'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling castegroupIndianHindu'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling castegroupIndianHindu'
            );
        }


        $resourcePath = '/api2/json/casteIndian/{subDivisionIso31662}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religion
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian full name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameReligionedOut
     */
    public function religion($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religion'][0])
    {
        list($response) = $this->religionWithHttpInfo($sub_division_iso31662, $personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation religionWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian full name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religionWithHttpInfo($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religion'][0])
    {
        $request = $this->religionRequest($sub_division_iso31662, $personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religionAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian full name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionAsync($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religion'][0])
    {
        return $this->religionAsyncWithHttpInfo($sub_division_iso31662, $personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religionAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian full name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionAsyncWithHttpInfo($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religion'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameReligionedOut';
        $request = $this->religionRequest($sub_division_iso31662, $personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religion'
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religionRequest($sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religion'][0])
    {

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling religion'
            );
        }

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling religion'
            );
        }


        $resourcePath = '/api2/json/religionIndianFull/{subDivisionIso31662}/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religion1
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian first/last name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion1'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameReligionedOut
     */
    public function religion1($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion1'][0])
    {
        list($response) = $this->religion1WithHttpInfo($sub_division_iso31662, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation religion1WithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian first/last name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion1'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religion1WithHttpInfo($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion1'][0])
    {
        $request = $this->religion1Request($sub_division_iso31662, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religion1Async
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian first/last name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religion1Async($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion1'][0])
    {
        return $this->religion1AsyncWithHttpInfo($sub_division_iso31662, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religion1AsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal Indian first/last name, provided the Indian state or Union territory (NB/ this can be inferred using the subclassification endpoint).
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religion1AsyncWithHttpInfo($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion1'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameReligionedOut';
        $request = $this->religion1Request($sub_division_iso31662, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religion1'
     *
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religion1Request($sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion1'][0])
    {

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling religion1'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling religion1'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling religion1'
            );
        }


        $resourcePath = '/api2/json/religionIndian/{subDivisionIso31662}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religionIndianBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameReligionedOut
     */
    public function religionIndianBatch($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianBatch'][0])
    {
        list($response) = $this->religionIndianBatchWithHttpInfo($batch_first_last_name_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation religionIndianBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religionIndianBatchWithHttpInfo($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianBatch'][0])
    {
        $request = $this->religionIndianBatchRequest($batch_first_last_name_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religionIndianBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionIndianBatchAsync($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianBatch'][0])
    {
        return $this->religionIndianBatchAsyncWithHttpInfo($batch_first_last_name_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religionIndianBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionIndianBatchAsyncWithHttpInfo($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameReligionedOut';
        $request = $this->religionIndianBatchRequest($batch_first_last_name_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religionIndianBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameSubdivisionIn|null $batch_first_last_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religionIndianBatchRequest($batch_first_last_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianBatch'][0])
    {



        $resourcePath = '/api2/json/religionIndianBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_subdivision_in));
            } else {
                $httpBody = $batch_first_last_name_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religionIndianFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameReligionedOut
     */
    public function religionIndianFullBatch($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianFullBatch'][0])
    {
        list($response) = $this->religionIndianFullBatchWithHttpInfo($batch_personal_name_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation religionIndianFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religionIndianFullBatchWithHttpInfo($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianFullBatch'][0])
    {
        $request = $this->religionIndianFullBatchRequest($batch_personal_name_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religionIndianFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionIndianFullBatchAsync($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianFullBatch'][0])
    {
        return $this->religionIndianFullBatchAsyncWithHttpInfo($batch_personal_name_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religionIndianFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full Indian names, provided the subclassification at State or Union territory level (NB/ can be inferred using the subclassification endpoint).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionIndianFullBatchAsyncWithHttpInfo($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameReligionedOut';
        $request = $this->religionIndianFullBatchRequest($batch_personal_name_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religionIndianFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameSubdivisionIn|null $batch_personal_name_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religionIndianFullBatchRequest($batch_personal_name_subdivision_in = null, string $contentType = self::contentTypes['religionIndianFullBatch'][0])
    {



        $resourcePath = '/api2/json/religionIndianFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_subdivision_in));
            } else {
                $httpBody = $batch_personal_name_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationIndian
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndian'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGeoSubclassificationOut
     */
    public function subclassificationIndian($first_name, $last_name, string $contentType = self::contentTypes['subclassificationIndian'][0])
    {
        list($response) = $this->subclassificationIndianWithHttpInfo($first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationIndianWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndian'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationIndianWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['subclassificationIndian'][0])
    {
        $request = $this->subclassificationIndianRequest($first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationIndianAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndian'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianAsync($first_name, $last_name, string $contentType = self::contentTypes['subclassificationIndian'][0])
    {
        return $this->subclassificationIndianAsyncWithHttpInfo($first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationIndianAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndian'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianAsyncWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['subclassificationIndian'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut';
        $request = $this->subclassificationIndianRequest($first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationIndian'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndian'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationIndianRequest($first_name, $last_name, string $contentType = self::contentTypes['subclassificationIndian'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling subclassificationIndian'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling subclassificationIndian'
            );
        }


        $resourcePath = '/api2/json/subclassificationIndian/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationIndianBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut
     */
    public function subclassificationIndianBatch($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianBatch'][0])
    {
        list($response) = $this->subclassificationIndianBatchWithHttpInfo($batch_first_last_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationIndianBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationIndianBatchWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianBatch'][0])
    {
        $request = $this->subclassificationIndianBatchRequest($batch_first_last_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationIndianBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianBatchAsync($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianBatch'][0])
    {
        return $this->subclassificationIndianBatchAsyncWithHttpInfo($batch_first_last_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationIndianBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianBatchAsyncWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut';
        $request = $this->subclassificationIndianBatchRequest($batch_first_last_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationIndianBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationIndianBatchRequest($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianBatch'][0])
    {



        $resourcePath = '/api2/json/subclassificationIndianBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_in));
            } else {
                $httpBody = $batch_first_last_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationIndianFull
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $full_name full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameGeoSubclassificationOut
     */
    public function subclassificationIndianFull($full_name, string $contentType = self::contentTypes['subclassificationIndianFull'][0])
    {
        list($response) = $this->subclassificationIndianFullWithHttpInfo($full_name, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationIndianFullWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationIndianFullWithHttpInfo($full_name, string $contentType = self::contentTypes['subclassificationIndianFull'][0])
    {
        $request = $this->subclassificationIndianFullRequest($full_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationIndianFullAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianFullAsync($full_name, string $contentType = self::contentTypes['subclassificationIndianFull'][0])
    {
        return $this->subclassificationIndianFullAsyncWithHttpInfo($full_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationIndianFullAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on the name.
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianFullAsyncWithHttpInfo($full_name, string $contentType = self::contentTypes['subclassificationIndianFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameGeoSubclassificationOut';
        $request = $this->subclassificationIndianFullRequest($full_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationIndianFull'
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationIndianFullRequest($full_name, string $contentType = self::contentTypes['subclassificationIndianFull'][0])
    {

        // verify the required parameter 'full_name' is set
        if ($full_name === null || (is_array($full_name) && count($full_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $full_name when calling subclassificationIndianFull'
            );
        }


        $resourcePath = '/api2/json/subclassificationIndianFull/{fullName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($full_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fullName' . '}',
                ObjectSerializer::toPathValue($full_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationIndianFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut
     */
    public function subclassificationIndianFullBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianFullBatch'][0])
    {
        list($response) = $this->subclassificationIndianFullBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationIndianFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationIndianFullBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianFullBatch'][0])
    {
        $request = $this->subclassificationIndianFullBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationIndianFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianFullBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianFullBatch'][0])
    {
        return $this->subclassificationIndianFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationIndianFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely Indian state of Union territory according to ISO 3166-2:IN based on a list of up to 100 names.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationIndianFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut';
        $request = $this->subclassificationIndianFullBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationIndianFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationIndianFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationIndianFullBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationIndianFullBatch'][0])
    {



        $resourcePath = '/api2/json/subclassificationIndianFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
