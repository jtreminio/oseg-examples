<?php
/**
 * JapaneseApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NamSor API v2
 *
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!
 *
 * The version of the OpenAPI document: 2.0.29
 * Contact: contact@namsor.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Namsor\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Namsor\Client\ApiException;
use Namsor\Client\Configuration;
use Namsor\Client\HeaderSelector;
use Namsor\Client\ObjectSerializer;

/**
 * JapaneseApi Class Doc Comment
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class JapaneseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'genderJapaneseNameFull' => [
            'application/json',
        ],
        'genderJapaneseNameFullBatch' => [
            'application/json',
        ],
        'genderJapaneseNamePinyin' => [
            'application/json',
        ],
        'genderJapaneseNamePinyinBatch' => [
            'application/json',
        ],
        'japaneseNameGenderKanjiCandidatesBatch' => [
            'application/json',
        ],
        'japaneseNameKanjiCandidates' => [
            'application/json',
        ],
        'japaneseNameKanjiCandidates1' => [
            'application/json',
        ],
        'japaneseNameKanjiCandidatesBatch' => [
            'application/json',
        ],
        'japaneseNameLatinCandidates' => [
            'application/json',
        ],
        'japaneseNameLatinCandidatesBatch' => [
            'application/json',
        ],
        'japaneseNameMatch' => [
            'application/json',
        ],
        'japaneseNameMatchBatch' => [
            'application/json',
        ],
        'japaneseNameMatchFeedbackLoop' => [
            'application/json',
        ],
        'parseJapaneseName' => [
            'application/json',
        ],
        'parseJapaneseNameBatch' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation genderJapaneseNameFull
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameGenderedOut
     */
    public function genderJapaneseNameFull($japanese_name, string $contentType = self::contentTypes['genderJapaneseNameFull'][0])
    {
        list($response) = $this->genderJapaneseNameFullWithHttpInfo($japanese_name, $contentType);
        return $response;
    }

    /**
     * Operation genderJapaneseNameFullWithHttpInfo
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNameFullWithHttpInfo($japanese_name, string $contentType = self::contentTypes['genderJapaneseNameFull'][0])
    {
        $request = $this->genderJapaneseNameFullRequest($japanese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNameFullAsync
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullAsync($japanese_name, string $contentType = self::contentTypes['genderJapaneseNameFull'][0])
    {
        return $this->genderJapaneseNameFullAsyncWithHttpInfo($japanese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNameFullAsyncWithHttpInfo
     *
     * Infer the likely gender of a Japanese full name ex. 王晓明
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullAsyncWithHttpInfo($japanese_name, string $contentType = self::contentTypes['genderJapaneseNameFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
        $request = $this->genderJapaneseNameFullRequest($japanese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNameFull'
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderJapaneseNameFullRequest($japanese_name, string $contentType = self::contentTypes['genderJapaneseNameFull'][0])
    {

        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling genderJapaneseNameFull'
            );
        }


        $resourcePath = '/api2/json/genderJapaneseNameFull/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderJapaneseNameFullBatch
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGenderedOut
     */
    public function genderJapaneseNameFullBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['genderJapaneseNameFullBatch'][0])
    {
        list($response) = $this->genderJapaneseNameFullBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation genderJapaneseNameFullBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNameFullBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['genderJapaneseNameFullBatch'][0])
    {
        $request = $this->genderJapaneseNameFullBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNameFullBatchAsync
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['genderJapaneseNameFullBatch'][0])
    {
        return $this->genderJapaneseNameFullBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNameFullBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNameFullBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['genderJapaneseNameFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
        $request = $this->genderJapaneseNameFullBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNameFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNameFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderJapaneseNameFullBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['genderJapaneseNameFullBatch'][0])
    {



        $resourcePath = '/api2/json/genderJapaneseNameFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderJapaneseNamePinyin
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname japanese_surname (required)
     * @param  string $japanese_given_name japanese_given_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyin'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGenderedOut
     */
    public function genderJapaneseNamePinyin($japanese_surname, $japanese_given_name, string $contentType = self::contentTypes['genderJapaneseNamePinyin'][0])
    {
        list($response) = $this->genderJapaneseNamePinyinWithHttpInfo($japanese_surname, $japanese_given_name, $contentType);
        return $response;
    }

    /**
     * Operation genderJapaneseNamePinyinWithHttpInfo
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyin'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNamePinyinWithHttpInfo($japanese_surname, $japanese_given_name, string $contentType = self::contentTypes['genderJapaneseNamePinyin'][0])
    {
        $request = $this->genderJapaneseNamePinyinRequest($japanese_surname, $japanese_given_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNamePinyinAsync
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinAsync($japanese_surname, $japanese_given_name, string $contentType = self::contentTypes['genderJapaneseNamePinyin'][0])
    {
        return $this->genderJapaneseNamePinyinAsyncWithHttpInfo($japanese_surname, $japanese_given_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNamePinyinAsyncWithHttpInfo
     *
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinAsyncWithHttpInfo($japanese_surname, $japanese_given_name, string $contentType = self::contentTypes['genderJapaneseNamePinyin'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
        $request = $this->genderJapaneseNamePinyinRequest($japanese_surname, $japanese_given_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNamePinyin'
     *
     * @param  string $japanese_surname (required)
     * @param  string $japanese_given_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderJapaneseNamePinyinRequest($japanese_surname, $japanese_given_name, string $contentType = self::contentTypes['genderJapaneseNamePinyin'][0])
    {

        // verify the required parameter 'japanese_surname' is set
        if ($japanese_surname === null || (is_array($japanese_surname) && count($japanese_surname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname when calling genderJapaneseNamePinyin'
            );
        }

        // verify the required parameter 'japanese_given_name' is set
        if ($japanese_given_name === null || (is_array($japanese_given_name) && count($japanese_given_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name when calling genderJapaneseNamePinyin'
            );
        }


        $resourcePath = '/api2/json/genderJapaneseName/{japaneseSurname}/{japaneseGivenName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_surname !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurname' . '}',
                ObjectSerializer::toPathValue($japanese_surname),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenName' . '}',
                ObjectSerializer::toPathValue($japanese_given_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderJapaneseNamePinyinBatch
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGenderedOut
     */
    public function genderJapaneseNamePinyinBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderJapaneseNamePinyinBatch'][0])
    {
        list($response) = $this->genderJapaneseNamePinyinBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation genderJapaneseNamePinyinBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderJapaneseNamePinyinBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderJapaneseNamePinyinBatch'][0])
    {
        $request = $this->genderJapaneseNamePinyinBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderJapaneseNamePinyinBatchAsync
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderJapaneseNamePinyinBatch'][0])
    {
        return $this->genderJapaneseNamePinyinBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderJapaneseNamePinyinBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderJapaneseNamePinyinBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderJapaneseNamePinyinBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
        $request = $this->genderJapaneseNamePinyinBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderJapaneseNamePinyinBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderJapaneseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderJapaneseNamePinyinBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderJapaneseNamePinyinBatch'][0])
    {



        $resourcePath = '/api2/json/genderJapaneseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameGenderKanjiCandidatesBatch
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchCandidatesOut
     */
    public function japaneseNameGenderKanjiCandidatesBatch($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'][0])
    {
        list($response) = $this->japaneseNameGenderKanjiCandidatesBatchWithHttpInfo($batch_first_last_name_gender_in, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameGenderKanjiCandidatesBatchWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameGenderKanjiCandidatesBatchWithHttpInfo($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'][0])
    {
        $request = $this->japaneseNameGenderKanjiCandidatesBatchRequest($batch_first_last_name_gender_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameGenderKanjiCandidatesBatchAsync
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameGenderKanjiCandidatesBatchAsync($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'][0])
    {
        return $this->japaneseNameGenderKanjiCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_gender_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameGenderKanjiCandidatesBatchAsyncWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameGenderKanjiCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->japaneseNameGenderKanjiCandidatesBatchRequest($batch_first_last_name_gender_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameGenderKanjiCandidatesBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameGenderKanjiCandidatesBatchRequest($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['japaneseNameGenderKanjiCandidatesBatch'][0])
    {



        $resourcePath = '/api2/json/japaneseNameGenderKanjiCandidatesBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_gender_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_gender_in));
            } else {
                $httpBody = $batch_first_last_name_gender_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameKanjiCandidates
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     * @param  string $known_gender known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchCandidatesOut
     */
    public function japaneseNameKanjiCandidates($japanese_surname_latin, $japanese_given_name_latin, $known_gender, string $contentType = self::contentTypes['japaneseNameKanjiCandidates'][0])
    {
        list($response) = $this->japaneseNameKanjiCandidatesWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $known_gender, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameKanjiCandidatesWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameKanjiCandidatesWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $known_gender, string $contentType = self::contentTypes['japaneseNameKanjiCandidates'][0])
    {
        $request = $this->japaneseNameKanjiCandidatesRequest($japanese_surname_latin, $japanese_given_name_latin, $known_gender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameKanjiCandidatesAsync
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesAsync($japanese_surname_latin, $japanese_given_name_latin, $known_gender, string $contentType = self::contentTypes['japaneseNameKanjiCandidates'][0])
    {
        return $this->japaneseNameKanjiCandidatesAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $known_gender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameKanjiCandidatesAsyncWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $known_gender, string $contentType = self::contentTypes['japaneseNameKanjiCandidates'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
        $request = $this->japaneseNameKanjiCandidatesRequest($japanese_surname_latin, $japanese_given_name_latin, $known_gender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameKanjiCandidates'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameKanjiCandidatesRequest($japanese_surname_latin, $japanese_given_name_latin, $known_gender, string $contentType = self::contentTypes['japaneseNameKanjiCandidates'][0])
    {

        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameKanjiCandidates'
            );
        }

        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameKanjiCandidates'
            );
        }

        // verify the required parameter 'known_gender' is set
        if ($known_gender === null || (is_array($known_gender) && count($known_gender) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $known_gender when calling japaneseNameKanjiCandidates'
            );
        }


        $resourcePath = '/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{knownGender}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($known_gender !== null) {
            $resourcePath = str_replace(
                '{' . 'knownGender' . '}',
                ObjectSerializer::toPathValue($known_gender),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameKanjiCandidates1
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates1'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchCandidatesOut
     */
    public function japaneseNameKanjiCandidates1($japanese_surname_latin, $japanese_given_name_latin, string $contentType = self::contentTypes['japaneseNameKanjiCandidates1'][0])
    {
        list($response) = $this->japaneseNameKanjiCandidates1WithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameKanjiCandidates1WithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates1'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameKanjiCandidates1WithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, string $contentType = self::contentTypes['japaneseNameKanjiCandidates1'][0])
    {
        $request = $this->japaneseNameKanjiCandidates1Request($japanese_surname_latin, $japanese_given_name_latin, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameKanjiCandidates1Async
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidates1Async($japanese_surname_latin, $japanese_given_name_latin, string $contentType = self::contentTypes['japaneseNameKanjiCandidates1'][0])
    {
        return $this->japaneseNameKanjiCandidates1AsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameKanjiCandidates1AsyncWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidates1AsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, string $contentType = self::contentTypes['japaneseNameKanjiCandidates1'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
        $request = $this->japaneseNameKanjiCandidates1Request($japanese_surname_latin, $japanese_given_name_latin, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameKanjiCandidates1'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidates1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameKanjiCandidates1Request($japanese_surname_latin, $japanese_given_name_latin, string $contentType = self::contentTypes['japaneseNameKanjiCandidates1'][0])
    {

        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameKanjiCandidates1'
            );
        }

        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameKanjiCandidates1'
            );
        }


        $resourcePath = '/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatch
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchCandidatesOut
     */
    public function japaneseNameKanjiCandidatesBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameKanjiCandidatesBatch'][0])
    {
        list($response) = $this->japaneseNameKanjiCandidatesBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatchWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameKanjiCandidatesBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameKanjiCandidatesBatch'][0])
    {
        $request = $this->japaneseNameKanjiCandidatesBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatchAsync
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameKanjiCandidatesBatch'][0])
    {
        return $this->japaneseNameKanjiCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameKanjiCandidatesBatchAsyncWithHttpInfo
     *
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname), ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameKanjiCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameKanjiCandidatesBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->japaneseNameKanjiCandidatesBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameKanjiCandidatesBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameKanjiCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameKanjiCandidatesBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameKanjiCandidatesBatch'][0])
    {



        $resourcePath = '/api2/json/japaneseNameKanjiCandidatesBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameLatinCandidates
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji japanese_given_name_kanji (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchCandidatesOut
     */
    public function japaneseNameLatinCandidates($japanese_surname_kanji, $japanese_given_name_kanji, string $contentType = self::contentTypes['japaneseNameLatinCandidates'][0])
    {
        list($response) = $this->japaneseNameLatinCandidatesWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameLatinCandidatesWithHttpInfo
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameLatinCandidatesWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji, string $contentType = self::contentTypes['japaneseNameLatinCandidates'][0])
    {
        $request = $this->japaneseNameLatinCandidatesRequest($japanese_surname_kanji, $japanese_given_name_kanji, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameLatinCandidatesAsync
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesAsync($japanese_surname_kanji, $japanese_given_name_kanji, string $contentType = self::contentTypes['japaneseNameLatinCandidates'][0])
    {
        return $this->japaneseNameLatinCandidatesAsyncWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameLatinCandidatesAsyncWithHttpInfo
     *
     * Romanize japanese name, based on the name in Kanji.
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesAsyncWithHttpInfo($japanese_surname_kanji, $japanese_given_name_kanji, string $contentType = self::contentTypes['japaneseNameLatinCandidates'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
        $request = $this->japaneseNameLatinCandidatesRequest($japanese_surname_kanji, $japanese_given_name_kanji, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameLatinCandidates'
     *
     * @param  string $japanese_surname_kanji (required)
     * @param  string $japanese_given_name_kanji (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameLatinCandidatesRequest($japanese_surname_kanji, $japanese_given_name_kanji, string $contentType = self::contentTypes['japaneseNameLatinCandidates'][0])
    {

        // verify the required parameter 'japanese_surname_kanji' is set
        if ($japanese_surname_kanji === null || (is_array($japanese_surname_kanji) && count($japanese_surname_kanji) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_kanji when calling japaneseNameLatinCandidates'
            );
        }

        // verify the required parameter 'japanese_given_name_kanji' is set
        if ($japanese_given_name_kanji === null || (is_array($japanese_given_name_kanji) && count($japanese_given_name_kanji) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_kanji when calling japaneseNameLatinCandidates'
            );
        }


        $resourcePath = '/api2/json/japaneseNameLatinCandidates/{japaneseSurnameKanji}/{japaneseGivenNameKanji}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_surname_kanji !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameKanji' . '}',
                ObjectSerializer::toPathValue($japanese_surname_kanji),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_kanji !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameKanji' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_kanji),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameLatinCandidatesBatch
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchCandidatesOut
     */
    public function japaneseNameLatinCandidatesBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameLatinCandidatesBatch'][0])
    {
        list($response) = $this->japaneseNameLatinCandidatesBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameLatinCandidatesBatchWithHttpInfo
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameLatinCandidatesBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameLatinCandidatesBatch'][0])
    {
        $request = $this->japaneseNameLatinCandidatesBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameLatinCandidatesBatchAsync
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameLatinCandidatesBatch'][0])
    {
        return $this->japaneseNameLatinCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameLatinCandidatesBatchAsyncWithHttpInfo
     *
     * Romanize japanese names, based on the name in KANJI
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameLatinCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameLatinCandidatesBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->japaneseNameLatinCandidatesBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameLatinCandidatesBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameLatinCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameLatinCandidatesBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameLatinCandidatesBatch'][0])
    {



        $resourcePath = '/api2/json/japaneseNameLatinCandidatesBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameMatch
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     * @param  string $japanese_name japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchedOut
     */
    public function japaneseNameMatch($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatch'][0])
    {
        list($response) = $this->japaneseNameMatchWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameMatchWithHttpInfo
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameMatchWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatch'][0])
    {
        $request = $this->japaneseNameMatchRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameMatchAsync
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchAsync($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatch'][0])
    {
        return $this->japaneseNameMatchAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameMatchAsyncWithHttpInfo
     *
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatch'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchedOut';
        $request = $this->japaneseNameMatchRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameMatch'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameMatchRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatch'][0])
    {

        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameMatch'
            );
        }

        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameMatch'
            );
        }

        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling japaneseNameMatch'
            );
        }


        $resourcePath = '/api2/json/japaneseNameMatch/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameMatchBatch
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchedOut
     */
    public function japaneseNameMatchBatch($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameMatchBatch'][0])
    {
        list($response) = $this->japaneseNameMatchBatchWithHttpInfo($batch_match_personal_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameMatchBatchWithHttpInfo
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameMatchBatchWithHttpInfo($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameMatchBatch'][0])
    {
        $request = $this->japaneseNameMatchBatchRequest($batch_match_personal_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameMatchBatchAsync
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchBatchAsync($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameMatchBatch'][0])
    {
        return $this->japaneseNameMatchBatchAsyncWithHttpInfo($batch_match_personal_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameMatchBatchAsyncWithHttpInfo
     *
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchBatchAsyncWithHttpInfo($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameMatchBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchedOut';
        $request = $this->japaneseNameMatchBatchRequest($batch_match_personal_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameMatchBatch'
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameMatchBatchRequest($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['japaneseNameMatchBatch'][0])
    {



        $resourcePath = '/api2/json/japaneseNameMatchBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_match_personal_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_match_personal_first_last_name_in));
            } else {
                $httpBody = $batch_match_personal_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation japaneseNameMatchFeedbackLoop
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin japanese_given_name_latin (required)
     * @param  string $japanese_name japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchFeedbackLoop'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FeedbackLoopOut
     */
    public function japaneseNameMatchFeedbackLoop($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatchFeedbackLoop'][0])
    {
        list($response) = $this->japaneseNameMatchFeedbackLoopWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType);
        return $response;
    }

    /**
     * Operation japaneseNameMatchFeedbackLoopWithHttpInfo
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchFeedbackLoop'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FeedbackLoopOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function japaneseNameMatchFeedbackLoopWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatchFeedbackLoop'][0])
    {
        $request = $this->japaneseNameMatchFeedbackLoopRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FeedbackLoopOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FeedbackLoopOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FeedbackLoopOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FeedbackLoopOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FeedbackLoopOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation japaneseNameMatchFeedbackLoopAsync
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchFeedbackLoop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchFeedbackLoopAsync($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatchFeedbackLoop'][0])
    {
        return $this->japaneseNameMatchFeedbackLoopAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation japaneseNameMatchFeedbackLoopAsyncWithHttpInfo
     *
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchFeedbackLoop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function japaneseNameMatchFeedbackLoopAsyncWithHttpInfo($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatchFeedbackLoop'][0])
    {
        $returnType = '\Namsor\Client\Model\FeedbackLoopOut';
        $request = $this->japaneseNameMatchFeedbackLoopRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'japaneseNameMatchFeedbackLoop'
     *
     * @param  string $japanese_surname_latin (required)
     * @param  string $japanese_given_name_latin (required)
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['japaneseNameMatchFeedbackLoop'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function japaneseNameMatchFeedbackLoopRequest($japanese_surname_latin, $japanese_given_name_latin, $japanese_name, string $contentType = self::contentTypes['japaneseNameMatchFeedbackLoop'][0])
    {

        // verify the required parameter 'japanese_surname_latin' is set
        if ($japanese_surname_latin === null || (is_array($japanese_surname_latin) && count($japanese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_surname_latin when calling japaneseNameMatchFeedbackLoop'
            );
        }

        // verify the required parameter 'japanese_given_name_latin' is set
        if ($japanese_given_name_latin === null || (is_array($japanese_given_name_latin) && count($japanese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_given_name_latin when calling japaneseNameMatchFeedbackLoop'
            );
        }

        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling japaneseNameMatchFeedbackLoop'
            );
        }


        $resourcePath = '/api2/json/japaneseNameMatchFeedbackLoop/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($japanese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseJapaneseName
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameParsedOut
     */
    public function parseJapaneseName($japanese_name, string $contentType = self::contentTypes['parseJapaneseName'][0])
    {
        list($response) = $this->parseJapaneseNameWithHttpInfo($japanese_name, $contentType);
        return $response;
    }

    /**
     * Operation parseJapaneseNameWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseJapaneseNameWithHttpInfo($japanese_name, string $contentType = self::contentTypes['parseJapaneseName'][0])
    {
        $request = $this->parseJapaneseNameRequest($japanese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseJapaneseNameAsync
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameAsync($japanese_name, string $contentType = self::contentTypes['parseJapaneseName'][0])
    {
        return $this->parseJapaneseNameAsyncWithHttpInfo($japanese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseJapaneseNameAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameAsyncWithHttpInfo($japanese_name, string $contentType = self::contentTypes['parseJapaneseName'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
        $request = $this->parseJapaneseNameRequest($japanese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseJapaneseName'
     *
     * @param  string $japanese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseJapaneseNameRequest($japanese_name, string $contentType = self::contentTypes['parseJapaneseName'][0])
    {

        // verify the required parameter 'japanese_name' is set
        if ($japanese_name === null || (is_array($japanese_name) && count($japanese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $japanese_name when calling parseJapaneseName'
            );
        }


        $resourcePath = '/api2/json/parseJapaneseName/{japaneseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($japanese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'japaneseName' . '}',
                ObjectSerializer::toPathValue($japanese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseJapaneseNameBatch
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameParsedOut
     */
    public function parseJapaneseNameBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['parseJapaneseNameBatch'][0])
    {
        list($response) = $this->parseJapaneseNameBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation parseJapaneseNameBatchWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseJapaneseNameBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['parseJapaneseNameBatch'][0])
    {
        $request = $this->parseJapaneseNameBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseJapaneseNameBatchAsync
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['parseJapaneseNameBatch'][0])
    {
        return $this->parseJapaneseNameBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseJapaneseNameBatchAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseJapaneseNameBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['parseJapaneseNameBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
        $request = $this->parseJapaneseNameBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseJapaneseNameBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseJapaneseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseJapaneseNameBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['parseJapaneseNameBatch'][0])
    {



        $resourcePath = '/api2/json/parseJapaneseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
