<?php
/**
 * PersonalApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NamSor API v2
 *
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!
 *
 * The version of the OpenAPI document: 2.0.29
 * Contact: contact@namsor.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Namsor\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Namsor\Client\ApiException;
use Namsor\Client\Configuration;
use Namsor\Client\HeaderSelector;
use Namsor\Client\ObjectSerializer;

/**
 * PersonalApi Class Doc Comment
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class PersonalApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'communityEngage' => [
            'application/json',
        ],
        'communityEngageBatch' => [
            'application/json',
        ],
        'communityEngageFull' => [
            'application/json',
        ],
        'communityEngageFullBatch' => [
            'application/json',
        ],
        'corridor' => [
            'application/json',
        ],
        'corridorBatch' => [
            'application/json',
        ],
        'country' => [
            'application/json',
        ],
        'countryBatch' => [
            'application/json',
        ],
        'countryFnLn' => [
            'application/json',
        ],
        'countryFnLnBatch' => [
            'application/json',
        ],
        'diaspora' => [
            'application/json',
        ],
        'diasporaBatch' => [
            'application/json',
        ],
        'diasporaFull' => [
            'application/json',
        ],
        'diasporaFullBatch' => [
            'application/json',
        ],
        'gender' => [
            'application/json',
        ],
        'gender1' => [
            'application/json',
        ],
        'genderBatch' => [
            'application/json',
        ],
        'genderFull' => [
            'application/json',
        ],
        'genderFullBatch' => [
            'application/json',
        ],
        'genderFullGeo' => [
            'application/json',
        ],
        'genderFullGeoBatch' => [
            'application/json',
        ],
        'genderGeo' => [
            'application/json',
        ],
        'genderGeoBatch' => [
            'application/json',
        ],
        'origin' => [
            'application/json',
        ],
        'originBatch' => [
            'application/json',
        ],
        'originFull' => [
            'application/json',
        ],
        'originFullBatch' => [
            'application/json',
        ],
        'parseName' => [
            'application/json',
        ],
        'parseNameBatch' => [
            'application/json',
        ],
        'parseNameGeo' => [
            'application/json',
        ],
        'parseNameGeoBatch' => [
            'application/json',
        ],
        'religion2' => [
            'application/json',
        ],
        'religionBatch' => [
            'application/json',
        ],
        'religionFull' => [
            'application/json',
        ],
        'religionFullBatch' => [
            'application/json',
        ],
        'subclassification' => [
            'application/json',
        ],
        'subclassificationBatch' => [
            'application/json',
        ],
        'subclassificationFull' => [
            'application/json',
        ],
        'subclassificationFullBatch' => [
            'application/json',
        ],
        'usRaceEthnicity' => [
            'application/json',
        ],
        'usRaceEthnicityBatch' => [
            'application/json',
        ],
        'usRaceEthnicityFull' => [
            'application/json',
        ],
        'usRaceEthnicityFullBatch' => [
            'application/json',
        ],
        'usRaceEthnicityZIP5' => [
            'application/json',
        ],
        'usZipRaceEthnicityBatch' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation communityEngage
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngage'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\CommunityEngageOut
     */
    public function communityEngage($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['communityEngage'][0])
    {
        list($response) = $this->communityEngageWithHttpInfo($country_iso2, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation communityEngageWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngage'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\CommunityEngageOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function communityEngageWithHttpInfo($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['communityEngage'][0])
    {
        $request = $this->communityEngageRequest($country_iso2, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\CommunityEngageOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\CommunityEngageOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\CommunityEngageOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\CommunityEngageOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\CommunityEngageOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation communityEngageAsync
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageAsync($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['communityEngage'][0])
    {
        return $this->communityEngageAsyncWithHttpInfo($country_iso2, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation communityEngageAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageAsyncWithHttpInfo($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['communityEngage'][0])
    {
        $returnType = '\Namsor\Client\Model\CommunityEngageOut';
        $request = $this->communityEngageRequest($country_iso2, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'communityEngage'
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function communityEngageRequest($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['communityEngage'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling communityEngage'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling communityEngage'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling communityEngage'
            );
        }


        $resourcePath = '/api2/json/communityEngage/{countryIso2}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation communityEngageBatch
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchCommunityEngageOut
     */
    public function communityEngageBatch($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['communityEngageBatch'][0])
    {
        list($response) = $this->communityEngageBatchWithHttpInfo($batch_first_last_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation communityEngageBatchWithHttpInfo
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchCommunityEngageOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function communityEngageBatchWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['communityEngageBatch'][0])
    {
        $request = $this->communityEngageBatchRequest($batch_first_last_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchCommunityEngageOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchCommunityEngageOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchCommunityEngageOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchCommunityEngageOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchCommunityEngageOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation communityEngageBatchAsync
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageBatchAsync($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['communityEngageBatch'][0])
    {
        return $this->communityEngageBatchAsyncWithHttpInfo($batch_first_last_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation communityEngageBatchAsyncWithHttpInfo
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageBatchAsyncWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['communityEngageBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchCommunityEngageOut';
        $request = $this->communityEngageBatchRequest($batch_first_last_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'communityEngageBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function communityEngageBatchRequest($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['communityEngageBatch'][0])
    {



        $resourcePath = '/api2/json/communityEngageBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_in));
            } else {
                $httpBody = $batch_first_last_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation communityEngageFull
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\CommunityEngageOut
     */
    public function communityEngageFull($country_iso2, $personal_name_full, string $contentType = self::contentTypes['communityEngageFull'][0])
    {
        list($response) = $this->communityEngageFullWithHttpInfo($country_iso2, $personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation communityEngageFullWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\CommunityEngageOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function communityEngageFullWithHttpInfo($country_iso2, $personal_name_full, string $contentType = self::contentTypes['communityEngageFull'][0])
    {
        $request = $this->communityEngageFullRequest($country_iso2, $personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\CommunityEngageOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\CommunityEngageOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\CommunityEngageOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\CommunityEngageOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\CommunityEngageOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation communityEngageFullAsync
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageFullAsync($country_iso2, $personal_name_full, string $contentType = self::contentTypes['communityEngageFull'][0])
    {
        return $this->communityEngageFullAsyncWithHttpInfo($country_iso2, $personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation communityEngageFullAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageFullAsyncWithHttpInfo($country_iso2, $personal_name_full, string $contentType = self::contentTypes['communityEngageFull'][0])
    {
        $returnType = '\Namsor\Client\Model\CommunityEngageOut';
        $request = $this->communityEngageFullRequest($country_iso2, $personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'communityEngageFull'
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function communityEngageFullRequest($country_iso2, $personal_name_full, string $contentType = self::contentTypes['communityEngageFull'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling communityEngageFull'
            );
        }

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling communityEngageFull'
            );
        }


        $resourcePath = '/api2/json/communityEngageFull/{countryIso2}/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation communityEngageFullBatch
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchCommunityEngageFullOut
     */
    public function communityEngageFullBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['communityEngageFullBatch'][0])
    {
        list($response) = $this->communityEngageFullBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation communityEngageFullBatchWithHttpInfo
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchCommunityEngageFullOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function communityEngageFullBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['communityEngageFullBatch'][0])
    {
        $request = $this->communityEngageFullBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchCommunityEngageFullOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchCommunityEngageFullOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchCommunityEngageFullOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchCommunityEngageFullOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchCommunityEngageFullOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation communityEngageFullBatchAsync
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageFullBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['communityEngageFullBatch'][0])
    {
        return $this->communityEngageFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation communityEngageFullBatchAsyncWithHttpInfo
     *
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function communityEngageFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['communityEngageFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchCommunityEngageFullOut';
        $request = $this->communityEngageFullBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'communityEngageFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['communityEngageFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function communityEngageFullBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['communityEngageFullBatch'][0])
    {



        $resourcePath = '/api2/json/communityEngageFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation corridor
     *
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  string $country_iso2_from country_iso2_from (required)
     * @param  string $first_name_from first_name_from (required)
     * @param  string $last_name_from last_name_from (required)
     * @param  string $country_iso2_to country_iso2_to (required)
     * @param  string $first_name_to first_name_to (required)
     * @param  string $last_name_to last_name_to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridor'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\CorridorOut
     */
    public function corridor($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, string $contentType = self::contentTypes['corridor'][0])
    {
        list($response) = $this->corridorWithHttpInfo($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, $contentType);
        return $response;
    }

    /**
     * Operation corridorWithHttpInfo
     *
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  string $country_iso2_from (required)
     * @param  string $first_name_from (required)
     * @param  string $last_name_from (required)
     * @param  string $country_iso2_to (required)
     * @param  string $first_name_to (required)
     * @param  string $last_name_to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridor'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\CorridorOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function corridorWithHttpInfo($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, string $contentType = self::contentTypes['corridor'][0])
    {
        $request = $this->corridorRequest($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\CorridorOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\CorridorOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\CorridorOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\CorridorOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\CorridorOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation corridorAsync
     *
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  string $country_iso2_from (required)
     * @param  string $first_name_from (required)
     * @param  string $last_name_from (required)
     * @param  string $country_iso2_to (required)
     * @param  string $first_name_to (required)
     * @param  string $last_name_to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function corridorAsync($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, string $contentType = self::contentTypes['corridor'][0])
    {
        return $this->corridorAsyncWithHttpInfo($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation corridorAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  string $country_iso2_from (required)
     * @param  string $first_name_from (required)
     * @param  string $last_name_from (required)
     * @param  string $country_iso2_to (required)
     * @param  string $first_name_to (required)
     * @param  string $last_name_to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function corridorAsyncWithHttpInfo($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, string $contentType = self::contentTypes['corridor'][0])
    {
        $returnType = '\Namsor\Client\Model\CorridorOut';
        $request = $this->corridorRequest($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'corridor'
     *
     * @param  string $country_iso2_from (required)
     * @param  string $first_name_from (required)
     * @param  string $last_name_from (required)
     * @param  string $country_iso2_to (required)
     * @param  string $first_name_to (required)
     * @param  string $last_name_to (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridor'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function corridorRequest($country_iso2_from, $first_name_from, $last_name_from, $country_iso2_to, $first_name_to, $last_name_to, string $contentType = self::contentTypes['corridor'][0])
    {

        // verify the required parameter 'country_iso2_from' is set
        if ($country_iso2_from === null || (is_array($country_iso2_from) && count($country_iso2_from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2_from when calling corridor'
            );
        }

        // verify the required parameter 'first_name_from' is set
        if ($first_name_from === null || (is_array($first_name_from) && count($first_name_from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name_from when calling corridor'
            );
        }

        // verify the required parameter 'last_name_from' is set
        if ($last_name_from === null || (is_array($last_name_from) && count($last_name_from) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name_from when calling corridor'
            );
        }

        // verify the required parameter 'country_iso2_to' is set
        if ($country_iso2_to === null || (is_array($country_iso2_to) && count($country_iso2_to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2_to when calling corridor'
            );
        }

        // verify the required parameter 'first_name_to' is set
        if ($first_name_to === null || (is_array($first_name_to) && count($first_name_to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name_to when calling corridor'
            );
        }

        // verify the required parameter 'last_name_to' is set
        if ($last_name_to === null || (is_array($last_name_to) && count($last_name_to) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name_to when calling corridor'
            );
        }


        $resourcePath = '/api2/json/corridor/{countryIso2From}/{firstNameFrom}/{lastNameFrom}/{countryIso2To}/{firstNameTo}/{lastNameTo}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2_from !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2From' . '}',
                ObjectSerializer::toPathValue($country_iso2_from),
                $resourcePath
            );
        }
        // path params
        if ($first_name_from !== null) {
            $resourcePath = str_replace(
                '{' . 'firstNameFrom' . '}',
                ObjectSerializer::toPathValue($first_name_from),
                $resourcePath
            );
        }
        // path params
        if ($last_name_from !== null) {
            $resourcePath = str_replace(
                '{' . 'lastNameFrom' . '}',
                ObjectSerializer::toPathValue($last_name_from),
                $resourcePath
            );
        }
        // path params
        if ($country_iso2_to !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2To' . '}',
                ObjectSerializer::toPathValue($country_iso2_to),
                $resourcePath
            );
        }
        // path params
        if ($first_name_to !== null) {
            $resourcePath = str_replace(
                '{' . 'firstNameTo' . '}',
                ObjectSerializer::toPathValue($first_name_to),
                $resourcePath
            );
        }
        // path params
        if ($last_name_to !== null) {
            $resourcePath = str_replace(
                '{' . 'lastNameTo' . '}',
                ObjectSerializer::toPathValue($last_name_to),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation corridorBatch
     *
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  \Namsor\Client\Model\BatchCorridorIn|null $batch_corridor_in A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridorBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchCorridorOut
     */
    public function corridorBatch($batch_corridor_in = null, string $contentType = self::contentTypes['corridorBatch'][0])
    {
        list($response) = $this->corridorBatchWithHttpInfo($batch_corridor_in, $contentType);
        return $response;
    }

    /**
     * Operation corridorBatchWithHttpInfo
     *
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  \Namsor\Client\Model\BatchCorridorIn|null $batch_corridor_in A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridorBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchCorridorOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function corridorBatchWithHttpInfo($batch_corridor_in = null, string $contentType = self::contentTypes['corridorBatch'][0])
    {
        $request = $this->corridorBatchRequest($batch_corridor_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchCorridorOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchCorridorOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchCorridorOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchCorridorOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchCorridorOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation corridorBatchAsync
     *
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  \Namsor\Client\Model\BatchCorridorIn|null $batch_corridor_in A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridorBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function corridorBatchAsync($batch_corridor_in = null, string $contentType = self::contentTypes['corridorBatch'][0])
    {
        return $this->corridorBatchAsyncWithHttpInfo($batch_corridor_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation corridorBatchAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     *
     * @param  \Namsor\Client\Model\BatchCorridorIn|null $batch_corridor_in A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridorBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function corridorBatchAsyncWithHttpInfo($batch_corridor_in = null, string $contentType = self::contentTypes['corridorBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchCorridorOut';
        $request = $this->corridorBatchRequest($batch_corridor_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'corridorBatch'
     *
     * @param  \Namsor\Client\Model\BatchCorridorIn|null $batch_corridor_in A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['corridorBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function corridorBatchRequest($batch_corridor_in = null, string $contentType = self::contentTypes['corridorBatch'][0])
    {



        $resourcePath = '/api2/json/corridorBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_corridor_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_corridor_in));
            } else {
                $httpBody = $batch_corridor_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation country
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['country'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameGeoOut
     */
    public function country($personal_name_full, string $contentType = self::contentTypes['country'][0])
    {
        list($response) = $this->countryWithHttpInfo($personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation countryWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['country'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameGeoOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function countryWithHttpInfo($personal_name_full, string $contentType = self::contentTypes['country'][0])
    {
        $request = $this->countryRequest($personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameGeoOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameGeoOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameGeoOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameGeoOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameGeoOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation countryAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['country'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryAsync($personal_name_full, string $contentType = self::contentTypes['country'][0])
    {
        return $this->countryAsyncWithHttpInfo($personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countryAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['country'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryAsyncWithHttpInfo($personal_name_full, string $contentType = self::contentTypes['country'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameGeoOut';
        $request = $this->countryRequest($personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'country'
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['country'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function countryRequest($personal_name_full, string $contentType = self::contentTypes['country'][0])
    {

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling country'
            );
        }


        $resourcePath = '/api2/json/country/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation countryBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGeoOut
     */
    public function countryBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['countryBatch'][0])
    {
        list($response) = $this->countryBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation countryBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGeoOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function countryBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['countryBatch'][0])
    {
        $request = $this->countryBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGeoOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGeoOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGeoOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGeoOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGeoOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation countryBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['countryBatch'][0])
    {
        return $this->countryBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countryBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['countryBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGeoOut';
        $request = $this->countryBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'countryBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function countryBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['countryBatch'][0])
    {



        $resourcePath = '/api2/json/countryBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation countryFnLn
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLn'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameOriginedOut
     */
    public function countryFnLn($first_name, $last_name, string $contentType = self::contentTypes['countryFnLn'][0])
    {
        list($response) = $this->countryFnLnWithHttpInfo($first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation countryFnLnWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLn'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameOriginedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function countryFnLnWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['countryFnLn'][0])
    {
        $request = $this->countryFnLnRequest($first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameOriginedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameOriginedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameOriginedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameOriginedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameOriginedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation countryFnLnAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryFnLnAsync($first_name, $last_name, string $contentType = self::contentTypes['countryFnLn'][0])
    {
        return $this->countryFnLnAsyncWithHttpInfo($first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countryFnLnAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryFnLnAsyncWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['countryFnLn'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameOriginedOut';
        $request = $this->countryFnLnRequest($first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'countryFnLn'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLn'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function countryFnLnRequest($first_name, $last_name, string $contentType = self::contentTypes['countryFnLn'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling countryFnLn'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling countryFnLn'
            );
        }


        $resourcePath = '/api2/json/countryFnLn/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation countryFnLnBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLnBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGeoOut
     */
    public function countryFnLnBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['countryFnLnBatch'][0])
    {
        list($response) = $this->countryFnLnBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation countryFnLnBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLnBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGeoOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function countryFnLnBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['countryFnLnBatch'][0])
    {
        $request = $this->countryFnLnBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGeoOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGeoOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGeoOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGeoOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGeoOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation countryFnLnBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLnBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryFnLnBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['countryFnLnBatch'][0])
    {
        return $this->countryFnLnBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation countryFnLnBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLnBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function countryFnLnBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['countryFnLnBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGeoOut';
        $request = $this->countryFnLnBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'countryFnLnBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['countryFnLnBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function countryFnLnBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['countryFnLnBatch'][0])
    {



        $resourcePath = '/api2/json/countryFnLnBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation diaspora
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diaspora'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameDiasporaedOut
     */
    public function diaspora($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['diaspora'][0])
    {
        list($response) = $this->diasporaWithHttpInfo($country_iso2, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation diasporaWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diaspora'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameDiasporaedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function diasporaWithHttpInfo($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['diaspora'][0])
    {
        $request = $this->diasporaRequest($country_iso2, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameDiasporaedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameDiasporaedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameDiasporaedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameDiasporaedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameDiasporaedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation diasporaAsync
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diaspora'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaAsync($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['diaspora'][0])
    {
        return $this->diasporaAsyncWithHttpInfo($country_iso2, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation diasporaAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diaspora'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaAsyncWithHttpInfo($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['diaspora'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameDiasporaedOut';
        $request = $this->diasporaRequest($country_iso2, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'diaspora'
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diaspora'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function diasporaRequest($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['diaspora'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling diaspora'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling diaspora'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling diaspora'
            );
        }


        $resourcePath = '/api2/json/diaspora/{countryIso2}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation diasporaBatch
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameDiasporaedOut
     */
    public function diasporaBatch($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['diasporaBatch'][0])
    {
        list($response) = $this->diasporaBatchWithHttpInfo($batch_first_last_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation diasporaBatchWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameDiasporaedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function diasporaBatchWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['diasporaBatch'][0])
    {
        $request = $this->diasporaBatchRequest($batch_first_last_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameDiasporaedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameDiasporaedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameDiasporaedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameDiasporaedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameDiasporaedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation diasporaBatchAsync
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaBatchAsync($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['diasporaBatch'][0])
    {
        return $this->diasporaBatchAsyncWithHttpInfo($batch_first_last_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation diasporaBatchAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaBatchAsyncWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['diasporaBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameDiasporaedOut';
        $request = $this->diasporaBatchRequest($batch_first_last_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'diasporaBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function diasporaBatchRequest($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['diasporaBatch'][0])
    {



        $resourcePath = '/api2/json/diasporaBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_in));
            } else {
                $httpBody = $batch_first_last_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation diasporaFull
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameDiasporaedOut
     */
    public function diasporaFull($country_iso2, $personal_name_full, string $contentType = self::contentTypes['diasporaFull'][0])
    {
        list($response) = $this->diasporaFullWithHttpInfo($country_iso2, $personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation diasporaFullWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameDiasporaedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function diasporaFullWithHttpInfo($country_iso2, $personal_name_full, string $contentType = self::contentTypes['diasporaFull'][0])
    {
        $request = $this->diasporaFullRequest($country_iso2, $personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameDiasporaedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameDiasporaedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameDiasporaedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameDiasporaedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameDiasporaedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation diasporaFullAsync
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaFullAsync($country_iso2, $personal_name_full, string $contentType = self::contentTypes['diasporaFull'][0])
    {
        return $this->diasporaFullAsyncWithHttpInfo($country_iso2, $personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation diasporaFullAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaFullAsyncWithHttpInfo($country_iso2, $personal_name_full, string $contentType = self::contentTypes['diasporaFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameDiasporaedOut';
        $request = $this->diasporaFullRequest($country_iso2, $personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'diasporaFull'
     *
     * @param  string $country_iso2 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function diasporaFullRequest($country_iso2, $personal_name_full, string $contentType = self::contentTypes['diasporaFull'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling diasporaFull'
            );
        }

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling diasporaFull'
            );
        }


        $resourcePath = '/api2/json/diasporaFull/{countryIso2}/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation diasporaFullBatch
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameDiasporaedOut
     */
    public function diasporaFullBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['diasporaFullBatch'][0])
    {
        list($response) = $this->diasporaFullBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation diasporaFullBatchWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameDiasporaedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function diasporaFullBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['diasporaFullBatch'][0])
    {
        $request = $this->diasporaFullBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameDiasporaedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameDiasporaedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameDiasporaedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameDiasporaedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameDiasporaedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation diasporaFullBatchAsync
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaFullBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['diasporaFullBatch'][0])
    {
        return $this->diasporaFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation diasporaFullBatchAsyncWithHttpInfo
     *
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function diasporaFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['diasporaFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameDiasporaedOut';
        $request = $this->diasporaFullBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'diasporaFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['diasporaFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function diasporaFullBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['diasporaFullBatch'][0])
    {



        $resourcePath = '/api2/json/diasporaFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gender
     *
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     *
     * @param  string $first_name first_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGenderedOut
     */
    public function gender($first_name, string $contentType = self::contentTypes['gender'][0])
    {
        list($response) = $this->genderWithHttpInfo($first_name, $contentType);
        return $response;
    }

    /**
     * Operation genderWithHttpInfo
     *
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     *
     * @param  string $first_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderWithHttpInfo($first_name, string $contentType = self::contentTypes['gender'][0])
    {
        $request = $this->genderRequest($first_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderAsync
     *
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     *
     * @param  string $first_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderAsync($first_name, string $contentType = self::contentTypes['gender'][0])
    {
        return $this->genderAsyncWithHttpInfo($first_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderAsyncWithHttpInfo
     *
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     *
     * @param  string $first_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderAsyncWithHttpInfo($first_name, string $contentType = self::contentTypes['gender'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
        $request = $this->genderRequest($first_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gender'
     *
     * @param  string $first_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderRequest($first_name, string $contentType = self::contentTypes['gender'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling gender'
            );
        }


        $resourcePath = '/api2/json/gender/{firstName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation gender1
     *
     * Infer the likely gender of a name.
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender1'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGenderedOut
     */
    public function gender1($first_name, $last_name, string $contentType = self::contentTypes['gender1'][0])
    {
        list($response) = $this->gender1WithHttpInfo($first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation gender1WithHttpInfo
     *
     * Infer the likely gender of a name.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender1'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function gender1WithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['gender1'][0])
    {
        $request = $this->gender1Request($first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation gender1Async
     *
     * Infer the likely gender of a name.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gender1Async($first_name, $last_name, string $contentType = self::contentTypes['gender1'][0])
    {
        return $this->gender1AsyncWithHttpInfo($first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation gender1AsyncWithHttpInfo
     *
     * Infer the likely gender of a name.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function gender1AsyncWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['gender1'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
        $request = $this->gender1Request($first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'gender1'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['gender1'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function gender1Request($first_name, $last_name, string $contentType = self::contentTypes['gender1'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling gender1'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling gender1'
            );
        }


        $resourcePath = '/api2/json/gender/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderBatch
     *
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGenderedOut
     */
    public function genderBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderBatch'][0])
    {
        list($response) = $this->genderBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation genderBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderBatch'][0])
    {
        $request = $this->genderBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderBatchAsync
     *
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderBatch'][0])
    {
        return $this->genderBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
        $request = $this->genderBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderBatch'][0])
    {



        $resourcePath = '/api2/json/genderBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderFull
     *
     * Infer the likely gender of a full name, ex. John H. Smith
     *
     * @param  string $full_name full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameGenderedOut
     */
    public function genderFull($full_name, string $contentType = self::contentTypes['genderFull'][0])
    {
        list($response) = $this->genderFullWithHttpInfo($full_name, $contentType);
        return $response;
    }

    /**
     * Operation genderFullWithHttpInfo
     *
     * Infer the likely gender of a full name, ex. John H. Smith
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderFullWithHttpInfo($full_name, string $contentType = self::contentTypes['genderFull'][0])
    {
        $request = $this->genderFullRequest($full_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderFullAsync
     *
     * Infer the likely gender of a full name, ex. John H. Smith
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullAsync($full_name, string $contentType = self::contentTypes['genderFull'][0])
    {
        return $this->genderFullAsyncWithHttpInfo($full_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderFullAsyncWithHttpInfo
     *
     * Infer the likely gender of a full name, ex. John H. Smith
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullAsyncWithHttpInfo($full_name, string $contentType = self::contentTypes['genderFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
        $request = $this->genderFullRequest($full_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderFull'
     *
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderFullRequest($full_name, string $contentType = self::contentTypes['genderFull'][0])
    {

        // verify the required parameter 'full_name' is set
        if ($full_name === null || (is_array($full_name) && count($full_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $full_name when calling genderFull'
            );
        }


        $resourcePath = '/api2/json/genderFull/{fullName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($full_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fullName' . '}',
                ObjectSerializer::toPathValue($full_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderFullBatch
     *
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGenderedOut
     */
    public function genderFullBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['genderFullBatch'][0])
    {
        list($response) = $this->genderFullBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation genderFullBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderFullBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['genderFullBatch'][0])
    {
        $request = $this->genderFullBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderFullBatchAsync
     *
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['genderFullBatch'][0])
    {
        return $this->genderFullBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderFullBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['genderFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
        $request = $this->genderFullBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderFullBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['genderFullBatch'][0])
    {



        $resourcePath = '/api2/json/genderFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderFullGeo
     *
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     *
     * @param  string $full_name full_name (required)
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeo'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameGenderedOut
     */
    public function genderFullGeo($full_name, $country_iso2, string $contentType = self::contentTypes['genderFullGeo'][0])
    {
        list($response) = $this->genderFullGeoWithHttpInfo($full_name, $country_iso2, $contentType);
        return $response;
    }

    /**
     * Operation genderFullGeoWithHttpInfo
     *
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     *
     * @param  string $full_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeo'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderFullGeoWithHttpInfo($full_name, $country_iso2, string $contentType = self::contentTypes['genderFullGeo'][0])
    {
        $request = $this->genderFullGeoRequest($full_name, $country_iso2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderFullGeoAsync
     *
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     *
     * @param  string $full_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullGeoAsync($full_name, $country_iso2, string $contentType = self::contentTypes['genderFullGeo'][0])
    {
        return $this->genderFullGeoAsyncWithHttpInfo($full_name, $country_iso2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderFullGeoAsyncWithHttpInfo
     *
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     *
     * @param  string $full_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullGeoAsyncWithHttpInfo($full_name, $country_iso2, string $contentType = self::contentTypes['genderFullGeo'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
        $request = $this->genderFullGeoRequest($full_name, $country_iso2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderFullGeo'
     *
     * @param  string $full_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderFullGeoRequest($full_name, $country_iso2, string $contentType = self::contentTypes['genderFullGeo'][0])
    {

        // verify the required parameter 'full_name' is set
        if ($full_name === null || (is_array($full_name) && count($full_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $full_name when calling genderFullGeo'
            );
        }

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling genderFullGeo'
            );
        }


        $resourcePath = '/api2/json/genderFullGeo/{fullName}/{countryIso2}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($full_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fullName' . '}',
                ObjectSerializer::toPathValue($full_name),
                $resourcePath
            );
        }
        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderFullGeoBatch
     *
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeoBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGenderedOut
     */
    public function genderFullGeoBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['genderFullGeoBatch'][0])
    {
        list($response) = $this->genderFullGeoBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation genderFullGeoBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeoBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderFullGeoBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['genderFullGeoBatch'][0])
    {
        $request = $this->genderFullGeoBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderFullGeoBatchAsync
     *
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullGeoBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['genderFullGeoBatch'][0])
    {
        return $this->genderFullGeoBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderFullGeoBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderFullGeoBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['genderFullGeoBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
        $request = $this->genderFullGeoBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderFullGeoBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderFullGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderFullGeoBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['genderFullGeoBatch'][0])
    {



        $resourcePath = '/api2/json/genderFullGeoBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderGeo
     *
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeo'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGenderedOut
     */
    public function genderGeo($first_name, $last_name, $country_iso2, string $contentType = self::contentTypes['genderGeo'][0])
    {
        list($response) = $this->genderGeoWithHttpInfo($first_name, $last_name, $country_iso2, $contentType);
        return $response;
    }

    /**
     * Operation genderGeoWithHttpInfo
     *
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeo'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderGeoWithHttpInfo($first_name, $last_name, $country_iso2, string $contentType = self::contentTypes['genderGeo'][0])
    {
        $request = $this->genderGeoRequest($first_name, $last_name, $country_iso2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderGeoAsync
     *
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderGeoAsync($first_name, $last_name, $country_iso2, string $contentType = self::contentTypes['genderGeo'][0])
    {
        return $this->genderGeoAsyncWithHttpInfo($first_name, $last_name, $country_iso2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderGeoAsyncWithHttpInfo
     *
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderGeoAsyncWithHttpInfo($first_name, $last_name, $country_iso2, string $contentType = self::contentTypes['genderGeo'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
        $request = $this->genderGeoRequest($first_name, $last_name, $country_iso2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderGeo'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderGeoRequest($first_name, $last_name, $country_iso2, string $contentType = self::contentTypes['genderGeo'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling genderGeo'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling genderGeo'
            );
        }

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling genderGeo'
            );
        }


        $resourcePath = '/api2/json/genderGeo/{firstName}/{lastName}/{countryIso2}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }
        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderGeoBatch
     *
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeoBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGenderedOut
     */
    public function genderGeoBatch($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['genderGeoBatch'][0])
    {
        list($response) = $this->genderGeoBatchWithHttpInfo($batch_first_last_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation genderGeoBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeoBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderGeoBatchWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['genderGeoBatch'][0])
    {
        $request = $this->genderGeoBatchRequest($batch_first_last_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderGeoBatchAsync
     *
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderGeoBatchAsync($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['genderGeoBatch'][0])
    {
        return $this->genderGeoBatchAsyncWithHttpInfo($batch_first_last_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderGeoBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderGeoBatchAsyncWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['genderGeoBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
        $request = $this->genderGeoBatchRequest($batch_first_last_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderGeoBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderGeoBatchRequest($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['genderGeoBatch'][0])
    {



        $resourcePath = '/api2/json/genderGeoBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_in));
            } else {
                $httpBody = $batch_first_last_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation origin
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['origin'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameOriginedOut
     */
    public function origin($first_name, $last_name, string $contentType = self::contentTypes['origin'][0])
    {
        list($response) = $this->originWithHttpInfo($first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation originWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['origin'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameOriginedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function originWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['origin'][0])
    {
        $request = $this->originRequest($first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameOriginedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameOriginedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameOriginedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameOriginedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameOriginedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation originAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['origin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originAsync($first_name, $last_name, string $contentType = self::contentTypes['origin'][0])
    {
        return $this->originAsyncWithHttpInfo($first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['origin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originAsyncWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['origin'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameOriginedOut';
        $request = $this->originRequest($first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'origin'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['origin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function originRequest($first_name, $last_name, string $contentType = self::contentTypes['origin'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling origin'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling origin'
            );
        }


        $resourcePath = '/api2/json/origin/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation originBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameOriginedOut
     */
    public function originBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['originBatch'][0])
    {
        list($response) = $this->originBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation originBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameOriginedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function originBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['originBatch'][0])
    {
        $request = $this->originBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameOriginedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameOriginedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameOriginedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameOriginedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameOriginedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation originBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['originBatch'][0])
    {
        return $this->originBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['originBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameOriginedOut';
        $request = $this->originBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'originBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function originBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['originBatch'][0])
    {



        $resourcePath = '/api2/json/originBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation originFull
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameOriginedOut
     */
    public function originFull($personal_name_full, string $contentType = self::contentTypes['originFull'][0])
    {
        list($response) = $this->originFullWithHttpInfo($personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation originFullWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameOriginedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function originFullWithHttpInfo($personal_name_full, string $contentType = self::contentTypes['originFull'][0])
    {
        $request = $this->originFullRequest($personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameOriginedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameOriginedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameOriginedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameOriginedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameOriginedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation originFullAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originFullAsync($personal_name_full, string $contentType = self::contentTypes['originFull'][0])
    {
        return $this->originFullAsyncWithHttpInfo($personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originFullAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originFullAsyncWithHttpInfo($personal_name_full, string $contentType = self::contentTypes['originFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameOriginedOut';
        $request = $this->originFullRequest($personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'originFull'
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function originFullRequest($personal_name_full, string $contentType = self::contentTypes['originFull'][0])
    {

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling originFull'
            );
        }


        $resourcePath = '/api2/json/originFull/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation originFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameOriginedOut
     */
    public function originFullBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['originFullBatch'][0])
    {
        list($response) = $this->originFullBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation originFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameOriginedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function originFullBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['originFullBatch'][0])
    {
        $request = $this->originFullBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameOriginedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameOriginedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameOriginedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameOriginedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameOriginedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation originFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originFullBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['originFullBatch'][0])
    {
        return $this->originFullBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originFullBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['originFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameOriginedOut';
        $request = $this->originFullBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'originFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['originFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function originFullBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['originFullBatch'][0])
    {



        $resourcePath = '/api2/json/originFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseName
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  string $name_full name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameParsedOut
     */
    public function parseName($name_full, string $contentType = self::contentTypes['parseName'][0])
    {
        list($response) = $this->parseNameWithHttpInfo($name_full, $contentType);
        return $response;
    }

    /**
     * Operation parseNameWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  string $name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseNameWithHttpInfo($name_full, string $contentType = self::contentTypes['parseName'][0])
    {
        $request = $this->parseNameRequest($name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseNameAsync
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  string $name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameAsync($name_full, string $contentType = self::contentTypes['parseName'][0])
    {
        return $this->parseNameAsyncWithHttpInfo($name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseNameAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  string $name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameAsyncWithHttpInfo($name_full, string $contentType = self::contentTypes['parseName'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
        $request = $this->parseNameRequest($name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseName'
     *
     * @param  string $name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseNameRequest($name_full, string $contentType = self::contentTypes['parseName'][0])
    {

        // verify the required parameter 'name_full' is set
        if ($name_full === null || (is_array($name_full) && count($name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name_full when calling parseName'
            );
        }


        $resourcePath = '/api2/json/parseName/{nameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'nameFull' . '}',
                ObjectSerializer::toPathValue($name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseNameBatch
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameParsedOut
     */
    public function parseNameBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['parseNameBatch'][0])
    {
        list($response) = $this->parseNameBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation parseNameBatchWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseNameBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['parseNameBatch'][0])
    {
        $request = $this->parseNameBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseNameBatchAsync
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['parseNameBatch'][0])
    {
        return $this->parseNameBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseNameBatchAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['parseNameBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
        $request = $this->parseNameBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseNameBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseNameBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['parseNameBatch'][0])
    {



        $resourcePath = '/api2/json/parseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseNameGeo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     *
     * @param  string $name_full name_full (required)
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeo'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameParsedOut
     */
    public function parseNameGeo($name_full, $country_iso2, string $contentType = self::contentTypes['parseNameGeo'][0])
    {
        list($response) = $this->parseNameGeoWithHttpInfo($name_full, $country_iso2, $contentType);
        return $response;
    }

    /**
     * Operation parseNameGeoWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     *
     * @param  string $name_full (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeo'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseNameGeoWithHttpInfo($name_full, $country_iso2, string $contentType = self::contentTypes['parseNameGeo'][0])
    {
        $request = $this->parseNameGeoRequest($name_full, $country_iso2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseNameGeoAsync
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     *
     * @param  string $name_full (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameGeoAsync($name_full, $country_iso2, string $contentType = self::contentTypes['parseNameGeo'][0])
    {
        return $this->parseNameGeoAsyncWithHttpInfo($name_full, $country_iso2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseNameGeoAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     *
     * @param  string $name_full (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameGeoAsyncWithHttpInfo($name_full, $country_iso2, string $contentType = self::contentTypes['parseNameGeo'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
        $request = $this->parseNameGeoRequest($name_full, $country_iso2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseNameGeo'
     *
     * @param  string $name_full (required)
     * @param  string $country_iso2 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseNameGeoRequest($name_full, $country_iso2, string $contentType = self::contentTypes['parseNameGeo'][0])
    {

        // verify the required parameter 'name_full' is set
        if ($name_full === null || (is_array($name_full) && count($name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name_full when calling parseNameGeo'
            );
        }

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling parseNameGeo'
            );
        }


        $resourcePath = '/api2/json/parseName/{nameFull}/{countryIso2}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'nameFull' . '}',
                ObjectSerializer::toPathValue($name_full),
                $resourcePath
            );
        }
        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseNameGeoBatch
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeoBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameParsedOut
     */
    public function parseNameGeoBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['parseNameGeoBatch'][0])
    {
        list($response) = $this->parseNameGeoBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation parseNameGeoBatchWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeoBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseNameGeoBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['parseNameGeoBatch'][0])
    {
        $request = $this->parseNameGeoBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseNameGeoBatchAsync
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameGeoBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['parseNameGeoBatch'][0])
    {
        return $this->parseNameGeoBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseNameGeoBatchAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseNameGeoBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['parseNameGeoBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
        $request = $this->parseNameGeoBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseNameGeoBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseNameGeoBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseNameGeoBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['parseNameGeoBatch'][0])
    {



        $resourcePath = '/api2/json/parseNameGeoBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religion2
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion2'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameReligionedOut
     */
    public function religion2($country_iso2, $sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion2'][0])
    {
        list($response) = $this->religion2WithHttpInfo($country_iso2, $sub_division_iso31662, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation religion2WithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion2'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religion2WithHttpInfo($country_iso2, $sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion2'][0])
    {
        $request = $this->religion2Request($country_iso2, $sub_division_iso31662, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religion2Async
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religion2Async($country_iso2, $sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion2'][0])
    {
        return $this->religion2AsyncWithHttpInfo($country_iso2, $sub_division_iso31662, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religion2AsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religion2AsyncWithHttpInfo($country_iso2, $sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion2'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameReligionedOut';
        $request = $this->religion2Request($country_iso2, $sub_division_iso31662, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religion2'
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religion2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religion2Request($country_iso2, $sub_division_iso31662, $first_name, $last_name, string $contentType = self::contentTypes['religion2'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling religion2'
            );
        }

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling religion2'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling religion2'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling religion2'
            );
        }


        $resourcePath = '/api2/json/religion/{countryIso2}/{subDivisionIso31662}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religionBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal first / last names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameReligionedOut
     */
    public function religionBatch($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionBatch'][0])
    {
        list($response) = $this->religionBatchWithHttpInfo($batch_first_last_name_geo_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation religionBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal first / last names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religionBatchWithHttpInfo($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionBatch'][0])
    {
        $request = $this->religionBatchRequest($batch_first_last_name_geo_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religionBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal first / last names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionBatchAsync($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionBatch'][0])
    {
        return $this->religionBatchAsyncWithHttpInfo($batch_first_last_name_geo_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religionBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal first / last names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionBatchAsyncWithHttpInfo($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameReligionedOut';
        $request = $this->religionBatchRequest($batch_first_last_name_geo_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religionBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoSubdivisionIn|null $batch_first_last_name_geo_subdivision_in A list of personal first / last names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religionBatchRequest($batch_first_last_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionBatch'][0])
    {



        $resourcePath = '/api2/json/religionBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_subdivision_in));
            } else {
                $httpBody = $batch_first_last_name_geo_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religionFull
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $sub_division_iso31662 sub_division_iso31662 (required)
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameReligionedOut
     */
    public function religionFull($country_iso2, $sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religionFull'][0])
    {
        list($response) = $this->religionFullWithHttpInfo($country_iso2, $sub_division_iso31662, $personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation religionFullWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religionFullWithHttpInfo($country_iso2, $sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religionFull'][0])
    {
        $request = $this->religionFullRequest($country_iso2, $sub_division_iso31662, $personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religionFullAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionFullAsync($country_iso2, $sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religionFull'][0])
    {
        return $this->religionFullAsyncWithHttpInfo($country_iso2, $sub_division_iso31662, $personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religionFullAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionFullAsyncWithHttpInfo($country_iso2, $sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religionFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameReligionedOut';
        $request = $this->religionFullRequest($country_iso2, $sub_division_iso31662, $personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religionFull'
     *
     * @param  string $country_iso2 (required)
     * @param  string $sub_division_iso31662 (required)
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religionFullRequest($country_iso2, $sub_division_iso31662, $personal_name_full, string $contentType = self::contentTypes['religionFull'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling religionFull'
            );
        }

        // verify the required parameter 'sub_division_iso31662' is set
        if ($sub_division_iso31662 === null || (is_array($sub_division_iso31662) && count($sub_division_iso31662) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sub_division_iso31662 when calling religionFull'
            );
        }

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling religionFull'
            );
        }


        $resourcePath = '/api2/json/religionFull/{countryIso2}/{subDivisionIso31662}/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($sub_division_iso31662 !== null) {
            $resourcePath = str_replace(
                '{' . 'subDivisionIso31662' . '}',
                ObjectSerializer::toPathValue($sub_division_iso31662),
                $resourcePath
            );
        }
        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation religionFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoSubdivisionIn|null $batch_personal_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameReligionedOut
     */
    public function religionFullBatch($batch_personal_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionFullBatch'][0])
    {
        list($response) = $this->religionFullBatchWithHttpInfo($batch_personal_name_geo_subdivision_in, $contentType);
        return $response;
    }

    /**
     * Operation religionFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoSubdivisionIn|null $batch_personal_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameReligionedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function religionFullBatchWithHttpInfo($batch_personal_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionFullBatch'][0])
    {
        $request = $this->religionFullBatchRequest($batch_personal_name_geo_subdivision_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameReligionedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameReligionedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameReligionedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameReligionedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameReligionedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation religionFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoSubdivisionIn|null $batch_personal_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionFullBatchAsync($batch_personal_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionFullBatch'][0])
    {
        return $this->religionFullBatchAsyncWithHttpInfo($batch_personal_name_geo_subdivision_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation religionFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoSubdivisionIn|null $batch_personal_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function religionFullBatchAsyncWithHttpInfo($batch_personal_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameReligionedOut';
        $request = $this->religionFullBatchRequest($batch_personal_name_geo_subdivision_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'religionFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoSubdivisionIn|null $batch_personal_name_geo_subdivision_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['religionFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function religionFullBatchRequest($batch_personal_name_geo_subdivision_in = null, string $contentType = self::contentTypes['religionFullBatch'][0])
    {



        $resourcePath = '/api2/json/religionFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_subdivision_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_subdivision_in));
            } else {
                $httpBody = $batch_personal_name_geo_subdivision_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassification
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassification'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGeoSubclassificationOut
     */
    public function subclassification($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['subclassification'][0])
    {
        list($response) = $this->subclassificationWithHttpInfo($country_iso2, $first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassification'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationWithHttpInfo($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['subclassification'][0])
    {
        $request = $this->subclassificationRequest($country_iso2, $first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationAsync($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['subclassification'][0])
    {
        return $this->subclassificationAsyncWithHttpInfo($country_iso2, $first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationAsyncWithHttpInfo($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['subclassification'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut';
        $request = $this->subclassificationRequest($country_iso2, $first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassification'
     *
     * @param  string $country_iso2 (required)
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassification'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationRequest($country_iso2, $first_name, $last_name, string $contentType = self::contentTypes['subclassification'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling subclassification'
            );
        }

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling subclassification'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling subclassification'
            );
        }


        $resourcePath = '/api2/json/subclassification/{countryIso2}/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut
     */
    public function subclassificationBatch($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationBatch'][0])
    {
        list($response) = $this->subclassificationBatchWithHttpInfo($batch_first_last_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationBatchWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationBatch'][0])
    {
        $request = $this->subclassificationBatchRequest($batch_first_last_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationBatchAsync($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationBatch'][0])
    {
        return $this->subclassificationBatchAsyncWithHttpInfo($batch_first_last_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationBatchAsyncWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGeoSubclassificationOut';
        $request = $this->subclassificationBatchRequest($batch_first_last_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationBatchRequest($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['subclassificationBatch'][0])
    {



        $resourcePath = '/api2/json/subclassificationBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_in));
            } else {
                $httpBody = $batch_first_last_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationFull
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 country_iso2 (required)
     * @param  string $full_name full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGeoSubclassificationOut
     */
    public function subclassificationFull($country_iso2, $full_name, string $contentType = self::contentTypes['subclassificationFull'][0])
    {
        list($response) = $this->subclassificationFullWithHttpInfo($country_iso2, $full_name, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationFullWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 (required)
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationFullWithHttpInfo($country_iso2, $full_name, string $contentType = self::contentTypes['subclassificationFull'][0])
    {
        $request = $this->subclassificationFullRequest($country_iso2, $full_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationFullAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 (required)
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationFullAsync($country_iso2, $full_name, string $contentType = self::contentTypes['subclassificationFull'][0])
    {
        return $this->subclassificationFullAsyncWithHttpInfo($country_iso2, $full_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationFullAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  string $country_iso2 (required)
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationFullAsyncWithHttpInfo($country_iso2, $full_name, string $contentType = self::contentTypes['subclassificationFull'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGeoSubclassificationOut';
        $request = $this->subclassificationFullRequest($country_iso2, $full_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationFull'
     *
     * @param  string $country_iso2 (required)
     * @param  string $full_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationFullRequest($country_iso2, $full_name, string $contentType = self::contentTypes['subclassificationFull'][0])
    {

        // verify the required parameter 'country_iso2' is set
        if ($country_iso2 === null || (is_array($country_iso2) && count($country_iso2) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $country_iso2 when calling subclassificationFull'
            );
        }

        // verify the required parameter 'full_name' is set
        if ($full_name === null || (is_array($full_name) && count($full_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $full_name when calling subclassificationFull'
            );
        }


        $resourcePath = '/api2/json/subclassificationFull/{countryIso2}/{fullName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($country_iso2 !== null) {
            $resourcePath = str_replace(
                '{' . 'countryIso2' . '}',
                ObjectSerializer::toPathValue($country_iso2),
                $resourcePath
            );
        }
        // path params
        if ($full_name !== null) {
            $resourcePath = str_replace(
                '{' . 'fullName' . '}',
                ObjectSerializer::toPathValue($full_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation subclassificationFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut
     */
    public function subclassificationFullBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationFullBatch'][0])
    {
        list($response) = $this->subclassificationFullBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation subclassificationFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function subclassificationFullBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationFullBatch'][0])
    {
        $request = $this->subclassificationFullBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation subclassificationFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationFullBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationFullBatch'][0])
    {
        return $this->subclassificationFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation subclassificationFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function subclassificationFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGeoSubclassificationOut';
        $request = $this->subclassificationFullBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'subclassificationFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['subclassificationFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function subclassificationFullBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['subclassificationFullBatch'][0])
    {



        $resourcePath = '/api2/json/subclassificationFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usRaceEthnicity
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicity'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut
     */
    public function usRaceEthnicity($first_name, $last_name, string $contentType = self::contentTypes['usRaceEthnicity'][0])
    {
        list($response) = $this->usRaceEthnicityWithHttpInfo($first_name, $last_name, $contentType);
        return $response;
    }

    /**
     * Operation usRaceEthnicityWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicity'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function usRaceEthnicityWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['usRaceEthnicity'][0])
    {
        $request = $this->usRaceEthnicityRequest($first_name, $last_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usRaceEthnicityAsync
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityAsync($first_name, $last_name, string $contentType = self::contentTypes['usRaceEthnicity'][0])
    {
        return $this->usRaceEthnicityAsyncWithHttpInfo($first_name, $last_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usRaceEthnicityAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityAsyncWithHttpInfo($first_name, $last_name, string $contentType = self::contentTypes['usRaceEthnicity'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut';
        $request = $this->usRaceEthnicityRequest($first_name, $last_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usRaceEthnicity'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicity'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usRaceEthnicityRequest($first_name, $last_name, string $contentType = self::contentTypes['usRaceEthnicity'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling usRaceEthnicity'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling usRaceEthnicity'
            );
        }


        $resourcePath = '/api2/json/usRaceEthnicity/{firstName}/{lastName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usRaceEthnicityBatch
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut
     */
    public function usRaceEthnicityBatch($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityBatch'][0])
    {
        list($response) = $this->usRaceEthnicityBatchWithHttpInfo($batch_first_last_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation usRaceEthnicityBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function usRaceEthnicityBatchWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityBatch'][0])
    {
        $request = $this->usRaceEthnicityBatchRequest($batch_first_last_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usRaceEthnicityBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityBatchAsync($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityBatch'][0])
    {
        return $this->usRaceEthnicityBatchAsyncWithHttpInfo($batch_first_last_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usRaceEthnicityBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityBatchAsyncWithHttpInfo($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut';
        $request = $this->usRaceEthnicityBatchRequest($batch_first_last_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usRaceEthnicityBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoIn|null $batch_first_last_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usRaceEthnicityBatchRequest($batch_first_last_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityBatch'][0])
    {



        $resourcePath = '/api2/json/usRaceEthnicityBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_in));
            } else {
                $httpBody = $batch_first_last_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usRaceEthnicityFull
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $personal_name_full personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameUSRaceEthnicityOut
     */
    public function usRaceEthnicityFull($personal_name_full, string $contentType = self::contentTypes['usRaceEthnicityFull'][0])
    {
        list($response) = $this->usRaceEthnicityFullWithHttpInfo($personal_name_full, $contentType);
        return $response;
    }

    /**
     * Operation usRaceEthnicityFullWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFull'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameUSRaceEthnicityOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function usRaceEthnicityFullWithHttpInfo($personal_name_full, string $contentType = self::contentTypes['usRaceEthnicityFull'][0])
    {
        $request = $this->usRaceEthnicityFullRequest($personal_name_full, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameUSRaceEthnicityOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameUSRaceEthnicityOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameUSRaceEthnicityOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameUSRaceEthnicityOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameUSRaceEthnicityOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usRaceEthnicityFullAsync
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityFullAsync($personal_name_full, string $contentType = self::contentTypes['usRaceEthnicityFull'][0])
    {
        return $this->usRaceEthnicityFullAsyncWithHttpInfo($personal_name_full, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usRaceEthnicityFullAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityFullAsyncWithHttpInfo($personal_name_full, string $contentType = self::contentTypes['usRaceEthnicityFull'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameUSRaceEthnicityOut';
        $request = $this->usRaceEthnicityFullRequest($personal_name_full, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usRaceEthnicityFull'
     *
     * @param  string $personal_name_full (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFull'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usRaceEthnicityFullRequest($personal_name_full, string $contentType = self::contentTypes['usRaceEthnicityFull'][0])
    {

        // verify the required parameter 'personal_name_full' is set
        if ($personal_name_full === null || (is_array($personal_name_full) && count($personal_name_full) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $personal_name_full when calling usRaceEthnicityFull'
            );
        }


        $resourcePath = '/api2/json/usRaceEthnicityFull/{personalNameFull}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($personal_name_full !== null) {
            $resourcePath = str_replace(
                '{' . 'personalNameFull' . '}',
                ObjectSerializer::toPathValue($personal_name_full),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usRaceEthnicityFullBatch
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut
     */
    public function usRaceEthnicityFullBatch($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityFullBatch'][0])
    {
        list($response) = $this->usRaceEthnicityFullBatchWithHttpInfo($batch_personal_name_geo_in, $contentType);
        return $response;
    }

    /**
     * Operation usRaceEthnicityFullBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFullBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function usRaceEthnicityFullBatchWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityFullBatch'][0])
    {
        $request = $this->usRaceEthnicityFullBatchRequest($batch_personal_name_geo_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usRaceEthnicityFullBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityFullBatchAsync($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityFullBatch'][0])
    {
        return $this->usRaceEthnicityFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usRaceEthnicityFullBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityFullBatchAsyncWithHttpInfo($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityFullBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameUSRaceEthnicityOut';
        $request = $this->usRaceEthnicityFullBatchRequest($batch_personal_name_geo_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usRaceEthnicityFullBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameGeoIn|null $batch_personal_name_geo_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityFullBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usRaceEthnicityFullBatchRequest($batch_personal_name_geo_in = null, string $contentType = self::contentTypes['usRaceEthnicityFullBatch'][0])
    {



        $resourcePath = '/api2/json/usRaceEthnicityFullBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_geo_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_geo_in));
            } else {
                $httpBody = $batch_personal_name_geo_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usRaceEthnicityZIP5
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name first_name (required)
     * @param  string $last_name last_name (required)
     * @param  string $zip5_code zip5_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityZIP5'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut
     */
    public function usRaceEthnicityZIP5($first_name, $last_name, $zip5_code, string $contentType = self::contentTypes['usRaceEthnicityZIP5'][0])
    {
        list($response) = $this->usRaceEthnicityZIP5WithHttpInfo($first_name, $last_name, $zip5_code, $contentType);
        return $response;
    }

    /**
     * Operation usRaceEthnicityZIP5WithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $zip5_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityZIP5'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function usRaceEthnicityZIP5WithHttpInfo($first_name, $last_name, $zip5_code, string $contentType = self::contentTypes['usRaceEthnicityZIP5'][0])
    {
        $request = $this->usRaceEthnicityZIP5Request($first_name, $last_name, $zip5_code, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usRaceEthnicityZIP5Async
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $zip5_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityZIP5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityZIP5Async($first_name, $last_name, $zip5_code, string $contentType = self::contentTypes['usRaceEthnicityZIP5'][0])
    {
        return $this->usRaceEthnicityZIP5AsyncWithHttpInfo($first_name, $last_name, $zip5_code, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usRaceEthnicityZIP5AsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $zip5_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityZIP5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usRaceEthnicityZIP5AsyncWithHttpInfo($first_name, $last_name, $zip5_code, string $contentType = self::contentTypes['usRaceEthnicityZIP5'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameUSRaceEthnicityOut';
        $request = $this->usRaceEthnicityZIP5Request($first_name, $last_name, $zip5_code, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usRaceEthnicityZIP5'
     *
     * @param  string $first_name (required)
     * @param  string $last_name (required)
     * @param  string $zip5_code (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usRaceEthnicityZIP5'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usRaceEthnicityZIP5Request($first_name, $last_name, $zip5_code, string $contentType = self::contentTypes['usRaceEthnicityZIP5'][0])
    {

        // verify the required parameter 'first_name' is set
        if ($first_name === null || (is_array($first_name) && count($first_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $first_name when calling usRaceEthnicityZIP5'
            );
        }

        // verify the required parameter 'last_name' is set
        if ($last_name === null || (is_array($last_name) && count($last_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $last_name when calling usRaceEthnicityZIP5'
            );
        }

        // verify the required parameter 'zip5_code' is set
        if ($zip5_code === null || (is_array($zip5_code) && count($zip5_code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zip5_code when calling usRaceEthnicityZIP5'
            );
        }


        $resourcePath = '/api2/json/usRaceEthnicityZIP5/{firstName}/{lastName}/{zip5Code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($first_name !== null) {
            $resourcePath = str_replace(
                '{' . 'firstName' . '}',
                ObjectSerializer::toPathValue($first_name),
                $resourcePath
            );
        }
        // path params
        if ($last_name !== null) {
            $resourcePath = str_replace(
                '{' . 'lastName' . '}',
                ObjectSerializer::toPathValue($last_name),
                $resourcePath
            );
        }
        // path params
        if ($zip5_code !== null) {
            $resourcePath = str_replace(
                '{' . 'zip5Code' . '}',
                ObjectSerializer::toPathValue($zip5_code),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation usZipRaceEthnicityBatch
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoZippedIn|null $batch_first_last_name_geo_zipped_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usZipRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut
     */
    public function usZipRaceEthnicityBatch($batch_first_last_name_geo_zipped_in = null, string $contentType = self::contentTypes['usZipRaceEthnicityBatch'][0])
    {
        list($response) = $this->usZipRaceEthnicityBatchWithHttpInfo($batch_first_last_name_geo_zipped_in, $contentType);
        return $response;
    }

    /**
     * Operation usZipRaceEthnicityBatchWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoZippedIn|null $batch_first_last_name_geo_zipped_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usZipRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function usZipRaceEthnicityBatchWithHttpInfo($batch_first_last_name_geo_zipped_in = null, string $contentType = self::contentTypes['usZipRaceEthnicityBatch'][0])
    {
        $request = $this->usZipRaceEthnicityBatchRequest($batch_first_last_name_geo_zipped_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation usZipRaceEthnicityBatchAsync
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoZippedIn|null $batch_first_last_name_geo_zipped_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usZipRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usZipRaceEthnicityBatchAsync($batch_first_last_name_geo_zipped_in = null, string $contentType = self::contentTypes['usZipRaceEthnicityBatch'][0])
    {
        return $this->usZipRaceEthnicityBatchAsyncWithHttpInfo($batch_first_last_name_geo_zipped_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation usZipRaceEthnicityBatchAsyncWithHttpInfo
     *
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoZippedIn|null $batch_first_last_name_geo_zipped_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usZipRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function usZipRaceEthnicityBatchAsyncWithHttpInfo($batch_first_last_name_geo_zipped_in = null, string $contentType = self::contentTypes['usZipRaceEthnicityBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameUSRaceEthnicityOut';
        $request = $this->usZipRaceEthnicityBatchRequest($batch_first_last_name_geo_zipped_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'usZipRaceEthnicityBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGeoZippedIn|null $batch_first_last_name_geo_zipped_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['usZipRaceEthnicityBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function usZipRaceEthnicityBatchRequest($batch_first_last_name_geo_zipped_in = null, string $contentType = self::contentTypes['usZipRaceEthnicityBatch'][0])
    {



        $resourcePath = '/api2/json/usZipRaceEthnicityBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_geo_zipped_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_geo_zipped_in));
            } else {
                $httpBody = $batch_first_last_name_geo_zipped_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
