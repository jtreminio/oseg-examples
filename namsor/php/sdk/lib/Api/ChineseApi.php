<?php
/**
 * ChineseApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NamSor API v2
 *
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!
 *
 * The version of the OpenAPI document: 2.0.29
 * Contact: contact@namsor.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Namsor\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Namsor\Client\ApiException;
use Namsor\Client\Configuration;
use Namsor\Client\HeaderSelector;
use Namsor\Client\ObjectSerializer;

/**
 * ChineseApi Class Doc Comment
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ChineseApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'chineseNameCandidates' => [
            'application/json',
        ],
        'chineseNameCandidatesBatch' => [
            'application/json',
        ],
        'chineseNameCandidatesGenderBatch' => [
            'application/json',
        ],
        'chineseNameGenderCandidates' => [
            'application/json',
        ],
        'chineseNameMatch' => [
            'application/json',
        ],
        'chineseNameMatchBatch' => [
            'application/json',
        ],
        'genderChineseName' => [
            'application/json',
        ],
        'genderChineseNameBatch' => [
            'application/json',
        ],
        'genderChineseNamePinyin' => [
            'application/json',
        ],
        'genderChineseNamePinyinBatch' => [
            'application/json',
        ],
        'parseChineseName' => [
            'application/json',
        ],
        'parseChineseNameBatch' => [
            'application/json',
        ],
        'pinyinChineseName' => [
            'application/json',
        ],
        'pinyinChineseNameBatch' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation chineseNameCandidates
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchCandidatesOut
     */
    public function chineseNameCandidates($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['chineseNameCandidates'][0])
    {
        list($response) = $this->chineseNameCandidatesWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $contentType);
        return $response;
    }

    /**
     * Operation chineseNameCandidatesWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function chineseNameCandidatesWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['chineseNameCandidates'][0])
    {
        $request = $this->chineseNameCandidatesRequest($chinese_surname_latin, $chinese_given_name_latin, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chineseNameCandidatesAsync
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameCandidatesAsync($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['chineseNameCandidates'][0])
    {
        return $this->chineseNameCandidatesAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chineseNameCandidatesAsyncWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameCandidatesAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['chineseNameCandidates'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
        $request = $this->chineseNameCandidatesRequest($chinese_surname_latin, $chinese_given_name_latin, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chineseNameCandidates'
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chineseNameCandidatesRequest($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['chineseNameCandidates'][0])
    {

        // verify the required parameter 'chinese_surname_latin' is set
        if ($chinese_surname_latin === null || (is_array($chinese_surname_latin) && count($chinese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_surname_latin when calling chineseNameCandidates'
            );
        }

        // verify the required parameter 'chinese_given_name_latin' is set
        if ($chinese_given_name_latin === null || (is_array($chinese_given_name_latin) && count($chinese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_given_name_latin when calling chineseNameCandidates'
            );
        }


        $resourcePath = '/api2/json/chineseNameCandidates/{chineseSurnameLatin}/{chineseGivenNameLatin}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($chinese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_given_name_latin),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chineseNameCandidatesBatch
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchCandidatesOut
     */
    public function chineseNameCandidatesBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameCandidatesBatch'][0])
    {
        list($response) = $this->chineseNameCandidatesBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation chineseNameCandidatesBatchWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function chineseNameCandidatesBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameCandidatesBatch'][0])
    {
        $request = $this->chineseNameCandidatesBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chineseNameCandidatesBatchAsync
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameCandidatesBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameCandidatesBatch'][0])
    {
        return $this->chineseNameCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chineseNameCandidatesBatchAsyncWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameCandidatesBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameCandidatesBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->chineseNameCandidatesBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chineseNameCandidatesBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chineseNameCandidatesBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameCandidatesBatch'][0])
    {



        $resourcePath = '/api2/json/chineseNameCandidatesBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chineseNameCandidatesGenderBatch
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname) ex. Wang Xiaoming.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesGenderBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchCandidatesOut
     */
    public function chineseNameCandidatesGenderBatch($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['chineseNameCandidatesGenderBatch'][0])
    {
        list($response) = $this->chineseNameCandidatesGenderBatchWithHttpInfo($batch_first_last_name_gender_in, $contentType);
        return $response;
    }

    /**
     * Operation chineseNameCandidatesGenderBatchWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname) ex. Wang Xiaoming.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesGenderBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function chineseNameCandidatesGenderBatchWithHttpInfo($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['chineseNameCandidatesGenderBatch'][0])
    {
        $request = $this->chineseNameCandidatesGenderBatchRequest($batch_first_last_name_gender_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chineseNameCandidatesGenderBatchAsync
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname) ex. Wang Xiaoming.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesGenderBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameCandidatesGenderBatchAsync($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['chineseNameCandidatesGenderBatch'][0])
    {
        return $this->chineseNameCandidatesGenderBatchAsyncWithHttpInfo($batch_first_last_name_gender_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chineseNameCandidatesGenderBatchAsyncWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname) ex. Wang Xiaoming.
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesGenderBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameCandidatesGenderBatchAsyncWithHttpInfo($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['chineseNameCandidatesGenderBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchCandidatesOut';
        $request = $this->chineseNameCandidatesGenderBatchRequest($batch_first_last_name_gender_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chineseNameCandidatesGenderBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameGenderIn|null $batch_first_last_name_gender_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameCandidatesGenderBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chineseNameCandidatesGenderBatchRequest($batch_first_last_name_gender_in = null, string $contentType = self::contentTypes['chineseNameCandidatesGenderBatch'][0])
    {



        $resourcePath = '/api2/json/chineseNameCandidatesGenderBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_gender_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_gender_in));
            } else {
                $httpBody = $batch_first_last_name_gender_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chineseNameGenderCandidates
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming - having a known gender (&#39;male&#39; or &#39;female&#39;)
     *
     * @param  string $chinese_surname_latin chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin chinese_given_name_latin (required)
     * @param  string $known_gender known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameGenderCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchCandidatesOut
     */
    public function chineseNameGenderCandidates($chinese_surname_latin, $chinese_given_name_latin, $known_gender, string $contentType = self::contentTypes['chineseNameGenderCandidates'][0])
    {
        list($response) = $this->chineseNameGenderCandidatesWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $known_gender, $contentType);
        return $response;
    }

    /**
     * Operation chineseNameGenderCandidatesWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming - having a known gender (&#39;male&#39; or &#39;female&#39;)
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameGenderCandidates'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchCandidatesOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function chineseNameGenderCandidatesWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $known_gender, string $contentType = self::contentTypes['chineseNameGenderCandidates'][0])
    {
        $request = $this->chineseNameGenderCandidatesRequest($chinese_surname_latin, $chinese_given_name_latin, $known_gender, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchCandidatesOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchCandidatesOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchCandidatesOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchCandidatesOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chineseNameGenderCandidatesAsync
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming - having a known gender (&#39;male&#39; or &#39;female&#39;)
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameGenderCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameGenderCandidatesAsync($chinese_surname_latin, $chinese_given_name_latin, $known_gender, string $contentType = self::contentTypes['chineseNameGenderCandidates'][0])
    {
        return $this->chineseNameGenderCandidatesAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $known_gender, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chineseNameGenderCandidatesAsyncWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming - having a known gender (&#39;male&#39; or &#39;female&#39;)
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameGenderCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameGenderCandidatesAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $known_gender, string $contentType = self::contentTypes['chineseNameGenderCandidates'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchCandidatesOut';
        $request = $this->chineseNameGenderCandidatesRequest($chinese_surname_latin, $chinese_given_name_latin, $known_gender, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chineseNameGenderCandidates'
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $known_gender (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameGenderCandidates'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chineseNameGenderCandidatesRequest($chinese_surname_latin, $chinese_given_name_latin, $known_gender, string $contentType = self::contentTypes['chineseNameGenderCandidates'][0])
    {

        // verify the required parameter 'chinese_surname_latin' is set
        if ($chinese_surname_latin === null || (is_array($chinese_surname_latin) && count($chinese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_surname_latin when calling chineseNameGenderCandidates'
            );
        }

        // verify the required parameter 'chinese_given_name_latin' is set
        if ($chinese_given_name_latin === null || (is_array($chinese_given_name_latin) && count($chinese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_given_name_latin when calling chineseNameGenderCandidates'
            );
        }

        // verify the required parameter 'known_gender' is set
        if ($known_gender === null || (is_array($known_gender) && count($known_gender) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $known_gender when calling chineseNameGenderCandidates'
            );
        }


        $resourcePath = '/api2/json/chineseNameGenderCandidates/{chineseSurnameLatin}/{chineseGivenNameLatin}/{knownGender}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($chinese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($known_gender !== null) {
            $resourcePath = str_replace(
                '{' . 'knownGender' . '}',
                ObjectSerializer::toPathValue($known_gender),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chineseNameMatch
     *
     * Return a score for matching Chinese name ex. 王晓明 with a romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin chinese_given_name_latin (required)
     * @param  string $chinese_name chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\NameMatchedOut
     */
    public function chineseNameMatch($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, string $contentType = self::contentTypes['chineseNameMatch'][0])
    {
        list($response) = $this->chineseNameMatchWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, $contentType);
        return $response;
    }

    /**
     * Operation chineseNameMatchWithHttpInfo
     *
     * Return a score for matching Chinese name ex. 王晓明 with a romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\NameMatchedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function chineseNameMatchWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, string $contentType = self::contentTypes['chineseNameMatch'][0])
    {
        $request = $this->chineseNameMatchRequest($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\NameMatchedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\NameMatchedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\NameMatchedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\NameMatchedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\NameMatchedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chineseNameMatchAsync
     *
     * Return a score for matching Chinese name ex. 王晓明 with a romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameMatchAsync($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, string $contentType = self::contentTypes['chineseNameMatch'][0])
    {
        return $this->chineseNameMatchAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chineseNameMatchAsyncWithHttpInfo
     *
     * Return a score for matching Chinese name ex. 王晓明 with a romanized name ex. Wang Xiaoming
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameMatchAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, string $contentType = self::contentTypes['chineseNameMatch'][0])
    {
        $returnType = '\Namsor\Client\Model\NameMatchedOut';
        $request = $this->chineseNameMatchRequest($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chineseNameMatch'
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chineseNameMatchRequest($chinese_surname_latin, $chinese_given_name_latin, $chinese_name, string $contentType = self::contentTypes['chineseNameMatch'][0])
    {

        // verify the required parameter 'chinese_surname_latin' is set
        if ($chinese_surname_latin === null || (is_array($chinese_surname_latin) && count($chinese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_surname_latin when calling chineseNameMatch'
            );
        }

        // verify the required parameter 'chinese_given_name_latin' is set
        if ($chinese_given_name_latin === null || (is_array($chinese_given_name_latin) && count($chinese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_given_name_latin when calling chineseNameMatch'
            );
        }

        // verify the required parameter 'chinese_name' is set
        if ($chinese_name === null || (is_array($chinese_name) && count($chinese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_name when calling chineseNameMatch'
            );
        }


        $resourcePath = '/api2/json/chineseNameMatch/{chineseSurnameLatin}/{chineseGivenNameLatin}/{chineseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($chinese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_given_name_latin),
                $resourcePath
            );
        }
        // path params
        if ($chinese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseName' . '}',
                ObjectSerializer::toPathValue($chinese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation chineseNameMatchBatch
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchNameMatchedOut
     */
    public function chineseNameMatchBatch($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameMatchBatch'][0])
    {
        list($response) = $this->chineseNameMatchBatchWithHttpInfo($batch_match_personal_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation chineseNameMatchBatchWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchNameMatchedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function chineseNameMatchBatchWithHttpInfo($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameMatchBatch'][0])
    {
        $request = $this->chineseNameMatchBatchRequest($batch_match_personal_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchNameMatchedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchNameMatchedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchNameMatchedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchNameMatchedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchNameMatchedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation chineseNameMatchBatchAsync
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameMatchBatchAsync($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameMatchBatch'][0])
    {
        return $this->chineseNameMatchBatchAsyncWithHttpInfo($batch_match_personal_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation chineseNameMatchBatchAsyncWithHttpInfo
     *
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function chineseNameMatchBatchAsyncWithHttpInfo($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameMatchBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchNameMatchedOut';
        $request = $this->chineseNameMatchBatchRequest($batch_match_personal_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'chineseNameMatchBatch'
     *
     * @param  \Namsor\Client\Model\BatchMatchPersonalFirstLastNameIn|null $batch_match_personal_first_last_name_in A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['chineseNameMatchBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function chineseNameMatchBatchRequest($batch_match_personal_first_last_name_in = null, string $contentType = self::contentTypes['chineseNameMatchBatch'][0])
    {



        $resourcePath = '/api2/json/chineseNameMatchBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_match_personal_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_match_personal_first_last_name_in));
            } else {
                $httpBody = $batch_match_personal_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderChineseName
     *
     * Infer the likely gender of a Chinese full name ex. 王晓明
     *
     * @param  string $chinese_name chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameGenderedOut
     */
    public function genderChineseName($chinese_name, string $contentType = self::contentTypes['genderChineseName'][0])
    {
        list($response) = $this->genderChineseNameWithHttpInfo($chinese_name, $contentType);
        return $response;
    }

    /**
     * Operation genderChineseNameWithHttpInfo
     *
     * Infer the likely gender of a Chinese full name ex. 王晓明
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderChineseNameWithHttpInfo($chinese_name, string $contentType = self::contentTypes['genderChineseName'][0])
    {
        $request = $this->genderChineseNameRequest($chinese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderChineseNameAsync
     *
     * Infer the likely gender of a Chinese full name ex. 王晓明
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNameAsync($chinese_name, string $contentType = self::contentTypes['genderChineseName'][0])
    {
        return $this->genderChineseNameAsyncWithHttpInfo($chinese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderChineseNameAsyncWithHttpInfo
     *
     * Infer the likely gender of a Chinese full name ex. 王晓明
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNameAsyncWithHttpInfo($chinese_name, string $contentType = self::contentTypes['genderChineseName'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameGenderedOut';
        $request = $this->genderChineseNameRequest($chinese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderChineseName'
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderChineseNameRequest($chinese_name, string $contentType = self::contentTypes['genderChineseName'][0])
    {

        // verify the required parameter 'chinese_name' is set
        if ($chinese_name === null || (is_array($chinese_name) && count($chinese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_name when calling genderChineseName'
            );
        }


        $resourcePath = '/api2/json/genderChineseName/{chineseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseName' . '}',
                ObjectSerializer::toPathValue($chinese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderChineseNameBatch
     *
     * Infer the likely gender of up to 100 full names ex. 王晓明
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameGenderedOut
     */
    public function genderChineseNameBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['genderChineseNameBatch'][0])
    {
        list($response) = $this->genderChineseNameBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation genderChineseNameBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names ex. 王晓明
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderChineseNameBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['genderChineseNameBatch'][0])
    {
        $request = $this->genderChineseNameBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderChineseNameBatchAsync
     *
     * Infer the likely gender of up to 100 full names ex. 王晓明
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNameBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['genderChineseNameBatch'][0])
    {
        return $this->genderChineseNameBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderChineseNameBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 full names ex. 王晓明
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNameBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['genderChineseNameBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameGenderedOut';
        $request = $this->genderChineseNameBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderChineseNameBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names, with a country ISO2 code (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderChineseNameBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['genderChineseNameBatch'][0])
    {



        $resourcePath = '/api2/json/genderChineseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderChineseNamePinyin
     *
     * Infer the likely gender of a Chinese name in LATIN (Pinyin).
     *
     * @param  string $chinese_surname_latin chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyin'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\FirstLastNameGenderedOut
     */
    public function genderChineseNamePinyin($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['genderChineseNamePinyin'][0])
    {
        list($response) = $this->genderChineseNamePinyinWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $contentType);
        return $response;
    }

    /**
     * Operation genderChineseNamePinyinWithHttpInfo
     *
     * Infer the likely gender of a Chinese name in LATIN (Pinyin).
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyin'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\FirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderChineseNamePinyinWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['genderChineseNamePinyin'][0])
    {
        $request = $this->genderChineseNamePinyinRequest($chinese_surname_latin, $chinese_given_name_latin, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\FirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\FirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\FirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\FirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderChineseNamePinyinAsync
     *
     * Infer the likely gender of a Chinese name in LATIN (Pinyin).
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNamePinyinAsync($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['genderChineseNamePinyin'][0])
    {
        return $this->genderChineseNamePinyinAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderChineseNamePinyinAsyncWithHttpInfo
     *
     * Infer the likely gender of a Chinese name in LATIN (Pinyin).
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNamePinyinAsyncWithHttpInfo($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['genderChineseNamePinyin'][0])
    {
        $returnType = '\Namsor\Client\Model\FirstLastNameGenderedOut';
        $request = $this->genderChineseNamePinyinRequest($chinese_surname_latin, $chinese_given_name_latin, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderChineseNamePinyin'
     *
     * @param  string $chinese_surname_latin (required)
     * @param  string $chinese_given_name_latin (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyin'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderChineseNamePinyinRequest($chinese_surname_latin, $chinese_given_name_latin, string $contentType = self::contentTypes['genderChineseNamePinyin'][0])
    {

        // verify the required parameter 'chinese_surname_latin' is set
        if ($chinese_surname_latin === null || (is_array($chinese_surname_latin) && count($chinese_surname_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_surname_latin when calling genderChineseNamePinyin'
            );
        }

        // verify the required parameter 'chinese_given_name_latin' is set
        if ($chinese_given_name_latin === null || (is_array($chinese_given_name_latin) && count($chinese_given_name_latin) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_given_name_latin when calling genderChineseNamePinyin'
            );
        }


        $resourcePath = '/api2/json/genderChineseNamePinyin/{chineseSurnameLatin}/{chineseGivenNameLatin}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_surname_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseSurnameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_surname_latin),
                $resourcePath
            );
        }
        // path params
        if ($chinese_given_name_latin !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseGivenNameLatin' . '}',
                ObjectSerializer::toPathValue($chinese_given_name_latin),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation genderChineseNamePinyinBatch
     *
     * Infer the likely gender of up to 100 Chinese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchFirstLastNameGenderedOut
     */
    public function genderChineseNamePinyinBatch($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderChineseNamePinyinBatch'][0])
    {
        list($response) = $this->genderChineseNamePinyinBatchWithHttpInfo($batch_first_last_name_in, $contentType);
        return $response;
    }

    /**
     * Operation genderChineseNamePinyinBatchWithHttpInfo
     *
     * Infer the likely gender of up to 100 Chinese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchFirstLastNameGenderedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function genderChineseNamePinyinBatchWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderChineseNamePinyinBatch'][0])
    {
        $request = $this->genderChineseNamePinyinBatchRequest($batch_first_last_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchFirstLastNameGenderedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchFirstLastNameGenderedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchFirstLastNameGenderedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation genderChineseNamePinyinBatchAsync
     *
     * Infer the likely gender of up to 100 Chinese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNamePinyinBatchAsync($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderChineseNamePinyinBatch'][0])
    {
        return $this->genderChineseNamePinyinBatchAsyncWithHttpInfo($batch_first_last_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation genderChineseNamePinyinBatchAsyncWithHttpInfo
     *
     * Infer the likely gender of up to 100 Chinese names in LATIN (Pinyin).
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function genderChineseNamePinyinBatchAsyncWithHttpInfo($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderChineseNamePinyinBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchFirstLastNameGenderedOut';
        $request = $this->genderChineseNamePinyinBatchRequest($batch_first_last_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'genderChineseNamePinyinBatch'
     *
     * @param  \Namsor\Client\Model\BatchFirstLastNameIn|null $batch_first_last_name_in A list of names, with country code. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['genderChineseNamePinyinBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function genderChineseNamePinyinBatchRequest($batch_first_last_name_in = null, string $contentType = self::contentTypes['genderChineseNamePinyinBatch'][0])
    {



        $resourcePath = '/api2/json/genderChineseNamePinyinBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_first_last_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_first_last_name_in));
            } else {
                $httpBody = $batch_first_last_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseChineseName
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name)
     *
     * @param  string $chinese_name chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameParsedOut
     */
    public function parseChineseName($chinese_name, string $contentType = self::contentTypes['parseChineseName'][0])
    {
        list($response) = $this->parseChineseNameWithHttpInfo($chinese_name, $contentType);
        return $response;
    }

    /**
     * Operation parseChineseNameWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name)
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseChineseNameWithHttpInfo($chinese_name, string $contentType = self::contentTypes['parseChineseName'][0])
    {
        $request = $this->parseChineseNameRequest($chinese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseChineseNameAsync
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name)
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseChineseNameAsync($chinese_name, string $contentType = self::contentTypes['parseChineseName'][0])
    {
        return $this->parseChineseNameAsyncWithHttpInfo($chinese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseChineseNameAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name)
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseChineseNameAsyncWithHttpInfo($chinese_name, string $contentType = self::contentTypes['parseChineseName'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
        $request = $this->parseChineseNameRequest($chinese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseChineseName'
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseChineseNameRequest($chinese_name, string $contentType = self::contentTypes['parseChineseName'][0])
    {

        // verify the required parameter 'chinese_name' is set
        if ($chinese_name === null || (is_array($chinese_name) && count($chinese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_name when calling parseChineseName'
            );
        }


        $resourcePath = '/api2/json/parseChineseName/{chineseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseName' . '}',
                ObjectSerializer::toPathValue($chinese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation parseChineseNameBatch
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameParsedOut
     */
    public function parseChineseNameBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['parseChineseNameBatch'][0])
    {
        list($response) = $this->parseChineseNameBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation parseChineseNameBatchWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function parseChineseNameBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['parseChineseNameBatch'][0])
    {
        $request = $this->parseChineseNameBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation parseChineseNameBatchAsync
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseChineseNameBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['parseChineseNameBatch'][0])
    {
        return $this->parseChineseNameBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation parseChineseNameBatchAsyncWithHttpInfo
     *
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function parseChineseNameBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['parseChineseNameBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
        $request = $this->parseChineseNameBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'parseChineseNameBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of personal names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['parseChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function parseChineseNameBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['parseChineseNameBatch'][0])
    {



        $resourcePath = '/api2/json/parseChineseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pinyinChineseName
     *
     * Romanize the Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name)
     *
     * @param  string $chinese_name chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\PersonalNameParsedOut
     */
    public function pinyinChineseName($chinese_name, string $contentType = self::contentTypes['pinyinChineseName'][0])
    {
        list($response) = $this->pinyinChineseNameWithHttpInfo($chinese_name, $contentType);
        return $response;
    }

    /**
     * Operation pinyinChineseNameWithHttpInfo
     *
     * Romanize the Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name)
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseName'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\PersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function pinyinChineseNameWithHttpInfo($chinese_name, string $contentType = self::contentTypes['pinyinChineseName'][0])
    {
        $request = $this->pinyinChineseNameRequest($chinese_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\PersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\PersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\PersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\PersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pinyinChineseNameAsync
     *
     * Romanize the Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name)
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinyinChineseNameAsync($chinese_name, string $contentType = self::contentTypes['pinyinChineseName'][0])
    {
        return $this->pinyinChineseNameAsyncWithHttpInfo($chinese_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pinyinChineseNameAsyncWithHttpInfo
     *
     * Romanize the Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name)
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinyinChineseNameAsyncWithHttpInfo($chinese_name, string $contentType = self::contentTypes['pinyinChineseName'][0])
    {
        $returnType = '\Namsor\Client\Model\PersonalNameParsedOut';
        $request = $this->pinyinChineseNameRequest($chinese_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pinyinChineseName'
     *
     * @param  string $chinese_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseName'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pinyinChineseNameRequest($chinese_name, string $contentType = self::contentTypes['pinyinChineseName'][0])
    {

        // verify the required parameter 'chinese_name' is set
        if ($chinese_name === null || (is_array($chinese_name) && count($chinese_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chinese_name when calling pinyinChineseName'
            );
        }


        $resourcePath = '/api2/json/pinyinChineseName/{chineseName}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($chinese_name !== null) {
            $resourcePath = str_replace(
                '{' . 'chineseName' . '}',
                ObjectSerializer::toPathValue($chinese_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation pinyinChineseNameBatch
     *
     * Romanize a list of Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of Chinese names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \Namsor\Client\Model\BatchPersonalNameParsedOut
     */
    public function pinyinChineseNameBatch($batch_personal_name_in = null, string $contentType = self::contentTypes['pinyinChineseNameBatch'][0])
    {
        list($response) = $this->pinyinChineseNameBatchWithHttpInfo($batch_personal_name_in, $contentType);
        return $response;
    }

    /**
     * Operation pinyinChineseNameBatchWithHttpInfo
     *
     * Romanize a list of Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of Chinese names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \Namsor\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \Namsor\Client\Model\BatchPersonalNameParsedOut, HTTP status code, HTTP response headers (array of strings)
     */
    public function pinyinChineseNameBatchWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['pinyinChineseNameBatch'][0])
    {
        $request = $this->pinyinChineseNameBatchRequest($batch_personal_name_in, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Namsor\Client\Model\BatchPersonalNameParsedOut' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Namsor\Client\Model\BatchPersonalNameParsedOut', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Namsor\Client\Model\BatchPersonalNameParsedOut',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation pinyinChineseNameBatchAsync
     *
     * Romanize a list of Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of Chinese names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinyinChineseNameBatchAsync($batch_personal_name_in = null, string $contentType = self::contentTypes['pinyinChineseNameBatch'][0])
    {
        return $this->pinyinChineseNameBatchAsyncWithHttpInfo($batch_personal_name_in, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation pinyinChineseNameBatchAsyncWithHttpInfo
     *
     * Romanize a list of Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name).
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of Chinese names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function pinyinChineseNameBatchAsyncWithHttpInfo($batch_personal_name_in = null, string $contentType = self::contentTypes['pinyinChineseNameBatch'][0])
    {
        $returnType = '\Namsor\Client\Model\BatchPersonalNameParsedOut';
        $request = $this->pinyinChineseNameBatchRequest($batch_personal_name_in, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'pinyinChineseNameBatch'
     *
     * @param  \Namsor\Client\Model\BatchPersonalNameIn|null $batch_personal_name_in A list of Chinese names (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['pinyinChineseNameBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function pinyinChineseNameBatchRequest($batch_personal_name_in = null, string $contentType = self::contentTypes['pinyinChineseNameBatch'][0])
    {



        $resourcePath = '/api2/json/pinyinChineseNameBatch';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_personal_name_in)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_personal_name_in));
            } else {
                $httpBody = $batch_personal_name_in;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-API-KEY');
        if ($apiKey !== null) {
            $headers['X-API-KEY'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
