<?php
/**
 * APIPlanSubscriptionOut
 *
 * PHP version 7.4
 *
 * @category Class
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * NamSor API v2
 *
 * NamSor API v2 : enpoints to process personal names (gender, cultural origin or ethnicity) in all alphabets or languages. By default, enpoints use 1 unit per name (ex. Gender), but Ethnicity classification uses 10 to 20 units per name depending on taxonomy. Use GET methods for small tests, but prefer POST methods for higher throughput (batch processing of up to 100 names at a time). Need something you can't find here? We have many more features coming soon. Let us know, we'll do our best to add it!
 *
 * The version of the OpenAPI document: 2.0.29
 * Contact: contact@namsor.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Namsor\Client\Model;

use \ArrayAccess;
use \Namsor\Client\ObjectSerializer;

/**
 * APIPlanSubscriptionOut Class Doc Comment
 *
 * @category Class
 * @description The API Plan governing the subscription.
 * @package  Namsor\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class APIPlanSubscriptionOut implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'APIPlanSubscriptionOut';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'api_key' => 'string',
        'plan_started' => 'int',
        'prior_plan_started' => 'int',
        'plan_ended' => 'int',
        'tax_rate' => 'float',
        'plan_name' => 'string',
        'plan_base_fees_key' => 'string',
        'plan_status' => 'string',
        'plan_quota' => 'int',
        'price_usd' => 'float',
        'price_overage_usd' => 'float',
        'price' => 'float',
        'price_overage' => 'float',
        'currency' => 'string',
        'currency_factor' => 'float',
        'stripe_customer_id' => 'string',
        'stripe_status' => 'string',
        'stripe_subscription' => 'string',
        'user_id' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'api_key' => null,
        'plan_started' => 'int64',
        'prior_plan_started' => 'int64',
        'plan_ended' => 'int64',
        'tax_rate' => 'double',
        'plan_name' => null,
        'plan_base_fees_key' => null,
        'plan_status' => null,
        'plan_quota' => 'int64',
        'price_usd' => 'double',
        'price_overage_usd' => 'double',
        'price' => 'double',
        'price_overage' => 'double',
        'currency' => null,
        'currency_factor' => 'double',
        'stripe_customer_id' => null,
        'stripe_status' => null,
        'stripe_subscription' => null,
        'user_id' => null
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'api_key' => false,
        'plan_started' => false,
        'prior_plan_started' => false,
        'plan_ended' => false,
        'tax_rate' => false,
        'plan_name' => false,
        'plan_base_fees_key' => false,
        'plan_status' => false,
        'plan_quota' => false,
        'price_usd' => false,
        'price_overage_usd' => false,
        'price' => false,
        'price_overage' => false,
        'currency' => false,
        'currency_factor' => false,
        'stripe_customer_id' => false,
        'stripe_status' => false,
        'stripe_subscription' => false,
        'user_id' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'api_key' => 'apiKey',
        'plan_started' => 'planStarted',
        'prior_plan_started' => 'priorPlanStarted',
        'plan_ended' => 'planEnded',
        'tax_rate' => 'taxRate',
        'plan_name' => 'planName',
        'plan_base_fees_key' => 'planBaseFeesKey',
        'plan_status' => 'planStatus',
        'plan_quota' => 'planQuota',
        'price_usd' => 'priceUSD',
        'price_overage_usd' => 'priceOverageUSD',
        'price' => 'price',
        'price_overage' => 'priceOverage',
        'currency' => 'currency',
        'currency_factor' => 'currencyFactor',
        'stripe_customer_id' => 'stripeCustomerId',
        'stripe_status' => 'stripeStatus',
        'stripe_subscription' => 'stripeSubscription',
        'user_id' => 'userId'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'api_key' => 'setApiKey',
        'plan_started' => 'setPlanStarted',
        'prior_plan_started' => 'setPriorPlanStarted',
        'plan_ended' => 'setPlanEnded',
        'tax_rate' => 'setTaxRate',
        'plan_name' => 'setPlanName',
        'plan_base_fees_key' => 'setPlanBaseFeesKey',
        'plan_status' => 'setPlanStatus',
        'plan_quota' => 'setPlanQuota',
        'price_usd' => 'setPriceUsd',
        'price_overage_usd' => 'setPriceOverageUsd',
        'price' => 'setPrice',
        'price_overage' => 'setPriceOverage',
        'currency' => 'setCurrency',
        'currency_factor' => 'setCurrencyFactor',
        'stripe_customer_id' => 'setStripeCustomerId',
        'stripe_status' => 'setStripeStatus',
        'stripe_subscription' => 'setStripeSubscription',
        'user_id' => 'setUserId'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'api_key' => 'getApiKey',
        'plan_started' => 'getPlanStarted',
        'prior_plan_started' => 'getPriorPlanStarted',
        'plan_ended' => 'getPlanEnded',
        'tax_rate' => 'getTaxRate',
        'plan_name' => 'getPlanName',
        'plan_base_fees_key' => 'getPlanBaseFeesKey',
        'plan_status' => 'getPlanStatus',
        'plan_quota' => 'getPlanQuota',
        'price_usd' => 'getPriceUsd',
        'price_overage_usd' => 'getPriceOverageUsd',
        'price' => 'getPrice',
        'price_overage' => 'getPriceOverage',
        'currency' => 'getCurrency',
        'currency_factor' => 'getCurrencyFactor',
        'stripe_customer_id' => 'getStripeCustomerId',
        'stripe_status' => 'getStripeStatus',
        'stripe_subscription' => 'getStripeSubscription',
        'user_id' => 'getUserId'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }


    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('api_key', $data ?? [], null);
        $this->setIfExists('plan_started', $data ?? [], null);
        $this->setIfExists('prior_plan_started', $data ?? [], null);
        $this->setIfExists('plan_ended', $data ?? [], null);
        $this->setIfExists('tax_rate', $data ?? [], null);
        $this->setIfExists('plan_name', $data ?? [], null);
        $this->setIfExists('plan_base_fees_key', $data ?? [], null);
        $this->setIfExists('plan_status', $data ?? [], null);
        $this->setIfExists('plan_quota', $data ?? [], null);
        $this->setIfExists('price_usd', $data ?? [], null);
        $this->setIfExists('price_overage_usd', $data ?? [], null);
        $this->setIfExists('price', $data ?? [], null);
        $this->setIfExists('price_overage', $data ?? [], null);
        $this->setIfExists('currency', $data ?? [], null);
        $this->setIfExists('currency_factor', $data ?? [], null);
        $this->setIfExists('stripe_customer_id', $data ?? [], null);
        $this->setIfExists('stripe_status', $data ?? [], null);
        $this->setIfExists('stripe_subscription', $data ?? [], null);
        $this->setIfExists('user_id', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets api_key
     *
     * @return string|null
     */
    public function getApiKey()
    {
        return $this->container['api_key'];
    }

    /**
     * Sets api_key
     *
     * @param string|null $api_key User API Key.
     *
     * @return self
     */
    public function setApiKey($api_key)
    {
        if (is_null($api_key)) {
            throw new \InvalidArgumentException('non-nullable api_key cannot be null');
        }
        $this->container['api_key'] = $api_key;

        return $this;
    }

    /**
     * Gets plan_started
     *
     * @return int|null
     */
    public function getPlanStarted()
    {
        return $this->container['plan_started'];
    }

    /**
     * Sets plan_started
     *
     * @param int|null $plan_started Datetime when the user subscribed to the current plan.
     *
     * @return self
     */
    public function setPlanStarted($plan_started)
    {
        if (is_null($plan_started)) {
            throw new \InvalidArgumentException('non-nullable plan_started cannot be null');
        }
        $this->container['plan_started'] = $plan_started;

        return $this;
    }

    /**
     * Gets prior_plan_started
     *
     * @return int|null
     */
    public function getPriorPlanStarted()
    {
        return $this->container['prior_plan_started'];
    }

    /**
     * Sets prior_plan_started
     *
     * @param int|null $prior_plan_started Datetime when the user subscribed to the prior plan.
     *
     * @return self
     */
    public function setPriorPlanStarted($prior_plan_started)
    {
        if (is_null($prior_plan_started)) {
            throw new \InvalidArgumentException('non-nullable prior_plan_started cannot be null');
        }
        $this->container['prior_plan_started'] = $prior_plan_started;

        return $this;
    }

    /**
     * Gets plan_ended
     *
     * @return int|null
     */
    public function getPlanEnded()
    {
        return $this->container['plan_ended'];
    }

    /**
     * Sets plan_ended
     *
     * @param int|null $plan_ended Datetime when the user ended the plan.
     *
     * @return self
     */
    public function setPlanEnded($plan_ended)
    {
        if (is_null($plan_ended)) {
            throw new \InvalidArgumentException('non-nullable plan_ended cannot be null');
        }
        $this->container['plan_ended'] = $plan_ended;

        return $this;
    }

    /**
     * Gets tax_rate
     *
     * @return float|null
     */
    public function getTaxRate()
    {
        return $this->container['tax_rate'];
    }

    /**
     * Sets tax_rate
     *
     * @param float|null $tax_rate Applicable tax rate for the plan.
     *
     * @return self
     */
    public function setTaxRate($tax_rate)
    {
        if (is_null($tax_rate)) {
            throw new \InvalidArgumentException('non-nullable tax_rate cannot be null');
        }
        $this->container['tax_rate'] = $tax_rate;

        return $this;
    }

    /**
     * Gets plan_name
     *
     * @return string|null
     */
    public function getPlanName()
    {
        return $this->container['plan_name'];
    }

    /**
     * Sets plan_name
     *
     * @param string|null $plan_name Current plan name.
     *
     * @return self
     */
    public function setPlanName($plan_name)
    {
        if (is_null($plan_name)) {
            throw new \InvalidArgumentException('non-nullable plan_name cannot be null');
        }
        $this->container['plan_name'] = $plan_name;

        return $this;
    }

    /**
     * Gets plan_base_fees_key
     *
     * @return string|null
     */
    public function getPlanBaseFeesKey()
    {
        return $this->container['plan_base_fees_key'];
    }

    /**
     * Sets plan_base_fees_key
     *
     * @param string|null $plan_base_fees_key Current plan key (as in Stripe product).
     *
     * @return self
     */
    public function setPlanBaseFeesKey($plan_base_fees_key)
    {
        if (is_null($plan_base_fees_key)) {
            throw new \InvalidArgumentException('non-nullable plan_base_fees_key cannot be null');
        }
        $this->container['plan_base_fees_key'] = $plan_base_fees_key;

        return $this;
    }

    /**
     * Gets plan_status
     *
     * @return string|null
     */
    public function getPlanStatus()
    {
        return $this->container['plan_status'];
    }

    /**
     * Sets plan_status
     *
     * @param string|null $plan_status Plan status.
     *
     * @return self
     */
    public function setPlanStatus($plan_status)
    {
        if (is_null($plan_status)) {
            throw new \InvalidArgumentException('non-nullable plan_status cannot be null');
        }
        $this->container['plan_status'] = $plan_status;

        return $this;
    }

    /**
     * Gets plan_quota
     *
     * @return int|null
     */
    public function getPlanQuota()
    {
        return $this->container['plan_quota'];
    }

    /**
     * Sets plan_quota
     *
     * @param int|null $plan_quota Current plan quota in quantity of units (NB: some API use several units per name).
     *
     * @return self
     */
    public function setPlanQuota($plan_quota)
    {
        if (is_null($plan_quota)) {
            throw new \InvalidArgumentException('non-nullable plan_quota cannot be null');
        }
        $this->container['plan_quota'] = $plan_quota;

        return $this;
    }

    /**
     * Gets price_usd
     *
     * @return float|null
     */
    public function getPriceUsd()
    {
        return $this->container['price_usd'];
    }

    /**
     * Sets price_usd
     *
     * @param float|null $price_usd Current plan monthly price expressed in USD (includes a free quota).
     *
     * @return self
     */
    public function setPriceUsd($price_usd)
    {
        if (is_null($price_usd)) {
            throw new \InvalidArgumentException('non-nullable price_usd cannot be null');
        }
        $this->container['price_usd'] = $price_usd;

        return $this;
    }

    /**
     * Gets price_overage_usd
     *
     * @return float|null
     */
    public function getPriceOverageUsd()
    {
        return $this->container['price_overage_usd'];
    }

    /**
     * Sets price_overage_usd
     *
     * @param float|null $price_overage_usd Current plan price for overages expressed in USD (extra price per unit above the free quota).
     *
     * @return self
     */
    public function setPriceOverageUsd($price_overage_usd)
    {
        if (is_null($price_overage_usd)) {
            throw new \InvalidArgumentException('non-nullable price_overage_usd cannot be null');
        }
        $this->container['price_overage_usd'] = $price_overage_usd;

        return $this;
    }

    /**
     * Gets price
     *
     * @return float|null
     */
    public function getPrice()
    {
        return $this->container['price'];
    }

    /**
     * Sets price
     *
     * @param float|null $price Current plan price for overages expressed in Currency (extra price per unit above the free quota).
     *
     * @return self
     */
    public function setPrice($price)
    {
        if (is_null($price)) {
            throw new \InvalidArgumentException('non-nullable price cannot be null');
        }
        $this->container['price'] = $price;

        return $this;
    }

    /**
     * Gets price_overage
     *
     * @return float|null
     */
    public function getPriceOverage()
    {
        return $this->container['price_overage'];
    }

    /**
     * Sets price_overage
     *
     * @param float|null $price_overage Current plan price for overages expressed in Currency (extra price per unit above the free quota).
     *
     * @return self
     */
    public function setPriceOverage($price_overage)
    {
        if (is_null($price_overage)) {
            throw new \InvalidArgumentException('non-nullable price_overage cannot be null');
        }
        $this->container['price_overage'] = $price_overage;

        return $this;
    }

    /**
     * Gets currency
     *
     * @return string|null
     */
    public function getCurrency()
    {
        return $this->container['currency'];
    }

    /**
     * Sets currency
     *
     * @param string|null $currency Current plan Currency for prices.
     *
     * @return self
     */
    public function setCurrency($currency)
    {
        if (is_null($currency)) {
            throw new \InvalidArgumentException('non-nullable currency cannot be null');
        }
        $this->container['currency'] = $currency;

        return $this;
    }

    /**
     * Gets currency_factor
     *
     * @return float|null
     */
    public function getCurrencyFactor()
    {
        return $this->container['currency_factor'];
    }

    /**
     * Sets currency_factor
     *
     * @param float|null $currency_factor For USD, GBP, EUR - the factor is 1.
     *
     * @return self
     */
    public function setCurrencyFactor($currency_factor)
    {
        if (is_null($currency_factor)) {
            throw new \InvalidArgumentException('non-nullable currency_factor cannot be null');
        }
        $this->container['currency_factor'] = $currency_factor;

        return $this;
    }

    /**
     * Gets stripe_customer_id
     *
     * @return string|null
     */
    public function getStripeCustomerId()
    {
        return $this->container['stripe_customer_id'];
    }

    /**
     * Sets stripe_customer_id
     *
     * @param string|null $stripe_customer_id Stripe customer identifier.
     *
     * @return self
     */
    public function setStripeCustomerId($stripe_customer_id)
    {
        if (is_null($stripe_customer_id)) {
            throw new \InvalidArgumentException('non-nullable stripe_customer_id cannot be null');
        }
        $this->container['stripe_customer_id'] = $stripe_customer_id;

        return $this;
    }

    /**
     * Gets stripe_status
     *
     * @return string|null
     */
    public function getStripeStatus()
    {
        return $this->container['stripe_status'];
    }

    /**
     * Sets stripe_status
     *
     * @param string|null $stripe_status Stripe status ex active.
     *
     * @return self
     */
    public function setStripeStatus($stripe_status)
    {
        if (is_null($stripe_status)) {
            throw new \InvalidArgumentException('non-nullable stripe_status cannot be null');
        }
        $this->container['stripe_status'] = $stripe_status;

        return $this;
    }

    /**
     * Gets stripe_subscription
     *
     * @return string|null
     */
    public function getStripeSubscription()
    {
        return $this->container['stripe_subscription'];
    }

    /**
     * Sets stripe_subscription
     *
     * @param string|null $stripe_subscription Stripe subscription identifier.
     *
     * @return self
     */
    public function setStripeSubscription($stripe_subscription)
    {
        if (is_null($stripe_subscription)) {
            throw new \InvalidArgumentException('non-nullable stripe_subscription cannot be null');
        }
        $this->container['stripe_subscription'] = $stripe_subscription;

        return $this;
    }

    /**
     * Gets user_id
     *
     * @return string|null
     */
    public function getUserId()
    {
        return $this->container['user_id'];
    }

    /**
     * Sets user_id
     *
     * @param string|null $user_id Internal user identifier.
     *
     * @return self
     */
    public function setUserId($user_id)
    {
        if (is_null($user_id)) {
            throw new \InvalidArgumentException('non-nullable user_id cannot be null');
        }
        $this->container['user_id'] = $user_id;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


