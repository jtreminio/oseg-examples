/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package app.namsor.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import app.namsor.client.models.APIClassifierTaxonomyOut
import app.namsor.client.models.APIClassifiersStatusOut
import app.namsor.client.models.APIKeyOut
import app.namsor.client.models.APIPeriodUsageOut
import app.namsor.client.models.APIServicesOut
import app.namsor.client.models.APIUsageAggregatedOut
import app.namsor.client.models.APIUsageHistoryOut
import app.namsor.client.models.RegionOut
import app.namsor.client.models.SoftwareVersionOut

import com.squareup.moshi.Json

import app.namsor.client.infrastructure.ApiClient
import app.namsor.client.infrastructure.ApiResponse
import app.namsor.client.infrastructure.ClientException
import app.namsor.client.infrastructure.ClientError
import app.namsor.client.infrastructure.ServerException
import app.namsor.client.infrastructure.ServerError
import app.namsor.client.infrastructure.MultiValueMap
import app.namsor.client.infrastructure.PartConfig
import app.namsor.client.infrastructure.RequestConfig
import app.namsor.client.infrastructure.RequestMethod
import app.namsor.client.infrastructure.ResponseType
import app.namsor.client.infrastructure.Success
import app.namsor.client.infrastructure.toMultiValue

class AdminApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://v2.namsor.com/NamSorAPIv2")
        }
    }

    /**
     * Activate/deactivate anonymization for a source.
     * 
     * @param source 
     * @param anonymized 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun anonymize(source: kotlin.String, anonymized: kotlin.Boolean) : Unit {
        val localVarResponse = anonymizeWithHttpInfo(source = source, anonymized = anonymized)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Activate/deactivate anonymization for a source.
     * 
     * @param source 
     * @param anonymized 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun anonymizeWithHttpInfo(source: kotlin.String, anonymized: kotlin.Boolean) : ApiResponse<Unit?> {
        val localVariableConfig = anonymizeRequestConfig(source = source, anonymized = anonymized)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation anonymize
     *
     * @param source 
     * @param anonymized 
     * @return RequestConfig
     */
    fun anonymizeRequestConfig(source: kotlin.String, anonymized: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/anonymize/{source}/{anonymized}".replace("{"+"source"+"}", encodeURIComponent(source.toString())).replace("{"+"anonymized"+"}", encodeURIComponent(anonymized.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Activate/deactivate anonymization for a source.
     * 
     * @param source 
     * @param anonymized 
     * @param token 
     * @return APIKeyOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun anonymize1(source: kotlin.String, anonymized: kotlin.Boolean, token: kotlin.String) : APIKeyOut {
        val localVarResponse = anonymize1WithHttpInfo(source = source, anonymized = anonymized, token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIKeyOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Activate/deactivate anonymization for a source.
     * 
     * @param source 
     * @param anonymized 
     * @param token 
     * @return ApiResponse<APIKeyOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun anonymize1WithHttpInfo(source: kotlin.String, anonymized: kotlin.Boolean, token: kotlin.String) : ApiResponse<APIKeyOut?> {
        val localVariableConfig = anonymize1RequestConfig(source = source, anonymized = anonymized, token = token)

        return request<Unit, APIKeyOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation anonymize1
     *
     * @param source 
     * @param anonymized 
     * @param token 
     * @return RequestConfig
     */
    fun anonymize1RequestConfig(source: kotlin.String, anonymized: kotlin.Boolean, token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/anonymize/{source}/{anonymized}/{token}".replace("{"+"source"+"}", encodeURIComponent(source.toString())).replace("{"+"anonymized"+"}", encodeURIComponent(anonymized.toString())).replace("{"+"token"+"}", encodeURIComponent(token.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Read API Key info.
     * 
     * @return APIKeyOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiKeyInfo() : APIKeyOut {
        val localVarResponse = apiKeyInfoWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIKeyOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Read API Key info.
     * 
     * @return ApiResponse<APIKeyOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiKeyInfoWithHttpInfo() : ApiResponse<APIKeyOut?> {
        val localVariableConfig = apiKeyInfoRequestConfig()

        return request<Unit, APIKeyOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiKeyInfo
     *
     * @return RequestConfig
     */
    fun apiKeyInfoRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/apiKeyInfo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Prints the current status of the classifiers. A classifier name in apiStatus corresponds to a service name in apiServices.
     * 
     * @return APIClassifiersStatusOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiStatus() : APIClassifiersStatusOut {
        val localVarResponse = apiStatusWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIClassifiersStatusOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Prints the current status of the classifiers. A classifier name in apiStatus corresponds to a service name in apiServices.
     * 
     * @return ApiResponse<APIClassifiersStatusOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiStatusWithHttpInfo() : ApiResponse<APIClassifiersStatusOut?> {
        val localVariableConfig = apiStatusRequestConfig()

        return request<Unit, APIClassifiersStatusOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiStatus
     *
     * @return RequestConfig
     */
    fun apiStatusRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/apiStatus",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Print current API usage.
     * 
     * @return APIPeriodUsageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiUsage() : APIPeriodUsageOut {
        val localVarResponse = apiUsageWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIPeriodUsageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Print current API usage.
     * 
     * @return ApiResponse<APIPeriodUsageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiUsageWithHttpInfo() : ApiResponse<APIPeriodUsageOut?> {
        val localVariableConfig = apiUsageRequestConfig()

        return request<Unit, APIPeriodUsageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiUsage
     *
     * @return RequestConfig
     */
    fun apiUsageRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/apiUsage",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Print historical API usage.
     * 
     * @return APIUsageHistoryOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiUsageHistory() : APIUsageHistoryOut {
        val localVarResponse = apiUsageHistoryWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIUsageHistoryOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Print historical API usage.
     * 
     * @return ApiResponse<APIUsageHistoryOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiUsageHistoryWithHttpInfo() : ApiResponse<APIUsageHistoryOut?> {
        val localVariableConfig = apiUsageHistoryRequestConfig()

        return request<Unit, APIUsageHistoryOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiUsageHistory
     *
     * @return RequestConfig
     */
    fun apiUsageHistoryRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/apiUsageHistory",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Print historical API usage (in an aggregated view, by service, by day/hour/min).
     * 
     * @return APIUsageAggregatedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun apiUsageHistoryAggregate() : APIUsageAggregatedOut {
        val localVarResponse = apiUsageHistoryAggregateWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIUsageAggregatedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Print historical API usage (in an aggregated view, by service, by day/hour/min).
     * 
     * @return ApiResponse<APIUsageAggregatedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun apiUsageHistoryAggregateWithHttpInfo() : ApiResponse<APIUsageAggregatedOut?> {
        val localVariableConfig = apiUsageHistoryAggregateRequestConfig()

        return request<Unit, APIUsageAggregatedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation apiUsageHistoryAggregate
     *
     * @return RequestConfig
     */
    fun apiUsageHistoryAggregateRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/apiUsageHistoryAggregate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List of classification services and usage cost in Units per classification (default is 1&#x3D;ONE Unit). Some API endpoints (ex. Corridor) combine multiple classifiers.
     * 
     * @return APIServicesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun availableServices() : APIServicesOut {
        val localVarResponse = availableServicesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIServicesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List of classification services and usage cost in Units per classification (default is 1&#x3D;ONE Unit). Some API endpoints (ex. Corridor) combine multiple classifiers.
     * 
     * @return ApiResponse<APIServicesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun availableServicesWithHttpInfo() : ApiResponse<APIServicesOut?> {
        val localVariableConfig = availableServicesRequestConfig()

        return request<Unit, APIServicesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation availableServices
     *
     * @return RequestConfig
     */
    fun availableServicesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/apiServices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Activate/deactivate an API Key.
     * 
     * @param source The API Key to set as enabled/disabled.
     * @param disabled 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun disable(source: kotlin.String, disabled: kotlin.Boolean) : Unit {
        val localVarResponse = disableWithHttpInfo(source = source, disabled = disabled)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Activate/deactivate an API Key.
     * 
     * @param source The API Key to set as enabled/disabled.
     * @param disabled 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun disableWithHttpInfo(source: kotlin.String, disabled: kotlin.Boolean) : ApiResponse<Unit?> {
        val localVariableConfig = disableRequestConfig(source = source, disabled = disabled)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation disable
     *
     * @param source The API Key to set as enabled/disabled.
     * @param disabled 
     * @return RequestConfig
     */
    fun disableRequestConfig(source: kotlin.String, disabled: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/disable/{source}/{disabled}".replace("{"+"source"+"}", encodeURIComponent(source.toString())).replace("{"+"disabled"+"}", encodeURIComponent(disabled.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Activate/deactivate learning from a source.
     * 
     * @param source The API Key to set as learnable/non learnable.
     * @param learnable 
     * @param token 
     * @return APIKeyOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun learnable(source: kotlin.String, learnable: kotlin.Boolean, token: kotlin.String) : APIKeyOut {
        val localVarResponse = learnableWithHttpInfo(source = source, learnable = learnable, token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIKeyOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Activate/deactivate learning from a source.
     * 
     * @param source The API Key to set as learnable/non learnable.
     * @param learnable 
     * @param token 
     * @return ApiResponse<APIKeyOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun learnableWithHttpInfo(source: kotlin.String, learnable: kotlin.Boolean, token: kotlin.String) : ApiResponse<APIKeyOut?> {
        val localVariableConfig = learnableRequestConfig(source = source, learnable = learnable, token = token)

        return request<Unit, APIKeyOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation learnable
     *
     * @param source The API Key to set as learnable/non learnable.
     * @param learnable 
     * @param token 
     * @return RequestConfig
     */
    fun learnableRequestConfig(source: kotlin.String, learnable: kotlin.Boolean, token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/learnable/{source}/{learnable}/{token}".replace("{"+"source"+"}", encodeURIComponent(source.toString())).replace("{"+"learnable"+"}", encodeURIComponent(learnable.toString())).replace("{"+"token"+"}", encodeURIComponent(token.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Activate/deactivate learning from a source.
     * 
     * @param source The API Key to set as learnable/non learnable.
     * @param learnable 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun learnable1(source: kotlin.String, learnable: kotlin.Boolean) : Unit {
        val localVarResponse = learnable1WithHttpInfo(source = source, learnable = learnable)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Activate/deactivate learning from a source.
     * 
     * @param source The API Key to set as learnable/non learnable.
     * @param learnable 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun learnable1WithHttpInfo(source: kotlin.String, learnable: kotlin.Boolean) : ApiResponse<Unit?> {
        val localVariableConfig = learnable1RequestConfig(source = source, learnable = learnable)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation learnable1
     *
     * @param source The API Key to set as learnable/non learnable.
     * @param learnable 
     * @return RequestConfig
     */
    fun learnable1RequestConfig(source: kotlin.String, learnable: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/learnable/{source}/{learnable}".replace("{"+"source"+"}", encodeURIComponent(source.toString())).replace("{"+"learnable"+"}", encodeURIComponent(learnable.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Print basic source statistics.
     * 
     * @return RegionOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun regions() : RegionOut {
        val localVarResponse = regionsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RegionOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Print basic source statistics.
     * 
     * @return ApiResponse<RegionOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun regionsWithHttpInfo() : ApiResponse<RegionOut?> {
        val localVariableConfig = regionsRequestConfig()

        return request<Unit, RegionOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation regions
     *
     * @return RequestConfig
     */
    fun regionsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/regions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get the current software version
     * 
     * @return SoftwareVersionOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun softwareVersion() : SoftwareVersionOut {
        val localVarResponse = softwareVersionWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SoftwareVersionOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get the current software version
     * 
     * @return ApiResponse<SoftwareVersionOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun softwareVersionWithHttpInfo() : ApiResponse<SoftwareVersionOut?> {
        val localVariableConfig = softwareVersionRequestConfig()

        return request<Unit, SoftwareVersionOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation softwareVersion
     *
     * @return RequestConfig
     */
    fun softwareVersionRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/softwareVersion",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Print the taxonomy classes valid for the given classifier.
     * 
     * @param classifierName 
     * @return APIClassifierTaxonomyOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun taxonomyClasses(classifierName: kotlin.String) : APIClassifierTaxonomyOut {
        val localVarResponse = taxonomyClassesWithHttpInfo(classifierName = classifierName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as APIClassifierTaxonomyOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Print the taxonomy classes valid for the given classifier.
     * 
     * @param classifierName 
     * @return ApiResponse<APIClassifierTaxonomyOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun taxonomyClassesWithHttpInfo(classifierName: kotlin.String) : ApiResponse<APIClassifierTaxonomyOut?> {
        val localVariableConfig = taxonomyClassesRequestConfig(classifierName = classifierName)

        return request<Unit, APIClassifierTaxonomyOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation taxonomyClasses
     *
     * @param classifierName 
     * @return RequestConfig
     */
    fun taxonomyClassesRequestConfig(classifierName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/taxonomyClasses/{classifierName}".replace("{"+"classifierName"+"}", encodeURIComponent(classifierName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
