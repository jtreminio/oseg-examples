/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package app.namsor.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import app.namsor.client.models.BatchCommunityEngageFullOut
import app.namsor.client.models.BatchCommunityEngageOut
import app.namsor.client.models.BatchCorridorIn
import app.namsor.client.models.BatchCorridorOut
import app.namsor.client.models.BatchFirstLastNameDiasporaedOut
import app.namsor.client.models.BatchFirstLastNameGenderedOut
import app.namsor.client.models.BatchFirstLastNameGeoIn
import app.namsor.client.models.BatchFirstLastNameGeoOut
import app.namsor.client.models.BatchFirstLastNameGeoSubclassificationOut
import app.namsor.client.models.BatchFirstLastNameGeoSubdivisionIn
import app.namsor.client.models.BatchFirstLastNameGeoZippedIn
import app.namsor.client.models.BatchFirstLastNameIn
import app.namsor.client.models.BatchFirstLastNameOriginedOut
import app.namsor.client.models.BatchFirstLastNameReligionedOut
import app.namsor.client.models.BatchFirstLastNameUSRaceEthnicityOut
import app.namsor.client.models.BatchPersonalNameDiasporaedOut
import app.namsor.client.models.BatchPersonalNameGenderedOut
import app.namsor.client.models.BatchPersonalNameGeoIn
import app.namsor.client.models.BatchPersonalNameGeoOut
import app.namsor.client.models.BatchPersonalNameGeoSubclassificationOut
import app.namsor.client.models.BatchPersonalNameGeoSubdivisionIn
import app.namsor.client.models.BatchPersonalNameIn
import app.namsor.client.models.BatchPersonalNameOriginedOut
import app.namsor.client.models.BatchPersonalNameParsedOut
import app.namsor.client.models.BatchPersonalNameReligionedOut
import app.namsor.client.models.BatchPersonalNameUSRaceEthnicityOut
import app.namsor.client.models.CommunityEngageOut
import app.namsor.client.models.CorridorOut
import app.namsor.client.models.FirstLastNameDiasporaedOut
import app.namsor.client.models.FirstLastNameGenderedOut
import app.namsor.client.models.FirstLastNameGeoSubclassificationOut
import app.namsor.client.models.FirstLastNameOriginedOut
import app.namsor.client.models.FirstLastNameReligionedOut
import app.namsor.client.models.FirstLastNameUSRaceEthnicityOut
import app.namsor.client.models.PersonalNameDiasporaedOut
import app.namsor.client.models.PersonalNameGenderedOut
import app.namsor.client.models.PersonalNameGeoOut
import app.namsor.client.models.PersonalNameOriginedOut
import app.namsor.client.models.PersonalNameParsedOut
import app.namsor.client.models.PersonalNameReligionedOut
import app.namsor.client.models.PersonalNameUSRaceEthnicityOut

import com.squareup.moshi.Json

import app.namsor.client.infrastructure.ApiClient
import app.namsor.client.infrastructure.ApiResponse
import app.namsor.client.infrastructure.ClientException
import app.namsor.client.infrastructure.ClientError
import app.namsor.client.infrastructure.ServerException
import app.namsor.client.infrastructure.ServerError
import app.namsor.client.infrastructure.MultiValueMap
import app.namsor.client.infrastructure.PartConfig
import app.namsor.client.infrastructure.RequestConfig
import app.namsor.client.infrastructure.RequestMethod
import app.namsor.client.infrastructure.ResponseType
import app.namsor.client.infrastructure.Success
import app.namsor.client.infrastructure.toMultiValue

class PersonalApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://v2.namsor.com/NamSorAPIv2")
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return CommunityEngageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun communityEngage(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : CommunityEngageOut {
        val localVarResponse = communityEngageWithHttpInfo(countryIso2 = countryIso2, firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CommunityEngageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<CommunityEngageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun communityEngageWithHttpInfo(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<CommunityEngageOut?> {
        val localVariableConfig = communityEngageRequestConfig(countryIso2 = countryIso2, firstName = firstName, lastName = lastName)

        return request<Unit, CommunityEngageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation communityEngage
     *
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun communityEngageRequestConfig(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/communityEngage/{countryIso2}/{firstName}/{lastName}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchCommunityEngageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun communityEngageBatch(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn? = null) : BatchCommunityEngageOut {
        val localVarResponse = communityEngageBatchWithHttpInfo(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchCommunityEngageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchCommunityEngageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun communityEngageBatchWithHttpInfo(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : ApiResponse<BatchCommunityEngageOut?> {
        val localVariableConfig = communityEngageBatchRequestConfig(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return request<BatchFirstLastNameGeoIn, BatchCommunityEngageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation communityEngageBatch
     *
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun communityEngageBatchRequestConfig(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : RequestConfig<BatchFirstLastNameGeoIn> {
        val localVariableBody = batchFirstLastNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/communityEngageBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param countryIso2 
     * @param personalNameFull 
     * @return CommunityEngageOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun communityEngageFull(countryIso2: kotlin.String, personalNameFull: kotlin.String) : CommunityEngageOut {
        val localVarResponse = communityEngageFullWithHttpInfo(countryIso2 = countryIso2, personalNameFull = personalNameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CommunityEngageOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora, country, gender of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param countryIso2 
     * @param personalNameFull 
     * @return ApiResponse<CommunityEngageOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun communityEngageFullWithHttpInfo(countryIso2: kotlin.String, personalNameFull: kotlin.String) : ApiResponse<CommunityEngageOut?> {
        val localVariableConfig = communityEngageFullRequestConfig(countryIso2 = countryIso2, personalNameFull = personalNameFull)

        return request<Unit, CommunityEngageOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation communityEngageFull
     *
     * @param countryIso2 
     * @param personalNameFull 
     * @return RequestConfig
     */
    fun communityEngageFullRequestConfig(countryIso2: kotlin.String, personalNameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/communityEngageFull/{countryIso2}/{personalNameFull}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"personalNameFull"+"}", encodeURIComponent(personalNameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchCommunityEngageFullOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun communityEngageFullBatch(batchPersonalNameGeoIn: BatchPersonalNameGeoIn? = null) : BatchCommunityEngageFullOut {
        val localVarResponse = communityEngageFullBatchWithHttpInfo(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchCommunityEngageFullOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely ethnicity/diaspora, country, gender of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.) for community engagement (require special module/pricing)
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchCommunityEngageFullOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun communityEngageFullBatchWithHttpInfo(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : ApiResponse<BatchCommunityEngageFullOut?> {
        val localVariableConfig = communityEngageFullBatchRequestConfig(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return request<BatchPersonalNameGeoIn, BatchCommunityEngageFullOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation communityEngageFullBatch
     *
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun communityEngageFullBatchRequestConfig(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : RequestConfig<BatchPersonalNameGeoIn> {
        val localVariableBody = batchPersonalNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/communityEngageFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param countryIso2From 
     * @param firstNameFrom 
     * @param lastNameFrom 
     * @param countryIso2To 
     * @param firstNameTo 
     * @param lastNameTo 
     * @return CorridorOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun corridor(countryIso2From: kotlin.String, firstNameFrom: kotlin.String, lastNameFrom: kotlin.String, countryIso2To: kotlin.String, firstNameTo: kotlin.String, lastNameTo: kotlin.String) : CorridorOut {
        val localVarResponse = corridorWithHttpInfo(countryIso2From = countryIso2From, firstNameFrom = firstNameFrom, lastNameFrom = lastNameFrom, countryIso2To = countryIso2To, firstNameTo = firstNameTo, lastNameTo = lastNameTo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CorridorOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME COUPLE] Infer several classifications for a cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param countryIso2From 
     * @param firstNameFrom 
     * @param lastNameFrom 
     * @param countryIso2To 
     * @param firstNameTo 
     * @param lastNameTo 
     * @return ApiResponse<CorridorOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun corridorWithHttpInfo(countryIso2From: kotlin.String, firstNameFrom: kotlin.String, lastNameFrom: kotlin.String, countryIso2To: kotlin.String, firstNameTo: kotlin.String, lastNameTo: kotlin.String) : ApiResponse<CorridorOut?> {
        val localVariableConfig = corridorRequestConfig(countryIso2From = countryIso2From, firstNameFrom = firstNameFrom, lastNameFrom = lastNameFrom, countryIso2To = countryIso2To, firstNameTo = firstNameTo, lastNameTo = lastNameTo)

        return request<Unit, CorridorOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation corridor
     *
     * @param countryIso2From 
     * @param firstNameFrom 
     * @param lastNameFrom 
     * @param countryIso2To 
     * @param firstNameTo 
     * @param lastNameTo 
     * @return RequestConfig
     */
    fun corridorRequestConfig(countryIso2From: kotlin.String, firstNameFrom: kotlin.String, lastNameFrom: kotlin.String, countryIso2To: kotlin.String, firstNameTo: kotlin.String, lastNameTo: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/corridor/{countryIso2From}/{firstNameFrom}/{lastNameFrom}/{countryIso2To}/{firstNameTo}/{lastNameTo}".replace("{"+"countryIso2From"+"}", encodeURIComponent(countryIso2From.toString())).replace("{"+"firstNameFrom"+"}", encodeURIComponent(firstNameFrom.toString())).replace("{"+"lastNameFrom"+"}", encodeURIComponent(lastNameFrom.toString())).replace("{"+"countryIso2To"+"}", encodeURIComponent(countryIso2To.toString())).replace("{"+"firstNameTo"+"}", encodeURIComponent(firstNameTo.toString())).replace("{"+"lastNameTo"+"}", encodeURIComponent(lastNameTo.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @return BatchCorridorOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun corridorBatch(batchCorridorIn: BatchCorridorIn? = null) : BatchCorridorOut {
        val localVarResponse = corridorBatchWithHttpInfo(batchCorridorIn = batchCorridorIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchCorridorOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME PAIR] Infer several classifications for up to 100 cross border interaction between names (ex. remit, travel, intl com)
     * 
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @return ApiResponse<BatchCorridorOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun corridorBatchWithHttpInfo(batchCorridorIn: BatchCorridorIn?) : ApiResponse<BatchCorridorOut?> {
        val localVariableConfig = corridorBatchRequestConfig(batchCorridorIn = batchCorridorIn)

        return request<BatchCorridorIn, BatchCorridorOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation corridorBatch
     *
     * @param batchCorridorIn A list of name pairs, with country code (nameFrom -&gt; nameTo). (optional)
     * @return RequestConfig
     */
    fun corridorBatchRequestConfig(batchCorridorIn: BatchCorridorIn?) : RequestConfig<BatchCorridorIn> {
        val localVariableBody = batchCorridorIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/corridorBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param personalNameFull 
     * @return PersonalNameGeoOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun country(personalNameFull: kotlin.String) : PersonalNameGeoOut {
        val localVarResponse = countryWithHttpInfo(personalNameFull = personalNameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameGeoOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal full name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param personalNameFull 
     * @return ApiResponse<PersonalNameGeoOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun countryWithHttpInfo(personalNameFull: kotlin.String) : ApiResponse<PersonalNameGeoOut?> {
        val localVariableConfig = countryRequestConfig(personalNameFull = personalNameFull)

        return request<Unit, PersonalNameGeoOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation country
     *
     * @param personalNameFull 
     * @return RequestConfig
     */
    fun countryRequestConfig(personalNameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/country/{personalNameFull}".replace("{"+"personalNameFull"+"}", encodeURIComponent(personalNameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameGeoOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun countryBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameGeoOut {
        val localVarResponse = countryBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameGeoOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal full names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameGeoOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun countryBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameGeoOut?> {
        val localVariableConfig = countryBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameGeoOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation countryBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun countryBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/countryBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameOriginedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun countryFnLn(firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameOriginedOut {
        val localVarResponse = countryFnLnWithHttpInfo(firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameOriginedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of a personal first / last name, or one surname. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameOriginedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun countryFnLnWithHttpInfo(firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameOriginedOut?> {
        val localVariableConfig = countryFnLnRequestConfig(firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameOriginedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation countryFnLn
     *
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun countryFnLnRequestConfig(firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/countryFnLn/{firstName}/{lastName}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return BatchFirstLastNameGeoOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun countryFnLnBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchFirstLastNameGeoOut {
        val localVarResponse = countryFnLnBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameGeoOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of residence of up to 100 personal first / last names, or surnames. Assumes names as they are in the country of residence OR the country of origin.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameGeoOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun countryFnLnBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchFirstLastNameGeoOut?> {
        val localVariableConfig = countryFnLnBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchFirstLastNameGeoOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation countryFnLnBatch
     *
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun countryFnLnBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/countryFnLnBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameDiasporaedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun diaspora(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameDiasporaedOut {
        val localVarResponse = diasporaWithHttpInfo(countryIso2 = countryIso2, firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameDiasporaedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameDiasporaedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun diasporaWithHttpInfo(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameDiasporaedOut?> {
        val localVariableConfig = diasporaRequestConfig(countryIso2 = countryIso2, firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameDiasporaedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation diaspora
     *
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun diasporaRequestConfig(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/diaspora/{countryIso2}/{firstName}/{lastName}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchFirstLastNameDiasporaedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun diasporaBatch(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn? = null) : BatchFirstLastNameDiasporaedOut {
        val localVarResponse = diasporaBatchWithHttpInfo(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameDiasporaedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameDiasporaedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun diasporaBatchWithHttpInfo(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : ApiResponse<BatchFirstLastNameDiasporaedOut?> {
        val localVariableConfig = diasporaBatchRequestConfig(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return request<BatchFirstLastNameGeoIn, BatchFirstLastNameDiasporaedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation diasporaBatch
     *
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun diasporaBatchRequestConfig(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : RequestConfig<BatchFirstLastNameGeoIn> {
        val localVariableBody = batchFirstLastNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/diasporaBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param countryIso2 
     * @param personalNameFull 
     * @return PersonalNameDiasporaedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun diasporaFull(countryIso2: kotlin.String, personalNameFull: kotlin.String) : PersonalNameDiasporaedOut {
        val localVarResponse = diasporaFullWithHttpInfo(countryIso2 = countryIso2, personalNameFull = personalNameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameDiasporaedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of a personal name, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param countryIso2 
     * @param personalNameFull 
     * @return ApiResponse<PersonalNameDiasporaedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun diasporaFullWithHttpInfo(countryIso2: kotlin.String, personalNameFull: kotlin.String) : ApiResponse<PersonalNameDiasporaedOut?> {
        val localVariableConfig = diasporaFullRequestConfig(countryIso2 = countryIso2, personalNameFull = personalNameFull)

        return request<Unit, PersonalNameDiasporaedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation diasporaFull
     *
     * @param countryIso2 
     * @param personalNameFull 
     * @return RequestConfig
     */
    fun diasporaFullRequestConfig(countryIso2: kotlin.String, personalNameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/diasporaFull/{countryIso2}/{personalNameFull}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"personalNameFull"+"}", encodeURIComponent(personalNameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchPersonalNameDiasporaedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun diasporaFullBatch(batchPersonalNameGeoIn: BatchPersonalNameGeoIn? = null) : BatchPersonalNameDiasporaedOut {
        val localVarResponse = diasporaFullBatchWithHttpInfo(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameDiasporaedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 20 UNITS PER NAME] Infer the likely ethnicity/diaspora of up to 100 personal names, given a country of residence ISO2 code (ex. US, CA, AU, NZ etc.)
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameDiasporaedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun diasporaFullBatchWithHttpInfo(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : ApiResponse<BatchPersonalNameDiasporaedOut?> {
        val localVariableConfig = diasporaFullBatchRequestConfig(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return request<BatchPersonalNameGeoIn, BatchPersonalNameDiasporaedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation diasporaFullBatch
     *
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun diasporaFullBatchRequestConfig(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : RequestConfig<BatchPersonalNameGeoIn> {
        val localVariableBody = batchPersonalNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/diasporaFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     * 
     * @param firstName 
     * @return FirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gender(firstName: kotlin.String) : FirstLastNameGenderedOut {
        val localVarResponse = genderWithHttpInfo(firstName = firstName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a just a fiven name, assuming default &#39;US&#39; local context. Please use preferably full names and local geographic context for better accuracy.
     * 
     * @param firstName 
     * @return ApiResponse<FirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderWithHttpInfo(firstName: kotlin.String) : ApiResponse<FirstLastNameGenderedOut?> {
        val localVariableConfig = genderRequestConfig(firstName = firstName)

        return request<Unit, FirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gender
     *
     * @param firstName 
     * @return RequestConfig
     */
    fun genderRequestConfig(firstName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/gender/{firstName}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a name.
     * 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun gender1(firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameGenderedOut {
        val localVarResponse = gender1WithHttpInfo(firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a name.
     * 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun gender1WithHttpInfo(firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameGenderedOut?> {
        val localVariableConfig = gender1RequestConfig(firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation gender1
     *
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun gender1RequestConfig(firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/gender/{firstName}/{lastName}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return BatchFirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchFirstLastNameGenderedOut {
        val localVarResponse = genderBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchFirstLastNameGenderedOut?> {
        val localVariableConfig = genderBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchFirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderBatch
     *
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun genderBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a full name, ex. John H. Smith
     * 
     * @param fullName 
     * @return PersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderFull(fullName: kotlin.String) : PersonalNameGenderedOut {
        val localVarResponse = genderFullWithHttpInfo(fullName = fullName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a full name, ex. John H. Smith
     * 
     * @param fullName 
     * @return ApiResponse<PersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderFullWithHttpInfo(fullName: kotlin.String) : ApiResponse<PersonalNameGenderedOut?> {
        val localVariableConfig = genderFullRequestConfig(fullName = fullName)

        return request<Unit, PersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderFull
     *
     * @param fullName 
     * @return RequestConfig
     */
    fun genderFullRequestConfig(fullName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderFull/{fullName}".replace("{"+"fullName"+"}", encodeURIComponent(fullName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderFullBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameGenderedOut {
        val localVarResponse = genderFullBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 full names, detecting automatically the cultural context.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderFullBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameGenderedOut?> {
        val localVariableConfig = genderFullBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderFullBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun genderFullBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     * 
     * @param fullName 
     * @param countryIso2 
     * @return PersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderFullGeo(fullName: kotlin.String, countryIso2: kotlin.String) : PersonalNameGenderedOut {
        val localVarResponse = genderFullGeoWithHttpInfo(fullName = fullName, countryIso2 = countryIso2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a full name, given a local context (ISO2 country code).
     * 
     * @param fullName 
     * @param countryIso2 
     * @return ApiResponse<PersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderFullGeoWithHttpInfo(fullName: kotlin.String, countryIso2: kotlin.String) : ApiResponse<PersonalNameGenderedOut?> {
        val localVariableConfig = genderFullGeoRequestConfig(fullName = fullName, countryIso2 = countryIso2)

        return request<Unit, PersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderFullGeo
     *
     * @param fullName 
     * @param countryIso2 
     * @return RequestConfig
     */
    fun genderFullGeoRequestConfig(fullName: kotlin.String, countryIso2: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderFullGeo/{fullName}/{countryIso2}".replace("{"+"fullName"+"}", encodeURIComponent(fullName.toString())).replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     * 
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @return BatchPersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderFullGeoBatch(batchPersonalNameGeoIn: BatchPersonalNameGeoIn? = null) : BatchPersonalNameGenderedOut {
        val localVarResponse = genderFullGeoBatchWithHttpInfo(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 full names, with a given cultural context (country ISO2 code).
     * 
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @return ApiResponse<BatchPersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderFullGeoBatchWithHttpInfo(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : ApiResponse<BatchPersonalNameGenderedOut?> {
        val localVariableConfig = genderFullGeoBatchRequestConfig(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return request<BatchPersonalNameGeoIn, BatchPersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderFullGeoBatch
     *
     * @param batchPersonalNameGeoIn A list of personal names, with a country ISO2 code (optional)
     * @return RequestConfig
     */
    fun genderFullGeoBatchRequestConfig(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : RequestConfig<BatchPersonalNameGeoIn> {
        val localVariableBody = batchPersonalNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderFullGeoBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     * 
     * @param firstName 
     * @param lastName 
     * @param countryIso2 
     * @return FirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderGeo(firstName: kotlin.String, lastName: kotlin.String, countryIso2: kotlin.String) : FirstLastNameGenderedOut {
        val localVarResponse = genderGeoWithHttpInfo(firstName = firstName, lastName = lastName, countryIso2 = countryIso2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a name, given a local context (ISO2 country code).
     * 
     * @param firstName 
     * @param lastName 
     * @param countryIso2 
     * @return ApiResponse<FirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderGeoWithHttpInfo(firstName: kotlin.String, lastName: kotlin.String, countryIso2: kotlin.String) : ApiResponse<FirstLastNameGenderedOut?> {
        val localVariableConfig = genderGeoRequestConfig(firstName = firstName, lastName = lastName, countryIso2 = countryIso2)

        return request<Unit, FirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderGeo
     *
     * @param firstName 
     * @param lastName 
     * @param countryIso2 
     * @return RequestConfig
     */
    fun genderGeoRequestConfig(firstName: kotlin.String, lastName: kotlin.String, countryIso2: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderGeo/{firstName}/{lastName}/{countryIso2}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())).replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     * 
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @return BatchFirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderGeoBatch(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn? = null) : BatchFirstLastNameGenderedOut {
        val localVarResponse = genderGeoBatchWithHttpInfo(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 names, each given a local context (ISO2 country code).
     * 
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @return ApiResponse<BatchFirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderGeoBatchWithHttpInfo(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : ApiResponse<BatchFirstLastNameGenderedOut?> {
        val localVariableConfig = genderGeoBatchRequestConfig(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return request<BatchFirstLastNameGeoIn, BatchFirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderGeoBatch
     *
     * @param batchFirstLastNameGeoIn A list of names, with country code. (optional)
     * @return RequestConfig
     */
    fun genderGeoBatchRequestConfig(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : RequestConfig<BatchFirstLastNameGeoIn> {
        val localVariableBody = batchFirstLastNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderGeoBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     * 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameOriginedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun origin(firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameOriginedOut {
        val localVarResponse = originWithHttpInfo(firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameOriginedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     * 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameOriginedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun originWithHttpInfo(firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameOriginedOut?> {
        val localVariableConfig = originRequestConfig(firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameOriginedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation origin
     *
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun originRequestConfig(firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/origin/{firstName}/{lastName}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return BatchFirstLastNameOriginedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun originBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchFirstLastNameOriginedOut {
        val localVarResponse = originBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameOriginedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameOriginedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun originBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchFirstLastNameOriginedOut?> {
        val localVariableConfig = originBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchFirstLastNameOriginedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation originBatch
     *
     * @param batchFirstLastNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun originBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/originBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     * 
     * @param personalNameFull 
     * @return PersonalNameOriginedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun originFull(personalNameFull: kotlin.String) : PersonalNameOriginedOut {
        val localVarResponse = originFullWithHttpInfo(personalNameFull = personalNameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameOriginedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of a personal name. Assumes names as they are in the country of origin. For US, CA, AU, NZ and other melting-pots : use &#39;diaspora&#39; instead.
     * 
     * @param personalNameFull 
     * @return ApiResponse<PersonalNameOriginedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun originFullWithHttpInfo(personalNameFull: kotlin.String) : ApiResponse<PersonalNameOriginedOut?> {
        val localVariableConfig = originFullRequestConfig(personalNameFull = personalNameFull)

        return request<Unit, PersonalNameOriginedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation originFull
     *
     * @param personalNameFull 
     * @return RequestConfig
     */
    fun originFullRequestConfig(personalNameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/originFull/{personalNameFull}".replace("{"+"personalNameFull"+"}", encodeURIComponent(personalNameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameOriginedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun originFullBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameOriginedOut {
        val localVarResponse = originFullBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameOriginedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely country of origin of up to 100 names, detecting automatically the cultural context.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameOriginedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun originFullBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameOriginedOut?> {
        val localVariableConfig = originFullBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameOriginedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation originFullBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun originFullBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/originFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. 
     * 
     * @param nameFull 
     * @return PersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseName(nameFull: kotlin.String) : PersonalNameParsedOut {
        val localVarResponse = parseNameWithHttpInfo(nameFull = nameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. 
     * 
     * @param nameFull 
     * @return ApiResponse<PersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseNameWithHttpInfo(nameFull: kotlin.String) : ApiResponse<PersonalNameParsedOut?> {
        val localVariableConfig = parseNameRequestConfig(nameFull = nameFull)

        return request<Unit, PersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseName
     *
     * @param nameFull 
     * @return RequestConfig
     */
    fun parseNameRequestConfig(nameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/parseName/{nameFull}".replace("{"+"nameFull"+"}", encodeURIComponent(nameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseNameBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameParsedOut {
        val localVarResponse = parseNameBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John.
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseNameBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameParsedOut?> {
        val localVariableConfig = parseNameBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseNameBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun parseNameBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/parseNameBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     * 
     * @param nameFull 
     * @param countryIso2 
     * @return PersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseNameGeo(nameFull: kotlin.String, countryIso2: kotlin.String) : PersonalNameParsedOut {
        val localVarResponse = parseNameGeoWithHttpInfo(nameFull = nameFull, countryIso2 = countryIso2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. For better accuracy, provide a geographic context.
     * 
     * @param nameFull 
     * @param countryIso2 
     * @return ApiResponse<PersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseNameGeoWithHttpInfo(nameFull: kotlin.String, countryIso2: kotlin.String) : ApiResponse<PersonalNameParsedOut?> {
        val localVariableConfig = parseNameGeoRequestConfig(nameFull = nameFull, countryIso2 = countryIso2)

        return request<Unit, PersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseNameGeo
     *
     * @param nameFull 
     * @param countryIso2 
     * @return RequestConfig
     */
    fun parseNameGeoRequestConfig(nameFull: kotlin.String, countryIso2: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/parseName/{nameFull}/{countryIso2}".replace("{"+"nameFull"+"}", encodeURIComponent(nameFull.toString())).replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision. 
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseNameGeoBatch(batchPersonalNameGeoIn: BatchPersonalNameGeoIn? = null) : BatchPersonalNameParsedOut {
        val localVarResponse = parseNameGeoBatchWithHttpInfo(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. John Smith or SMITH, John or SMITH; John. Giving a local context improves precision. 
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseNameGeoBatchWithHttpInfo(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : ApiResponse<BatchPersonalNameParsedOut?> {
        val localVariableConfig = parseNameGeoBatchRequestConfig(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return request<BatchPersonalNameGeoIn, BatchPersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseNameGeoBatch
     *
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun parseNameGeoBatchRequestConfig(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : RequestConfig<BatchPersonalNameGeoIn> {
        val localVariableBody = batchPersonalNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/parseNameGeoBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2 
     * @param subDivisionIso31662 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameReligionedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun religion2(countryIso2: kotlin.String, subDivisionIso31662: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameReligionedOut {
        val localVarResponse = religion2WithHttpInfo(countryIso2 = countryIso2, subDivisionIso31662 = subDivisionIso31662, firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameReligionedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal first/last name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2 
     * @param subDivisionIso31662 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameReligionedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun religion2WithHttpInfo(countryIso2: kotlin.String, subDivisionIso31662: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameReligionedOut?> {
        val localVariableConfig = religion2RequestConfig(countryIso2 = countryIso2, subDivisionIso31662 = subDivisionIso31662, firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameReligionedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation religion2
     *
     * @param countryIso2 
     * @param subDivisionIso31662 
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun religion2RequestConfig(countryIso2: kotlin.String, subDivisionIso31662: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/religion/{countryIso2}/{subDivisionIso31662}/{firstName}/{lastName}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"subDivisionIso31662"+"}", encodeURIComponent(subDivisionIso31662.toString())).replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     * 
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @return BatchFirstLastNameReligionedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun religionBatch(batchFirstLastNameGeoSubdivisionIn: BatchFirstLastNameGeoSubdivisionIn? = null) : BatchFirstLastNameReligionedOut {
        val localVarResponse = religionBatchWithHttpInfo(batchFirstLastNameGeoSubdivisionIn = batchFirstLastNameGeoSubdivisionIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameReligionedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal first/last names. NB: only for India as of currently.
     * 
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @return ApiResponse<BatchFirstLastNameReligionedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun religionBatchWithHttpInfo(batchFirstLastNameGeoSubdivisionIn: BatchFirstLastNameGeoSubdivisionIn?) : ApiResponse<BatchFirstLastNameReligionedOut?> {
        val localVariableConfig = religionBatchRequestConfig(batchFirstLastNameGeoSubdivisionIn = batchFirstLastNameGeoSubdivisionIn)

        return request<BatchFirstLastNameGeoSubdivisionIn, BatchFirstLastNameReligionedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation religionBatch
     *
     * @param batchFirstLastNameGeoSubdivisionIn A list of personal first / last names (optional)
     * @return RequestConfig
     */
    fun religionBatchRequestConfig(batchFirstLastNameGeoSubdivisionIn: BatchFirstLastNameGeoSubdivisionIn?) : RequestConfig<BatchFirstLastNameGeoSubdivisionIn> {
        val localVariableBody = batchFirstLastNameGeoSubdivisionIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/religionBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2 
     * @param subDivisionIso31662 
     * @param personalNameFull 
     * @return PersonalNameReligionedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun religionFull(countryIso2: kotlin.String, subDivisionIso31662: kotlin.String, personalNameFull: kotlin.String) : PersonalNameReligionedOut {
        val localVarResponse = religionFullWithHttpInfo(countryIso2 = countryIso2, subDivisionIso31662 = subDivisionIso31662, personalNameFull = personalNameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameReligionedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of a personal full name. NB: only for INDIA (as of current version).
     * 
     * @param countryIso2 
     * @param subDivisionIso31662 
     * @param personalNameFull 
     * @return ApiResponse<PersonalNameReligionedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun religionFullWithHttpInfo(countryIso2: kotlin.String, subDivisionIso31662: kotlin.String, personalNameFull: kotlin.String) : ApiResponse<PersonalNameReligionedOut?> {
        val localVariableConfig = religionFullRequestConfig(countryIso2 = countryIso2, subDivisionIso31662 = subDivisionIso31662, personalNameFull = personalNameFull)

        return request<Unit, PersonalNameReligionedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation religionFull
     *
     * @param countryIso2 
     * @param subDivisionIso31662 
     * @param personalNameFull 
     * @return RequestConfig
     */
    fun religionFullRequestConfig(countryIso2: kotlin.String, subDivisionIso31662: kotlin.String, personalNameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/religionFull/{countryIso2}/{subDivisionIso31662}/{personalNameFull}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"subDivisionIso31662"+"}", encodeURIComponent(subDivisionIso31662.toString())).replace("{"+"personalNameFull"+"}", encodeURIComponent(personalNameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     * 
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @return BatchPersonalNameReligionedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun religionFullBatch(batchPersonalNameGeoSubdivisionIn: BatchPersonalNameGeoSubdivisionIn? = null) : BatchPersonalNameReligionedOut {
        val localVarResponse = religionFullBatchWithHttpInfo(batchPersonalNameGeoSubdivisionIn = batchPersonalNameGeoSubdivisionIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameReligionedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely religion of up to 100 personal full names. NB: only for India as of currently.
     * 
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameReligionedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun religionFullBatchWithHttpInfo(batchPersonalNameGeoSubdivisionIn: BatchPersonalNameGeoSubdivisionIn?) : ApiResponse<BatchPersonalNameReligionedOut?> {
        val localVariableConfig = religionFullBatchRequestConfig(batchPersonalNameGeoSubdivisionIn = batchPersonalNameGeoSubdivisionIn)

        return request<BatchPersonalNameGeoSubdivisionIn, BatchPersonalNameReligionedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation religionFullBatch
     *
     * @param batchPersonalNameGeoSubdivisionIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun religionFullBatchRequestConfig(batchPersonalNameGeoSubdivisionIn: BatchPersonalNameGeoSubdivisionIn?) : RequestConfig<BatchPersonalNameGeoSubdivisionIn> {
        val localVariableBody = batchPersonalNameGeoSubdivisionIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/religionFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameGeoSubclassificationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun subclassification(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameGeoSubclassificationOut {
        val localVarResponse = subclassificationWithHttpInfo(countryIso2 = countryIso2, firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGeoSubclassificationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameGeoSubclassificationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun subclassificationWithHttpInfo(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameGeoSubclassificationOut?> {
        val localVariableConfig = subclassificationRequestConfig(countryIso2 = countryIso2, firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameGeoSubclassificationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation subclassification
     *
     * @param countryIso2 
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun subclassificationRequestConfig(countryIso2: kotlin.String, firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/subclassification/{countryIso2}/{firstName}/{lastName}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchFirstLastNameGeoSubclassificationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun subclassificationBatch(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn? = null) : BatchFirstLastNameGeoSubclassificationOut {
        val localVarResponse = subclassificationBatchWithHttpInfo(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameGeoSubclassificationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameGeoSubclassificationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun subclassificationBatchWithHttpInfo(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : ApiResponse<BatchFirstLastNameGeoSubclassificationOut?> {
        val localVariableConfig = subclassificationBatchRequestConfig(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return request<BatchFirstLastNameGeoIn, BatchFirstLastNameGeoSubclassificationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation subclassificationBatch
     *
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun subclassificationBatchRequestConfig(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : RequestConfig<BatchFirstLastNameGeoIn> {
        val localVariableBody = batchFirstLastNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/subclassificationBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2 
     * @param fullName 
     * @return FirstLastNameGeoSubclassificationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun subclassificationFull(countryIso2: kotlin.String, fullName: kotlin.String) : FirstLastNameGeoSubclassificationOut {
        val localVarResponse = subclassificationFullWithHttpInfo(countryIso2 = countryIso2, fullName = fullName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGeoSubclassificationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a name at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param countryIso2 
     * @param fullName 
     * @return ApiResponse<FirstLastNameGeoSubclassificationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun subclassificationFullWithHttpInfo(countryIso2: kotlin.String, fullName: kotlin.String) : ApiResponse<FirstLastNameGeoSubclassificationOut?> {
        val localVariableConfig = subclassificationFullRequestConfig(countryIso2 = countryIso2, fullName = fullName)

        return request<Unit, FirstLastNameGeoSubclassificationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation subclassificationFull
     *
     * @param countryIso2 
     * @param fullName 
     * @return RequestConfig
     */
    fun subclassificationFullRequestConfig(countryIso2: kotlin.String, fullName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/subclassificationFull/{countryIso2}/{fullName}".replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())).replace("{"+"fullName"+"}", encodeURIComponent(fullName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchPersonalNameGeoSubclassificationOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun subclassificationFullBatch(batchPersonalNameGeoIn: BatchPersonalNameGeoIn? = null) : BatchPersonalNameGeoSubclassificationOut {
        val localVarResponse = subclassificationFullBatchWithHttpInfo(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameGeoSubclassificationOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer the likely origin of a list of up to 100 names at a country subclassification level (state or regeion). Initially, this is only supported for India (ISO2 code &#39;IN&#39;).
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameGeoSubclassificationOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun subclassificationFullBatchWithHttpInfo(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : ApiResponse<BatchPersonalNameGeoSubclassificationOut?> {
        val localVariableConfig = subclassificationFullBatchRequestConfig(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return request<BatchPersonalNameGeoIn, BatchPersonalNameGeoSubclassificationOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation subclassificationFullBatch
     *
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun subclassificationFullBatchRequestConfig(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : RequestConfig<BatchPersonalNameGeoIn> {
        val localVariableBody = batchPersonalNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/subclassificationFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName 
     * @param lastName 
     * @return FirstLastNameUSRaceEthnicityOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usRaceEthnicity(firstName: kotlin.String, lastName: kotlin.String) : FirstLastNameUSRaceEthnicityOut {
        val localVarResponse = usRaceEthnicityWithHttpInfo(firstName = firstName, lastName = lastName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameUSRaceEthnicityOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName 
     * @param lastName 
     * @return ApiResponse<FirstLastNameUSRaceEthnicityOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usRaceEthnicityWithHttpInfo(firstName: kotlin.String, lastName: kotlin.String) : ApiResponse<FirstLastNameUSRaceEthnicityOut?> {
        val localVariableConfig = usRaceEthnicityRequestConfig(firstName = firstName, lastName = lastName)

        return request<Unit, FirstLastNameUSRaceEthnicityOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usRaceEthnicity
     *
     * @param firstName 
     * @param lastName 
     * @return RequestConfig
     */
    fun usRaceEthnicityRequestConfig(firstName: kotlin.String, lastName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/usRaceEthnicity/{firstName}/{lastName}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return BatchFirstLastNameUSRaceEthnicityOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usRaceEthnicityBatch(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn? = null) : BatchFirstLastNameUSRaceEthnicityOut {
        val localVarResponse = usRaceEthnicityBatchWithHttpInfo(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameUSRaceEthnicityOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameUSRaceEthnicityOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usRaceEthnicityBatchWithHttpInfo(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : ApiResponse<BatchFirstLastNameUSRaceEthnicityOut?> {
        val localVariableConfig = usRaceEthnicityBatchRequestConfig(batchFirstLastNameGeoIn = batchFirstLastNameGeoIn)

        return request<BatchFirstLastNameGeoIn, BatchFirstLastNameUSRaceEthnicityOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usRaceEthnicityBatch
     *
     * @param batchFirstLastNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun usRaceEthnicityBatchRequestConfig(batchFirstLastNameGeoIn: BatchFirstLastNameGeoIn?) : RequestConfig<BatchFirstLastNameGeoIn> {
        val localVariableBody = batchFirstLastNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/usRaceEthnicityBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param personalNameFull 
     * @return PersonalNameUSRaceEthnicityOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usRaceEthnicityFull(personalNameFull: kotlin.String) : PersonalNameUSRaceEthnicityOut {
        val localVarResponse = usRaceEthnicityFullWithHttpInfo(personalNameFull = personalNameFull)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameUSRaceEthnicityOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param personalNameFull 
     * @return ApiResponse<PersonalNameUSRaceEthnicityOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usRaceEthnicityFullWithHttpInfo(personalNameFull: kotlin.String) : ApiResponse<PersonalNameUSRaceEthnicityOut?> {
        val localVariableConfig = usRaceEthnicityFullRequestConfig(personalNameFull = personalNameFull)

        return request<Unit, PersonalNameUSRaceEthnicityOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usRaceEthnicityFull
     *
     * @param personalNameFull 
     * @return RequestConfig
     */
    fun usRaceEthnicityFullRequestConfig(personalNameFull: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/usRaceEthnicityFull/{personalNameFull}".replace("{"+"personalNameFull"+"}", encodeURIComponent(personalNameFull.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return BatchPersonalNameUSRaceEthnicityOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usRaceEthnicityFullBatch(batchPersonalNameGeoIn: BatchPersonalNameGeoIn? = null) : BatchPersonalNameUSRaceEthnicityOut {
        val localVarResponse = usRaceEthnicityFullBatchWithHttpInfo(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameUSRaceEthnicityOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameUSRaceEthnicityOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usRaceEthnicityFullBatchWithHttpInfo(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : ApiResponse<BatchPersonalNameUSRaceEthnicityOut?> {
        val localVariableConfig = usRaceEthnicityFullBatchRequestConfig(batchPersonalNameGeoIn = batchPersonalNameGeoIn)

        return request<BatchPersonalNameGeoIn, BatchPersonalNameUSRaceEthnicityOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usRaceEthnicityFullBatch
     *
     * @param batchPersonalNameGeoIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun usRaceEthnicityFullBatchRequestConfig(batchPersonalNameGeoIn: BatchPersonalNameGeoIn?) : RequestConfig<BatchPersonalNameGeoIn> {
        val localVariableBody = batchPersonalNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/usRaceEthnicityFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName 
     * @param lastName 
     * @param zip5Code 
     * @return FirstLastNameUSRaceEthnicityOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usRaceEthnicityZIP5(firstName: kotlin.String, lastName: kotlin.String, zip5Code: kotlin.String) : FirstLastNameUSRaceEthnicityOut {
        val localVarResponse = usRaceEthnicityZIP5WithHttpInfo(firstName = firstName, lastName = lastName, zip5Code = zip5Code)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameUSRaceEthnicityOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer a US resident&#39;s likely race/ethnicity according to US Census taxonomy, using (optional) ZIP5 code info. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param firstName 
     * @param lastName 
     * @param zip5Code 
     * @return ApiResponse<FirstLastNameUSRaceEthnicityOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usRaceEthnicityZIP5WithHttpInfo(firstName: kotlin.String, lastName: kotlin.String, zip5Code: kotlin.String) : ApiResponse<FirstLastNameUSRaceEthnicityOut?> {
        val localVariableConfig = usRaceEthnicityZIP5RequestConfig(firstName = firstName, lastName = lastName, zip5Code = zip5Code)

        return request<Unit, FirstLastNameUSRaceEthnicityOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usRaceEthnicityZIP5
     *
     * @param firstName 
     * @param lastName 
     * @param zip5Code 
     * @return RequestConfig
     */
    fun usRaceEthnicityZIP5RequestConfig(firstName: kotlin.String, lastName: kotlin.String, zip5Code: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/usRaceEthnicityZIP5/{firstName}/{lastName}/{zip5Code}".replace("{"+"firstName"+"}", encodeURIComponent(firstName.toString())).replace("{"+"lastName"+"}", encodeURIComponent(lastName.toString())).replace("{"+"zip5Code"+"}", encodeURIComponent(zip5Code.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @return BatchFirstLastNameUSRaceEthnicityOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun usZipRaceEthnicityBatch(batchFirstLastNameGeoZippedIn: BatchFirstLastNameGeoZippedIn? = null) : BatchFirstLastNameUSRaceEthnicityOut {
        val localVarResponse = usZipRaceEthnicityBatchWithHttpInfo(batchFirstLastNameGeoZippedIn = batchFirstLastNameGeoZippedIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameUSRaceEthnicityOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [USES 10 UNITS PER NAME] Infer up-to 100 US resident&#39;s likely race/ethnicity according to US Census taxonomy, with (optional) ZIP code. Output is W_NL (white, non latino), HL (hispano latino),  A (asian, non latino), B_NL (black, non latino). Optionally add header X-OPTION-USRACEETHNICITY-TAXONOMY: USRACEETHNICITY-6CLASSES for two additional classes, AI_AN (American Indian or Alaskan Native) and PI (Pacific Islander).
     * 
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @return ApiResponse<BatchFirstLastNameUSRaceEthnicityOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun usZipRaceEthnicityBatchWithHttpInfo(batchFirstLastNameGeoZippedIn: BatchFirstLastNameGeoZippedIn?) : ApiResponse<BatchFirstLastNameUSRaceEthnicityOut?> {
        val localVariableConfig = usZipRaceEthnicityBatchRequestConfig(batchFirstLastNameGeoZippedIn = batchFirstLastNameGeoZippedIn)

        return request<BatchFirstLastNameGeoZippedIn, BatchFirstLastNameUSRaceEthnicityOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation usZipRaceEthnicityBatch
     *
     * @param batchFirstLastNameGeoZippedIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun usZipRaceEthnicityBatchRequestConfig(batchFirstLastNameGeoZippedIn: BatchFirstLastNameGeoZippedIn?) : RequestConfig<BatchFirstLastNameGeoZippedIn> {
        val localVariableBody = batchFirstLastNameGeoZippedIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/usZipRaceEthnicityBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
