/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package app.namsor.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import app.namsor.client.models.BatchFirstLastNameGenderIn
import app.namsor.client.models.BatchFirstLastNameGenderedOut
import app.namsor.client.models.BatchFirstLastNameIn
import app.namsor.client.models.BatchMatchPersonalFirstLastNameIn
import app.namsor.client.models.BatchNameMatchCandidatesOut
import app.namsor.client.models.BatchNameMatchedOut
import app.namsor.client.models.BatchPersonalNameGenderedOut
import app.namsor.client.models.BatchPersonalNameIn
import app.namsor.client.models.BatchPersonalNameParsedOut
import app.namsor.client.models.FirstLastNameGenderedOut
import app.namsor.client.models.NameMatchCandidatesOut
import app.namsor.client.models.NameMatchedOut
import app.namsor.client.models.PersonalNameGenderedOut
import app.namsor.client.models.PersonalNameParsedOut

import com.squareup.moshi.Json

import app.namsor.client.infrastructure.ApiClient
import app.namsor.client.infrastructure.ApiResponse
import app.namsor.client.infrastructure.ClientException
import app.namsor.client.infrastructure.ClientError
import app.namsor.client.infrastructure.ServerException
import app.namsor.client.infrastructure.ServerError
import app.namsor.client.infrastructure.MultiValueMap
import app.namsor.client.infrastructure.PartConfig
import app.namsor.client.infrastructure.RequestConfig
import app.namsor.client.infrastructure.RequestMethod
import app.namsor.client.infrastructure.ResponseType
import app.namsor.client.infrastructure.Success
import app.namsor.client.infrastructure.toMultiValue

class ChineseApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://v2.namsor.com/NamSorAPIv2")
        }
    }

    /**
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @return NameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chineseNameCandidates(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String) : NameMatchCandidatesOut {
        val localVarResponse = chineseNameCandidatesWithHttpInfo(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @return ApiResponse<NameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chineseNameCandidatesWithHttpInfo(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String) : ApiResponse<NameMatchCandidatesOut?> {
        val localVariableConfig = chineseNameCandidatesRequestConfig(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin)

        return request<Unit, NameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chineseNameCandidates
     *
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @return RequestConfig
     */
    fun chineseNameCandidatesRequestConfig(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/chineseNameCandidates/{chineseSurnameLatin}/{chineseGivenNameLatin}".replace("{"+"chineseSurnameLatin"+"}", encodeURIComponent(chineseSurnameLatin.toString())).replace("{"+"chineseGivenNameLatin"+"}", encodeURIComponent(chineseGivenNameLatin.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     * 
     * @param batchFirstLastNameIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return BatchNameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chineseNameCandidatesBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchNameMatchCandidatesOut {
        val localVarResponse = chineseNameCandidatesBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     * 
     * @param batchFirstLastNameIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return ApiResponse<BatchNameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chineseNameCandidatesBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchNameMatchCandidatesOut?> {
        val localVariableConfig = chineseNameCandidatesBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchNameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chineseNameCandidatesBatch
     *
     * @param batchFirstLastNameIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return RequestConfig
     */
    fun chineseNameCandidatesBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/chineseNameCandidatesBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname) ex. Wang Xiaoming.
     * 
     * @param batchFirstLastNameGenderIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return BatchNameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chineseNameCandidatesGenderBatch(batchFirstLastNameGenderIn: BatchFirstLastNameGenderIn? = null) : BatchNameMatchCandidatesOut {
        val localVarResponse = chineseNameCandidatesGenderBatchWithHttpInfo(batchFirstLastNameGenderIn = batchFirstLastNameGenderIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname) ex. Wang Xiaoming.
     * 
     * @param batchFirstLastNameGenderIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return ApiResponse<BatchNameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chineseNameCandidatesGenderBatchWithHttpInfo(batchFirstLastNameGenderIn: BatchFirstLastNameGenderIn?) : ApiResponse<BatchNameMatchCandidatesOut?> {
        val localVariableConfig = chineseNameCandidatesGenderBatchRequestConfig(batchFirstLastNameGenderIn = batchFirstLastNameGenderIn)

        return request<BatchFirstLastNameGenderIn, BatchNameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chineseNameCandidatesGenderBatch
     *
     * @param batchFirstLastNameGenderIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return RequestConfig
     */
    fun chineseNameCandidatesGenderBatchRequestConfig(batchFirstLastNameGenderIn: BatchFirstLastNameGenderIn?) : RequestConfig<BatchFirstLastNameGenderIn> {
        val localVariableBody = batchFirstLastNameGenderIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/chineseNameCandidatesGenderBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming - having a known gender (&#39;male&#39; or &#39;female&#39;)
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @param knownGender 
     * @return NameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chineseNameGenderCandidates(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String, knownGender: kotlin.String) : NameMatchCandidatesOut {
        val localVarResponse = chineseNameGenderCandidatesWithHttpInfo(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin, knownGender = knownGender)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify Chinese name candidates, based on the romanized name ex. Wang Xiaoming - having a known gender (&#39;male&#39; or &#39;female&#39;)
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @param knownGender 
     * @return ApiResponse<NameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chineseNameGenderCandidatesWithHttpInfo(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String, knownGender: kotlin.String) : ApiResponse<NameMatchCandidatesOut?> {
        val localVariableConfig = chineseNameGenderCandidatesRequestConfig(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin, knownGender = knownGender)

        return request<Unit, NameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chineseNameGenderCandidates
     *
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @param knownGender 
     * @return RequestConfig
     */
    fun chineseNameGenderCandidatesRequestConfig(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String, knownGender: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/chineseNameGenderCandidates/{chineseSurnameLatin}/{chineseGivenNameLatin}/{knownGender}".replace("{"+"chineseSurnameLatin"+"}", encodeURIComponent(chineseSurnameLatin.toString())).replace("{"+"chineseGivenNameLatin"+"}", encodeURIComponent(chineseGivenNameLatin.toString())).replace("{"+"knownGender"+"}", encodeURIComponent(knownGender.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Return a score for matching Chinese name ex. 王晓明 with a romanized name ex. Wang Xiaoming
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @param chineseName 
     * @return NameMatchedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chineseNameMatch(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String, chineseName: kotlin.String) : NameMatchedOut {
        val localVarResponse = chineseNameMatchWithHttpInfo(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin, chineseName = chineseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Return a score for matching Chinese name ex. 王晓明 with a romanized name ex. Wang Xiaoming
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @param chineseName 
     * @return ApiResponse<NameMatchedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chineseNameMatchWithHttpInfo(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String, chineseName: kotlin.String) : ApiResponse<NameMatchedOut?> {
        val localVariableConfig = chineseNameMatchRequestConfig(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin, chineseName = chineseName)

        return request<Unit, NameMatchedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chineseNameMatch
     *
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @param chineseName 
     * @return RequestConfig
     */
    fun chineseNameMatchRequestConfig(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String, chineseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/chineseNameMatch/{chineseSurnameLatin}/{chineseGivenNameLatin}/{chineseName}".replace("{"+"chineseSurnameLatin"+"}", encodeURIComponent(chineseSurnameLatin.toString())).replace("{"+"chineseGivenNameLatin"+"}", encodeURIComponent(chineseGivenNameLatin.toString())).replace("{"+"chineseName"+"}", encodeURIComponent(chineseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     * 
     * @param batchMatchPersonalFirstLastNameIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return BatchNameMatchedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun chineseNameMatchBatch(batchMatchPersonalFirstLastNameIn: BatchMatchPersonalFirstLastNameIn? = null) : BatchNameMatchedOut {
        val localVarResponse = chineseNameMatchBatchWithHttpInfo(batchMatchPersonalFirstLastNameIn = batchMatchPersonalFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify Chinese name candidates, based on the romanized name (firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname), ex. Wang Xiaoming
     * 
     * @param batchMatchPersonalFirstLastNameIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return ApiResponse<BatchNameMatchedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun chineseNameMatchBatchWithHttpInfo(batchMatchPersonalFirstLastNameIn: BatchMatchPersonalFirstLastNameIn?) : ApiResponse<BatchNameMatchedOut?> {
        val localVariableConfig = chineseNameMatchBatchRequestConfig(batchMatchPersonalFirstLastNameIn = batchMatchPersonalFirstLastNameIn)

        return request<BatchMatchPersonalFirstLastNameIn, BatchNameMatchedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation chineseNameMatchBatch
     *
     * @param batchMatchPersonalFirstLastNameIn A list of personal Chinese names in LATIN, firstName &#x3D; chineseGivenName; lastName&#x3D;chineseSurname (optional)
     * @return RequestConfig
     */
    fun chineseNameMatchBatchRequestConfig(batchMatchPersonalFirstLastNameIn: BatchMatchPersonalFirstLastNameIn?) : RequestConfig<BatchMatchPersonalFirstLastNameIn> {
        val localVariableBody = batchMatchPersonalFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/chineseNameMatchBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a Chinese full name ex. 王晓明
     * 
     * @param chineseName 
     * @return PersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderChineseName(chineseName: kotlin.String) : PersonalNameGenderedOut {
        val localVarResponse = genderChineseNameWithHttpInfo(chineseName = chineseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a Chinese full name ex. 王晓明
     * 
     * @param chineseName 
     * @return ApiResponse<PersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderChineseNameWithHttpInfo(chineseName: kotlin.String) : ApiResponse<PersonalNameGenderedOut?> {
        val localVariableConfig = genderChineseNameRequestConfig(chineseName = chineseName)

        return request<Unit, PersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderChineseName
     *
     * @param chineseName 
     * @return RequestConfig
     */
    fun genderChineseNameRequestConfig(chineseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderChineseName/{chineseName}".replace("{"+"chineseName"+"}", encodeURIComponent(chineseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 full names ex. 王晓明
     * 
     * @param batchPersonalNameIn A list of personal names, with a country ISO2 code (optional)
     * @return BatchPersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderChineseNameBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameGenderedOut {
        val localVarResponse = genderChineseNameBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 full names ex. 王晓明
     * 
     * @param batchPersonalNameIn A list of personal names, with a country ISO2 code (optional)
     * @return ApiResponse<BatchPersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderChineseNameBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameGenderedOut?> {
        val localVariableConfig = genderChineseNameBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderChineseNameBatch
     *
     * @param batchPersonalNameIn A list of personal names, with a country ISO2 code (optional)
     * @return RequestConfig
     */
    fun genderChineseNameBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderChineseNameBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a Chinese name in LATIN (Pinyin).
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @return FirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderChineseNamePinyin(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String) : FirstLastNameGenderedOut {
        val localVarResponse = genderChineseNamePinyinWithHttpInfo(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a Chinese name in LATIN (Pinyin).
     * 
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @return ApiResponse<FirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderChineseNamePinyinWithHttpInfo(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String) : ApiResponse<FirstLastNameGenderedOut?> {
        val localVariableConfig = genderChineseNamePinyinRequestConfig(chineseSurnameLatin = chineseSurnameLatin, chineseGivenNameLatin = chineseGivenNameLatin)

        return request<Unit, FirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderChineseNamePinyin
     *
     * @param chineseSurnameLatin 
     * @param chineseGivenNameLatin 
     * @return RequestConfig
     */
    fun genderChineseNamePinyinRequestConfig(chineseSurnameLatin: kotlin.String, chineseGivenNameLatin: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderChineseNamePinyin/{chineseSurnameLatin}/{chineseGivenNameLatin}".replace("{"+"chineseSurnameLatin"+"}", encodeURIComponent(chineseSurnameLatin.toString())).replace("{"+"chineseGivenNameLatin"+"}", encodeURIComponent(chineseGivenNameLatin.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 Chinese names in LATIN (Pinyin).
     * 
     * @param batchFirstLastNameIn A list of names, with country code. (optional)
     * @return BatchFirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderChineseNamePinyinBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchFirstLastNameGenderedOut {
        val localVarResponse = genderChineseNamePinyinBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 Chinese names in LATIN (Pinyin).
     * 
     * @param batchFirstLastNameIn A list of names, with country code. (optional)
     * @return ApiResponse<BatchFirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderChineseNamePinyinBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchFirstLastNameGenderedOut?> {
        val localVariableConfig = genderChineseNamePinyinBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchFirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderChineseNamePinyinBatch
     *
     * @param batchFirstLastNameIn A list of names, with country code. (optional)
     * @return RequestConfig
     */
    fun genderChineseNamePinyinBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderChineseNamePinyinBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name)
     * 
     * @param chineseName 
     * @return PersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseChineseName(chineseName: kotlin.String) : PersonalNameParsedOut {
        val localVarResponse = parseChineseNameWithHttpInfo(chineseName = chineseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name)
     * 
     * @param chineseName 
     * @return ApiResponse<PersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseChineseNameWithHttpInfo(chineseName: kotlin.String) : ApiResponse<PersonalNameParsedOut?> {
        val localVariableConfig = parseChineseNameRequestConfig(chineseName = chineseName)

        return request<Unit, PersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseChineseName
     *
     * @param chineseName 
     * @return RequestConfig
     */
    fun parseChineseNameRequestConfig(chineseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/parseChineseName/{chineseName}".replace("{"+"chineseName"+"}", encodeURIComponent(chineseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name).
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseChineseNameBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameParsedOut {
        val localVarResponse = parseChineseNameBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 王晓明 -&gt; 王(surname) 晓明(given name).
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseChineseNameBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameParsedOut?> {
        val localVariableConfig = parseChineseNameBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseChineseNameBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun parseChineseNameBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/parseChineseNameBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Romanize the Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name)
     * 
     * @param chineseName 
     * @return PersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun pinyinChineseName(chineseName: kotlin.String) : PersonalNameParsedOut {
        val localVarResponse = pinyinChineseNameWithHttpInfo(chineseName = chineseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Romanize the Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name)
     * 
     * @param chineseName 
     * @return ApiResponse<PersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun pinyinChineseNameWithHttpInfo(chineseName: kotlin.String) : ApiResponse<PersonalNameParsedOut?> {
        val localVariableConfig = pinyinChineseNameRequestConfig(chineseName = chineseName)

        return request<Unit, PersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pinyinChineseName
     *
     * @param chineseName 
     * @return RequestConfig
     */
    fun pinyinChineseNameRequestConfig(chineseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/pinyinChineseName/{chineseName}".replace("{"+"chineseName"+"}", encodeURIComponent(chineseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Romanize a list of Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name).
     * 
     * @param batchPersonalNameIn A list of Chinese names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun pinyinChineseNameBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameParsedOut {
        val localVarResponse = pinyinChineseNameBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Romanize a list of Chinese name to Pinyin, ex. 王晓明 -&gt; Wang (surname) Xiaoming (given name).
     * 
     * @param batchPersonalNameIn A list of Chinese names (optional)
     * @return ApiResponse<BatchPersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun pinyinChineseNameBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameParsedOut?> {
        val localVariableConfig = pinyinChineseNameBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation pinyinChineseNameBatch
     *
     * @param batchPersonalNameIn A list of Chinese names (optional)
     * @return RequestConfig
     */
    fun pinyinChineseNameBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/pinyinChineseNameBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
