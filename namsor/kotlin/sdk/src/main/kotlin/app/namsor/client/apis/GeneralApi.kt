/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package app.namsor.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import app.namsor.client.models.BatchNameGeoIn
import app.namsor.client.models.BatchNameIn
import app.namsor.client.models.BatchProperNounCategorizedOut
import app.namsor.client.models.ProperNounCategorizedOut

import com.squareup.moshi.Json

import app.namsor.client.infrastructure.ApiClient
import app.namsor.client.infrastructure.ApiResponse
import app.namsor.client.infrastructure.ClientException
import app.namsor.client.infrastructure.ClientError
import app.namsor.client.infrastructure.ServerException
import app.namsor.client.infrastructure.ServerError
import app.namsor.client.infrastructure.MultiValueMap
import app.namsor.client.infrastructure.PartConfig
import app.namsor.client.infrastructure.RequestConfig
import app.namsor.client.infrastructure.RequestMethod
import app.namsor.client.infrastructure.ResponseType
import app.namsor.client.infrastructure.Success
import app.namsor.client.infrastructure.toMultiValue

class GeneralApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://v2.namsor.com/NamSorAPIv2")
        }
    }

    /**
     * Infer the likely type of a proper noun (personal name, brand name, place name etc.)
     * 
     * @param properNoun 
     * @return ProperNounCategorizedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun nameType(properNoun: kotlin.String) : ProperNounCategorizedOut {
        val localVarResponse = nameTypeWithHttpInfo(properNoun = properNoun)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProperNounCategorizedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely type of a proper noun (personal name, brand name, place name etc.)
     * 
     * @param properNoun 
     * @return ApiResponse<ProperNounCategorizedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun nameTypeWithHttpInfo(properNoun: kotlin.String) : ApiResponse<ProperNounCategorizedOut?> {
        val localVariableConfig = nameTypeRequestConfig(properNoun = properNoun)

        return request<Unit, ProperNounCategorizedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation nameType
     *
     * @param properNoun 
     * @return RequestConfig
     */
    fun nameTypeRequestConfig(properNoun: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/nameType/{properNoun}".replace("{"+"properNoun"+"}", encodeURIComponent(properNoun.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely common type of up to 100 proper nouns (personal name, brand name, place name etc.)
     * 
     * @param batchNameIn A list of proper names (optional)
     * @return BatchProperNounCategorizedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun nameTypeBatch(batchNameIn: BatchNameIn? = null) : BatchProperNounCategorizedOut {
        val localVarResponse = nameTypeBatchWithHttpInfo(batchNameIn = batchNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchProperNounCategorizedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely common type of up to 100 proper nouns (personal name, brand name, place name etc.)
     * 
     * @param batchNameIn A list of proper names (optional)
     * @return ApiResponse<BatchProperNounCategorizedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun nameTypeBatchWithHttpInfo(batchNameIn: BatchNameIn?) : ApiResponse<BatchProperNounCategorizedOut?> {
        val localVariableConfig = nameTypeBatchRequestConfig(batchNameIn = batchNameIn)

        return request<BatchNameIn, BatchProperNounCategorizedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation nameTypeBatch
     *
     * @param batchNameIn A list of proper names (optional)
     * @return RequestConfig
     */
    fun nameTypeBatchRequestConfig(batchNameIn: BatchNameIn?) : RequestConfig<BatchNameIn> {
        val localVariableBody = batchNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/nameTypeBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely type of a proper noun (personal name, brand name, place name etc.)
     * 
     * @param properNoun 
     * @param countryIso2 
     * @return ProperNounCategorizedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun nameTypeGeo(properNoun: kotlin.String, countryIso2: kotlin.String) : ProperNounCategorizedOut {
        val localVarResponse = nameTypeGeoWithHttpInfo(properNoun = properNoun, countryIso2 = countryIso2)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProperNounCategorizedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely type of a proper noun (personal name, brand name, place name etc.)
     * 
     * @param properNoun 
     * @param countryIso2 
     * @return ApiResponse<ProperNounCategorizedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun nameTypeGeoWithHttpInfo(properNoun: kotlin.String, countryIso2: kotlin.String) : ApiResponse<ProperNounCategorizedOut?> {
        val localVariableConfig = nameTypeGeoRequestConfig(properNoun = properNoun, countryIso2 = countryIso2)

        return request<Unit, ProperNounCategorizedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation nameTypeGeo
     *
     * @param properNoun 
     * @param countryIso2 
     * @return RequestConfig
     */
    fun nameTypeGeoRequestConfig(properNoun: kotlin.String, countryIso2: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/nameTypeGeo/{properNoun}/{countryIso2}".replace("{"+"properNoun"+"}", encodeURIComponent(properNoun.toString())).replace("{"+"countryIso2"+"}", encodeURIComponent(countryIso2.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely common type of up to 100 proper nouns (personal name, brand name, place name etc.)
     * 
     * @param batchNameGeoIn A list of proper names (optional)
     * @return BatchProperNounCategorizedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun nameTypeGeoBatch(batchNameGeoIn: BatchNameGeoIn? = null) : BatchProperNounCategorizedOut {
        val localVarResponse = nameTypeGeoBatchWithHttpInfo(batchNameGeoIn = batchNameGeoIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchProperNounCategorizedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely common type of up to 100 proper nouns (personal name, brand name, place name etc.)
     * 
     * @param batchNameGeoIn A list of proper names (optional)
     * @return ApiResponse<BatchProperNounCategorizedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun nameTypeGeoBatchWithHttpInfo(batchNameGeoIn: BatchNameGeoIn?) : ApiResponse<BatchProperNounCategorizedOut?> {
        val localVariableConfig = nameTypeGeoBatchRequestConfig(batchNameGeoIn = batchNameGeoIn)

        return request<BatchNameGeoIn, BatchProperNounCategorizedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation nameTypeGeoBatch
     *
     * @param batchNameGeoIn A list of proper names (optional)
     * @return RequestConfig
     */
    fun nameTypeGeoBatchRequestConfig(batchNameGeoIn: BatchNameGeoIn?) : RequestConfig<BatchNameGeoIn> {
        val localVariableBody = batchNameGeoIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/nameTypeGeoBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
