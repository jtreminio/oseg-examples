/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package app.namsor.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import app.namsor.client.models.BatchFirstLastNameGenderIn
import app.namsor.client.models.BatchFirstLastNameGenderedOut
import app.namsor.client.models.BatchFirstLastNameIn
import app.namsor.client.models.BatchMatchPersonalFirstLastNameIn
import app.namsor.client.models.BatchNameMatchCandidatesOut
import app.namsor.client.models.BatchNameMatchedOut
import app.namsor.client.models.BatchPersonalNameGenderedOut
import app.namsor.client.models.BatchPersonalNameIn
import app.namsor.client.models.BatchPersonalNameParsedOut
import app.namsor.client.models.FeedbackLoopOut
import app.namsor.client.models.FirstLastNameGenderedOut
import app.namsor.client.models.NameMatchCandidatesOut
import app.namsor.client.models.NameMatchedOut
import app.namsor.client.models.PersonalNameGenderedOut
import app.namsor.client.models.PersonalNameParsedOut

import com.squareup.moshi.Json

import app.namsor.client.infrastructure.ApiClient
import app.namsor.client.infrastructure.ApiResponse
import app.namsor.client.infrastructure.ClientException
import app.namsor.client.infrastructure.ClientError
import app.namsor.client.infrastructure.ServerException
import app.namsor.client.infrastructure.ServerError
import app.namsor.client.infrastructure.MultiValueMap
import app.namsor.client.infrastructure.PartConfig
import app.namsor.client.infrastructure.RequestConfig
import app.namsor.client.infrastructure.RequestMethod
import app.namsor.client.infrastructure.ResponseType
import app.namsor.client.infrastructure.Success
import app.namsor.client.infrastructure.toMultiValue

class JapaneseApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://v2.namsor.com/NamSorAPIv2")
        }
    }

    /**
     * Infer the likely gender of a Japanese full name ex. 王晓明
     * 
     * @param japaneseName 
     * @return PersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderJapaneseNameFull(japaneseName: kotlin.String) : PersonalNameGenderedOut {
        val localVarResponse = genderJapaneseNameFullWithHttpInfo(japaneseName = japaneseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a Japanese full name ex. 王晓明
     * 
     * @param japaneseName 
     * @return ApiResponse<PersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderJapaneseNameFullWithHttpInfo(japaneseName: kotlin.String) : ApiResponse<PersonalNameGenderedOut?> {
        val localVariableConfig = genderJapaneseNameFullRequestConfig(japaneseName = japaneseName)

        return request<Unit, PersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderJapaneseNameFull
     *
     * @param japaneseName 
     * @return RequestConfig
     */
    fun genderJapaneseNameFullRequestConfig(japaneseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderJapaneseNameFull/{japaneseName}".replace("{"+"japaneseName"+"}", encodeURIComponent(japaneseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 full names
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderJapaneseNameFullBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameGenderedOut {
        val localVarResponse = genderJapaneseNameFullBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 full names
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderJapaneseNameFullBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameGenderedOut?> {
        val localVariableConfig = genderJapaneseNameFullBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderJapaneseNameFullBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun genderJapaneseNameFullBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderJapaneseNameFullBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     * 
     * @param japaneseSurname 
     * @param japaneseGivenName 
     * @return FirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderJapaneseNamePinyin(japaneseSurname: kotlin.String, japaneseGivenName: kotlin.String) : FirstLastNameGenderedOut {
        val localVarResponse = genderJapaneseNamePinyinWithHttpInfo(japaneseSurname = japaneseSurname, japaneseGivenName = japaneseGivenName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of a Japanese name in LATIN (Pinyin).
     * 
     * @param japaneseSurname 
     * @param japaneseGivenName 
     * @return ApiResponse<FirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderJapaneseNamePinyinWithHttpInfo(japaneseSurname: kotlin.String, japaneseGivenName: kotlin.String) : ApiResponse<FirstLastNameGenderedOut?> {
        val localVariableConfig = genderJapaneseNamePinyinRequestConfig(japaneseSurname = japaneseSurname, japaneseGivenName = japaneseGivenName)

        return request<Unit, FirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderJapaneseNamePinyin
     *
     * @param japaneseSurname 
     * @param japaneseGivenName 
     * @return RequestConfig
     */
    fun genderJapaneseNamePinyinRequestConfig(japaneseSurname: kotlin.String, japaneseGivenName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/genderJapaneseName/{japaneseSurname}/{japaneseGivenName}".replace("{"+"japaneseSurname"+"}", encodeURIComponent(japaneseSurname.toString())).replace("{"+"japaneseGivenName"+"}", encodeURIComponent(japaneseGivenName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     * 
     * @param batchFirstLastNameIn A list of names, with country code. (optional)
     * @return BatchFirstLastNameGenderedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun genderJapaneseNamePinyinBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchFirstLastNameGenderedOut {
        val localVarResponse = genderJapaneseNamePinyinBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchFirstLastNameGenderedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely gender of up to 100 Japanese names in LATIN (Pinyin).
     * 
     * @param batchFirstLastNameIn A list of names, with country code. (optional)
     * @return ApiResponse<BatchFirstLastNameGenderedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun genderJapaneseNamePinyinBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchFirstLastNameGenderedOut?> {
        val localVariableConfig = genderJapaneseNamePinyinBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchFirstLastNameGenderedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation genderJapaneseNamePinyinBatch
     *
     * @param batchFirstLastNameIn A list of names, with country code. (optional)
     * @return RequestConfig
     */
    fun genderJapaneseNamePinyinBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/genderJapaneseNameBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
     * 
     * @param batchFirstLastNameGenderIn A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @return BatchNameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameGenderKanjiCandidatesBatch(batchFirstLastNameGenderIn: BatchFirstLastNameGenderIn? = null) : BatchNameMatchCandidatesOut {
        val localVarResponse = japaneseNameGenderKanjiCandidatesBatchWithHttpInfo(batchFirstLastNameGenderIn = batchFirstLastNameGenderIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname) with KNOWN gender, ex. Yamamoto Sanae
     * 
     * @param batchFirstLastNameGenderIn A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @return ApiResponse<BatchNameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameGenderKanjiCandidatesBatchWithHttpInfo(batchFirstLastNameGenderIn: BatchFirstLastNameGenderIn?) : ApiResponse<BatchNameMatchCandidatesOut?> {
        val localVariableConfig = japaneseNameGenderKanjiCandidatesBatchRequestConfig(batchFirstLastNameGenderIn = batchFirstLastNameGenderIn)

        return request<BatchFirstLastNameGenderIn, BatchNameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameGenderKanjiCandidatesBatch
     *
     * @param batchFirstLastNameGenderIn A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname and known gender (optional)
     * @return RequestConfig
     */
    fun japaneseNameGenderKanjiCandidatesBatchRequestConfig(batchFirstLastNameGenderIn: BatchFirstLastNameGenderIn?) : RequestConfig<BatchFirstLastNameGenderIn> {
        val localVariableBody = batchFirstLastNameGenderIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/japaneseNameGenderKanjiCandidatesBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param knownGender 
     * @return NameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameKanjiCandidates(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, knownGender: kotlin.String) : NameMatchCandidatesOut {
        val localVarResponse = japaneseNameKanjiCandidatesWithHttpInfo(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin, knownGender = knownGender)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae - and a known gender.
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param knownGender 
     * @return ApiResponse<NameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameKanjiCandidatesWithHttpInfo(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, knownGender: kotlin.String) : ApiResponse<NameMatchCandidatesOut?> {
        val localVariableConfig = japaneseNameKanjiCandidatesRequestConfig(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin, knownGender = knownGender)

        return request<Unit, NameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameKanjiCandidates
     *
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param knownGender 
     * @return RequestConfig
     */
    fun japaneseNameKanjiCandidatesRequestConfig(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, knownGender: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{knownGender}".replace("{"+"japaneseSurnameLatin"+"}", encodeURIComponent(japaneseSurnameLatin.toString())).replace("{"+"japaneseGivenNameLatin"+"}", encodeURIComponent(japaneseGivenNameLatin.toString())).replace("{"+"knownGender"+"}", encodeURIComponent(knownGender.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @return NameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameKanjiCandidates1(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String) : NameMatchCandidatesOut {
        val localVarResponse = japaneseNameKanjiCandidates1WithHttpInfo(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name ex. Yamamoto Sanae
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @return ApiResponse<NameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameKanjiCandidates1WithHttpInfo(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String) : ApiResponse<NameMatchCandidatesOut?> {
        val localVariableConfig = japaneseNameKanjiCandidates1RequestConfig(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin)

        return request<Unit, NameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameKanjiCandidates1
     *
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @return RequestConfig
     */
    fun japaneseNameKanjiCandidates1RequestConfig(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/japaneseNameKanjiCandidates/{japaneseSurnameLatin}/{japaneseGivenNameLatin}".replace("{"+"japaneseSurnameLatin"+"}", encodeURIComponent(japaneseSurnameLatin.toString())).replace("{"+"japaneseGivenNameLatin"+"}", encodeURIComponent(japaneseGivenNameLatin.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname), ex. Yamamoto Sanae
     * 
     * @param batchFirstLastNameIn A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return BatchNameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameKanjiCandidatesBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchNameMatchCandidatesOut {
        val localVarResponse = japaneseNameKanjiCandidatesBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Identify japanese name candidates in KANJI, based on the romanized name (firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname), ex. Yamamoto Sanae
     * 
     * @param batchFirstLastNameIn A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return ApiResponse<BatchNameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameKanjiCandidatesBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchNameMatchCandidatesOut?> {
        val localVariableConfig = japaneseNameKanjiCandidatesBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchNameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameKanjiCandidatesBatch
     *
     * @param batchFirstLastNameIn A list of personal japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return RequestConfig
     */
    fun japaneseNameKanjiCandidatesBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/japaneseNameKanjiCandidatesBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Romanize japanese name, based on the name in Kanji.
     * 
     * @param japaneseSurnameKanji 
     * @param japaneseGivenNameKanji 
     * @return NameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameLatinCandidates(japaneseSurnameKanji: kotlin.String, japaneseGivenNameKanji: kotlin.String) : NameMatchCandidatesOut {
        val localVarResponse = japaneseNameLatinCandidatesWithHttpInfo(japaneseSurnameKanji = japaneseSurnameKanji, japaneseGivenNameKanji = japaneseGivenNameKanji)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Romanize japanese name, based on the name in Kanji.
     * 
     * @param japaneseSurnameKanji 
     * @param japaneseGivenNameKanji 
     * @return ApiResponse<NameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameLatinCandidatesWithHttpInfo(japaneseSurnameKanji: kotlin.String, japaneseGivenNameKanji: kotlin.String) : ApiResponse<NameMatchCandidatesOut?> {
        val localVariableConfig = japaneseNameLatinCandidatesRequestConfig(japaneseSurnameKanji = japaneseSurnameKanji, japaneseGivenNameKanji = japaneseGivenNameKanji)

        return request<Unit, NameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameLatinCandidates
     *
     * @param japaneseSurnameKanji 
     * @param japaneseGivenNameKanji 
     * @return RequestConfig
     */
    fun japaneseNameLatinCandidatesRequestConfig(japaneseSurnameKanji: kotlin.String, japaneseGivenNameKanji: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/japaneseNameLatinCandidates/{japaneseSurnameKanji}/{japaneseGivenNameKanji}".replace("{"+"japaneseSurnameKanji"+"}", encodeURIComponent(japaneseSurnameKanji.toString())).replace("{"+"japaneseGivenNameKanji"+"}", encodeURIComponent(japaneseGivenNameKanji.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Romanize japanese names, based on the name in KANJI
     * 
     * @param batchFirstLastNameIn A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return BatchNameMatchCandidatesOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameLatinCandidatesBatch(batchFirstLastNameIn: BatchFirstLastNameIn? = null) : BatchNameMatchCandidatesOut {
        val localVarResponse = japaneseNameLatinCandidatesBatchWithHttpInfo(batchFirstLastNameIn = batchFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchCandidatesOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Romanize japanese names, based on the name in KANJI
     * 
     * @param batchFirstLastNameIn A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return ApiResponse<BatchNameMatchCandidatesOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameLatinCandidatesBatchWithHttpInfo(batchFirstLastNameIn: BatchFirstLastNameIn?) : ApiResponse<BatchNameMatchCandidatesOut?> {
        val localVariableConfig = japaneseNameLatinCandidatesBatchRequestConfig(batchFirstLastNameIn = batchFirstLastNameIn)

        return request<BatchFirstLastNameIn, BatchNameMatchCandidatesOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameLatinCandidatesBatch
     *
     * @param batchFirstLastNameIn A list of personal japanese names in KANJI, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return RequestConfig
     */
    fun japaneseNameLatinCandidatesBatchRequestConfig(batchFirstLastNameIn: BatchFirstLastNameIn?) : RequestConfig<BatchFirstLastNameIn> {
        val localVariableBody = batchFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/japaneseNameLatinCandidatesBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param japaneseName 
     * @return NameMatchedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameMatch(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, japaneseName: kotlin.String) : NameMatchedOut {
        val localVarResponse = japaneseNameMatchWithHttpInfo(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin, japaneseName = japaneseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NameMatchedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Return a score for matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param japaneseName 
     * @return ApiResponse<NameMatchedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameMatchWithHttpInfo(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, japaneseName: kotlin.String) : ApiResponse<NameMatchedOut?> {
        val localVariableConfig = japaneseNameMatchRequestConfig(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin, japaneseName = japaneseName)

        return request<Unit, NameMatchedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameMatch
     *
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param japaneseName 
     * @return RequestConfig
     */
    fun japaneseNameMatchRequestConfig(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, japaneseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/japaneseNameMatch/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}".replace("{"+"japaneseSurnameLatin"+"}", encodeURIComponent(japaneseSurnameLatin.toString())).replace("{"+"japaneseGivenNameLatin"+"}", encodeURIComponent(japaneseGivenNameLatin.toString())).replace("{"+"japaneseName"+"}", encodeURIComponent(japaneseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     * 
     * @param batchMatchPersonalFirstLastNameIn A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return BatchNameMatchedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameMatchBatch(batchMatchPersonalFirstLastNameIn: BatchMatchPersonalFirstLastNameIn? = null) : BatchNameMatchedOut {
        val localVarResponse = japaneseNameMatchBatchWithHttpInfo(batchMatchPersonalFirstLastNameIn = batchMatchPersonalFirstLastNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchNameMatchedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Return a score for matching a list of Japanese names in KANJI ex. 山本 早苗 with romanized names ex. Yamamoto Sanae
     * 
     * @param batchMatchPersonalFirstLastNameIn A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return ApiResponse<BatchNameMatchedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameMatchBatchWithHttpInfo(batchMatchPersonalFirstLastNameIn: BatchMatchPersonalFirstLastNameIn?) : ApiResponse<BatchNameMatchedOut?> {
        val localVariableConfig = japaneseNameMatchBatchRequestConfig(batchMatchPersonalFirstLastNameIn = batchMatchPersonalFirstLastNameIn)

        return request<BatchMatchPersonalFirstLastNameIn, BatchNameMatchedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameMatchBatch
     *
     * @param batchMatchPersonalFirstLastNameIn A list of personal Japanese names in LATIN, firstName &#x3D; japaneseGivenName; lastName&#x3D;japaneseSurname (optional)
     * @return RequestConfig
     */
    fun japaneseNameMatchBatchRequestConfig(batchMatchPersonalFirstLastNameIn: BatchMatchPersonalFirstLastNameIn?) : RequestConfig<BatchMatchPersonalFirstLastNameIn> {
        val localVariableBody = batchMatchPersonalFirstLastNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/japaneseNameMatchBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param japaneseName 
     * @return FeedbackLoopOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun japaneseNameMatchFeedbackLoop(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, japaneseName: kotlin.String) : FeedbackLoopOut {
        val localVarResponse = japaneseNameMatchFeedbackLoopWithHttpInfo(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin, japaneseName = japaneseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeedbackLoopOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * [CREDITS 1 UNIT] Feedback loop to better perform matching Japanese name in KANJI ex. 山本 早苗 with a romanized name ex. Yamamoto Sanae
     * 
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param japaneseName 
     * @return ApiResponse<FeedbackLoopOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun japaneseNameMatchFeedbackLoopWithHttpInfo(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, japaneseName: kotlin.String) : ApiResponse<FeedbackLoopOut?> {
        val localVariableConfig = japaneseNameMatchFeedbackLoopRequestConfig(japaneseSurnameLatin = japaneseSurnameLatin, japaneseGivenNameLatin = japaneseGivenNameLatin, japaneseName = japaneseName)

        return request<Unit, FeedbackLoopOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation japaneseNameMatchFeedbackLoop
     *
     * @param japaneseSurnameLatin 
     * @param japaneseGivenNameLatin 
     * @param japaneseName 
     * @return RequestConfig
     */
    fun japaneseNameMatchFeedbackLoopRequestConfig(japaneseSurnameLatin: kotlin.String, japaneseGivenNameLatin: kotlin.String, japaneseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/japaneseNameMatchFeedbackLoop/{japaneseSurnameLatin}/{japaneseGivenNameLatin}/{japaneseName}".replace("{"+"japaneseSurnameLatin"+"}", encodeURIComponent(japaneseSurnameLatin.toString())).replace("{"+"japaneseGivenNameLatin"+"}", encodeURIComponent(japaneseGivenNameLatin.toString())).replace("{"+"japaneseName"+"}", encodeURIComponent(japaneseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     * 
     * @param japaneseName 
     * @return PersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseJapaneseName(japaneseName: kotlin.String) : PersonalNameParsedOut {
        val localVarResponse = parseJapaneseNameWithHttpInfo(japaneseName = japaneseName)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae
     * 
     * @param japaneseName 
     * @return ApiResponse<PersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseJapaneseNameWithHttpInfo(japaneseName: kotlin.String) : ApiResponse<PersonalNameParsedOut?> {
        val localVariableConfig = parseJapaneseNameRequestConfig(japaneseName = japaneseName)

        return request<Unit, PersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseJapaneseName
     *
     * @param japaneseName 
     * @return RequestConfig
     */
    fun parseJapaneseNameRequestConfig(japaneseName: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api2/json/parseJapaneseName/{japaneseName}".replace("{"+"japaneseName"+"}", encodeURIComponent(japaneseName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae 
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return BatchPersonalNameParsedOut
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun parseJapaneseNameBatch(batchPersonalNameIn: BatchPersonalNameIn? = null) : BatchPersonalNameParsedOut {
        val localVarResponse = parseJapaneseNameBatchWithHttpInfo(batchPersonalNameIn = batchPersonalNameIn)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatchPersonalNameParsedOut
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Infer the likely first/last name structure of a name, ex. 山本 早苗 or Yamamoto Sanae 
     * 
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return ApiResponse<BatchPersonalNameParsedOut?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun parseJapaneseNameBatchWithHttpInfo(batchPersonalNameIn: BatchPersonalNameIn?) : ApiResponse<BatchPersonalNameParsedOut?> {
        val localVariableConfig = parseJapaneseNameBatchRequestConfig(batchPersonalNameIn = batchPersonalNameIn)

        return request<BatchPersonalNameIn, BatchPersonalNameParsedOut>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation parseJapaneseNameBatch
     *
     * @param batchPersonalNameIn A list of personal names (optional)
     * @return RequestConfig
     */
    fun parseJapaneseNameBatchRequestConfig(batchPersonalNameIn: BatchPersonalNameIn?) : RequestConfig<BatchPersonalNameIn> {
        val localVariableBody = batchPersonalNameIn
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api2/json/parseJapaneseNameBatch",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
