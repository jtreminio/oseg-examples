/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.BranchCollectionRep
import com.launchdarkly.client.models.BranchRep
import com.launchdarkly.client.models.Extinction
import com.launchdarkly.client.models.ExtinctionCollectionRep
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.PatchOperation
import com.launchdarkly.client.models.PutBranch
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.RepositoryCollectionRep
import com.launchdarkly.client.models.RepositoryPost
import com.launchdarkly.client.models.RepositoryRep
import com.launchdarkly.client.models.StatisticCollectionRep
import com.launchdarkly.client.models.StatisticsRoot
import com.launchdarkly.client.models.StatusConflictErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class CodeReferencesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Delete branches
     * Asynchronously delete a number of branches.
     * @param repo The repository name to delete branches for.
     * @param requestBody 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBranches(repo: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : Unit {
        val localVarResponse = deleteBranchesWithHttpInfo(repo = repo, requestBody = requestBody)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete branches
     * Asynchronously delete a number of branches.
     * @param repo The repository name to delete branches for.
     * @param requestBody 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBranchesWithHttpInfo(repo: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : ApiResponse<Unit?> {
        val localVariableConfig = deleteBranchesRequestConfig(repo = repo, requestBody = requestBody)

        return request<kotlin.collections.List<kotlin.String>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBranches
     *
     * @param repo The repository name to delete branches for.
     * @param requestBody 
     * @return RequestConfig
     */
    fun deleteBranchesRequestConfig(repo: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : RequestConfig<kotlin.collections.List<kotlin.String>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/code-refs/repositories/{repo}/branch-delete-tasks".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete repository
     * Delete a repository with the specified name.
     * @param repo The repository name
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteRepository(repo: kotlin.String) : Unit {
        val localVarResponse = deleteRepositoryWithHttpInfo(repo = repo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete repository
     * Delete a repository with the specified name.
     * @param repo The repository name
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteRepositoryWithHttpInfo(repo: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteRepositoryRequestConfig(repo = repo)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteRepository
     *
     * @param repo The repository name
     * @return RequestConfig
     */
    fun deleteRepositoryRequestConfig(repo: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/code-refs/repositories/{repo}".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get branch
     * Get a specific branch in a repository.
     * @param repo The repository name
     * @param branch The url-encoded branch name
     * @param projKey Filter results to a specific project (optional)
     * @param flagKey Filter results to a specific flag key (optional)
     * @return BranchRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBranch(repo: kotlin.String, branch: kotlin.String, projKey: kotlin.String? = null, flagKey: kotlin.String? = null) : BranchRep {
        val localVarResponse = getBranchWithHttpInfo(repo = repo, branch = branch, projKey = projKey, flagKey = flagKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BranchRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get branch
     * Get a specific branch in a repository.
     * @param repo The repository name
     * @param branch The url-encoded branch name
     * @param projKey Filter results to a specific project (optional)
     * @param flagKey Filter results to a specific flag key (optional)
     * @return ApiResponse<BranchRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBranchWithHttpInfo(repo: kotlin.String, branch: kotlin.String, projKey: kotlin.String?, flagKey: kotlin.String?) : ApiResponse<BranchRep?> {
        val localVariableConfig = getBranchRequestConfig(repo = repo, branch = branch, projKey = projKey, flagKey = flagKey)

        return request<Unit, BranchRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBranch
     *
     * @param repo The repository name
     * @param branch The url-encoded branch name
     * @param projKey Filter results to a specific project (optional)
     * @param flagKey Filter results to a specific flag key (optional)
     * @return RequestConfig
     */
    fun getBranchRequestConfig(repo: kotlin.String, branch: kotlin.String, projKey: kotlin.String?, flagKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (projKey != null) {
                    put("projKey", listOf(projKey.toString()))
                }
                if (flagKey != null) {
                    put("flagKey", listOf(flagKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/repositories/{repo}/branches/{branch}".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())).replace("{"+"branch"+"}", encodeURIComponent(branch.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List branches
     * Get a list of branches.
     * @param repo The repository name
     * @return BranchCollectionRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBranches(repo: kotlin.String) : BranchCollectionRep {
        val localVarResponse = getBranchesWithHttpInfo(repo = repo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BranchCollectionRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List branches
     * Get a list of branches.
     * @param repo The repository name
     * @return ApiResponse<BranchCollectionRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBranchesWithHttpInfo(repo: kotlin.String) : ApiResponse<BranchCollectionRep?> {
        val localVariableConfig = getBranchesRequestConfig(repo = repo)

        return request<Unit, BranchCollectionRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBranches
     *
     * @param repo The repository name
     * @return RequestConfig
     */
    fun getBranchesRequestConfig(repo: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/repositories/{repo}/branches".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List extinctions
     * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [About extinction events](https://docs.launchdarkly.com/home/observability/code-references#about-extinction-events).
     * @param repoName Filter results to a specific repository (optional)
     * @param branchName Filter results to a specific branch. By default, only the default branch will be queried for extinctions. (optional)
     * @param projKey Filter results to a specific project (optional)
     * @param flagKey Filter results to a specific flag key (optional)
     * @param from Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;. (optional)
     * @param to Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;. (optional)
     * @return ExtinctionCollectionRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExtinctions(repoName: kotlin.String? = null, branchName: kotlin.String? = null, projKey: kotlin.String? = null, flagKey: kotlin.String? = null, from: kotlin.Long? = null, to: kotlin.Long? = null) : ExtinctionCollectionRep {
        val localVarResponse = getExtinctionsWithHttpInfo(repoName = repoName, branchName = branchName, projKey = projKey, flagKey = flagKey, from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExtinctionCollectionRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List extinctions
     * Get a list of all extinctions. LaunchDarkly creates an extinction event after you remove all code references to a flag. To learn more, read [About extinction events](https://docs.launchdarkly.com/home/observability/code-references#about-extinction-events).
     * @param repoName Filter results to a specific repository (optional)
     * @param branchName Filter results to a specific branch. By default, only the default branch will be queried for extinctions. (optional)
     * @param projKey Filter results to a specific project (optional)
     * @param flagKey Filter results to a specific flag key (optional)
     * @param from Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;. (optional)
     * @param to Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;. (optional)
     * @return ApiResponse<ExtinctionCollectionRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExtinctionsWithHttpInfo(repoName: kotlin.String?, branchName: kotlin.String?, projKey: kotlin.String?, flagKey: kotlin.String?, from: kotlin.Long?, to: kotlin.Long?) : ApiResponse<ExtinctionCollectionRep?> {
        val localVariableConfig = getExtinctionsRequestConfig(repoName = repoName, branchName = branchName, projKey = projKey, flagKey = flagKey, from = from, to = to)

        return request<Unit, ExtinctionCollectionRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getExtinctions
     *
     * @param repoName Filter results to a specific repository (optional)
     * @param branchName Filter results to a specific branch. By default, only the default branch will be queried for extinctions. (optional)
     * @param projKey Filter results to a specific project (optional)
     * @param flagKey Filter results to a specific flag key (optional)
     * @param from Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;to&#x60;. (optional)
     * @param to Filter results to a specific timeframe based on commit time, expressed as a Unix epoch time in milliseconds. Must be used with &#x60;from&#x60;. (optional)
     * @return RequestConfig
     */
    fun getExtinctionsRequestConfig(repoName: kotlin.String?, branchName: kotlin.String?, projKey: kotlin.String?, flagKey: kotlin.String?, from: kotlin.Long?, to: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (repoName != null) {
                    put("repoName", listOf(repoName.toString()))
                }
                if (branchName != null) {
                    put("branchName", listOf(branchName.toString()))
                }
                if (projKey != null) {
                    put("projKey", listOf(projKey.toString()))
                }
                if (flagKey != null) {
                    put("flagKey", listOf(flagKey.toString()))
                }
                if (from != null) {
                    put("from", listOf(from.toString()))
                }
                if (to != null) {
                    put("to", listOf(to.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/extinctions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List repositories
     * Get a list of connected repositories. Optionally, you can include branch metadata with the &#x60;withBranches&#x60; query parameter. Embed references for the default branch with &#x60;ReferencesForDefaultBranch&#x60;. You can also filter the list of code references by project key and flag key.
     * @param withBranches If set to any value, the endpoint returns repositories with associated branch data (optional)
     * @param withReferencesForDefaultBranch If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch (optional)
     * @param projKey A LaunchDarkly project key. If provided, this filters code reference results to the specified project. (optional)
     * @param flagKey If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch (optional)
     * @return RepositoryCollectionRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRepositories(withBranches: kotlin.String? = null, withReferencesForDefaultBranch: kotlin.String? = null, projKey: kotlin.String? = null, flagKey: kotlin.String? = null) : RepositoryCollectionRep {
        val localVarResponse = getRepositoriesWithHttpInfo(withBranches = withBranches, withReferencesForDefaultBranch = withReferencesForDefaultBranch, projKey = projKey, flagKey = flagKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RepositoryCollectionRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List repositories
     * Get a list of connected repositories. Optionally, you can include branch metadata with the &#x60;withBranches&#x60; query parameter. Embed references for the default branch with &#x60;ReferencesForDefaultBranch&#x60;. You can also filter the list of code references by project key and flag key.
     * @param withBranches If set to any value, the endpoint returns repositories with associated branch data (optional)
     * @param withReferencesForDefaultBranch If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch (optional)
     * @param projKey A LaunchDarkly project key. If provided, this filters code reference results to the specified project. (optional)
     * @param flagKey If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch (optional)
     * @return ApiResponse<RepositoryCollectionRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRepositoriesWithHttpInfo(withBranches: kotlin.String?, withReferencesForDefaultBranch: kotlin.String?, projKey: kotlin.String?, flagKey: kotlin.String?) : ApiResponse<RepositoryCollectionRep?> {
        val localVariableConfig = getRepositoriesRequestConfig(withBranches = withBranches, withReferencesForDefaultBranch = withReferencesForDefaultBranch, projKey = projKey, flagKey = flagKey)

        return request<Unit, RepositoryCollectionRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRepositories
     *
     * @param withBranches If set to any value, the endpoint returns repositories with associated branch data (optional)
     * @param withReferencesForDefaultBranch If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch (optional)
     * @param projKey A LaunchDarkly project key. If provided, this filters code reference results to the specified project. (optional)
     * @param flagKey If set to any value, the endpoint returns repositories with associated branch data, as well as code references for the default git branch (optional)
     * @return RequestConfig
     */
    fun getRepositoriesRequestConfig(withBranches: kotlin.String?, withReferencesForDefaultBranch: kotlin.String?, projKey: kotlin.String?, flagKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (withBranches != null) {
                    put("withBranches", listOf(withBranches.toString()))
                }
                if (withReferencesForDefaultBranch != null) {
                    put("withReferencesForDefaultBranch", listOf(withReferencesForDefaultBranch.toString()))
                }
                if (projKey != null) {
                    put("projKey", listOf(projKey.toString()))
                }
                if (flagKey != null) {
                    put("flagKey", listOf(flagKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/repositories",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get repository
     * Get a single repository by name.
     * @param repo The repository name
     * @return RepositoryRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRepository(repo: kotlin.String) : RepositoryRep {
        val localVarResponse = getRepositoryWithHttpInfo(repo = repo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RepositoryRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get repository
     * Get a single repository by name.
     * @param repo The repository name
     * @return ApiResponse<RepositoryRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRepositoryWithHttpInfo(repo: kotlin.String) : ApiResponse<RepositoryRep?> {
        val localVariableConfig = getRepositoryRequestConfig(repo = repo)

        return request<Unit, RepositoryRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRepository
     *
     * @param repo The repository name
     * @return RequestConfig
     */
    fun getRepositoryRequestConfig(repo: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/repositories/{repo}".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get links to code reference repositories for each project
     * Get links for all projects that have code references.
     * @return StatisticsRoot
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRootStatistic() : StatisticsRoot {
        val localVarResponse = getRootStatisticWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StatisticsRoot
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get links to code reference repositories for each project
     * Get links for all projects that have code references.
     * @return ApiResponse<StatisticsRoot?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRootStatisticWithHttpInfo() : ApiResponse<StatisticsRoot?> {
        val localVariableConfig = getRootStatisticRequestConfig()

        return request<Unit, StatisticsRoot>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRootStatistic
     *
     * @return RequestConfig
     */
    fun getRootStatisticRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/statistics",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get code references statistics for flags
     * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, &#x60;main&#x60;. Optionally, you can include the &#x60;flagKey&#x60; query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
     * @param projectKey The project key
     * @param flagKey Filter results to a specific flag key (optional)
     * @return StatisticCollectionRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStatistics(projectKey: kotlin.String, flagKey: kotlin.String? = null) : StatisticCollectionRep {
        val localVarResponse = getStatisticsWithHttpInfo(projectKey = projectKey, flagKey = flagKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as StatisticCollectionRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get code references statistics for flags
     * Get statistics about all the code references across repositories for all flags in your project that have code references in the default branch, for example, &#x60;main&#x60;. Optionally, you can include the &#x60;flagKey&#x60; query parameter to limit your request to statistics about code references for a single flag. This endpoint returns the number of references to your flag keys in your repositories, as well as a link to each repository.
     * @param projectKey The project key
     * @param flagKey Filter results to a specific flag key (optional)
     * @return ApiResponse<StatisticCollectionRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStatisticsWithHttpInfo(projectKey: kotlin.String, flagKey: kotlin.String?) : ApiResponse<StatisticCollectionRep?> {
        val localVariableConfig = getStatisticsRequestConfig(projectKey = projectKey, flagKey = flagKey)

        return request<Unit, StatisticCollectionRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStatistics
     *
     * @param projectKey The project key
     * @param flagKey Filter results to a specific flag key (optional)
     * @return RequestConfig
     */
    fun getStatisticsRequestConfig(projectKey: kotlin.String, flagKey: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (flagKey != null) {
                    put("flagKey", listOf(flagKey.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/code-refs/statistics/{projectKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update repository
     * Update a repository&#39;s settings. Updating repository settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @param repo The repository name
     * @param patchOperation 
     * @return RepositoryRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchRepository(repo: kotlin.String, patchOperation: kotlin.collections.List<PatchOperation>) : RepositoryRep {
        val localVarResponse = patchRepositoryWithHttpInfo(repo = repo, patchOperation = patchOperation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RepositoryRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update repository
     * Update a repository&#39;s settings. Updating repository settings uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @param repo The repository name
     * @param patchOperation 
     * @return ApiResponse<RepositoryRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchRepositoryWithHttpInfo(repo: kotlin.String, patchOperation: kotlin.collections.List<PatchOperation>) : ApiResponse<RepositoryRep?> {
        val localVariableConfig = patchRepositoryRequestConfig(repo = repo, patchOperation = patchOperation)

        return request<kotlin.collections.List<PatchOperation>, RepositoryRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchRepository
     *
     * @param repo The repository name
     * @param patchOperation 
     * @return RequestConfig
     */
    fun patchRepositoryRequestConfig(repo: kotlin.String, patchOperation: kotlin.collections.List<PatchOperation>) : RequestConfig<kotlin.collections.List<PatchOperation>> {
        val localVariableBody = patchOperation
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/code-refs/repositories/{repo}".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create extinction
     * Create a new extinction.
     * @param repo The repository name
     * @param branch The URL-encoded branch name
     * @param extinction 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postExtinction(repo: kotlin.String, branch: kotlin.String, extinction: kotlin.collections.List<Extinction>) : Unit {
        val localVarResponse = postExtinctionWithHttpInfo(repo = repo, branch = branch, extinction = extinction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create extinction
     * Create a new extinction.
     * @param repo The repository name
     * @param branch The URL-encoded branch name
     * @param extinction 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun postExtinctionWithHttpInfo(repo: kotlin.String, branch: kotlin.String, extinction: kotlin.collections.List<Extinction>) : ApiResponse<Unit?> {
        val localVariableConfig = postExtinctionRequestConfig(repo = repo, branch = branch, extinction = extinction)

        return request<kotlin.collections.List<Extinction>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postExtinction
     *
     * @param repo The repository name
     * @param branch The URL-encoded branch name
     * @param extinction 
     * @return RequestConfig
     */
    fun postExtinctionRequestConfig(repo: kotlin.String, branch: kotlin.String, extinction: kotlin.collections.List<Extinction>) : RequestConfig<kotlin.collections.List<Extinction>> {
        val localVariableBody = extinction
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/code-refs/repositories/{repo}/branches/{branch}/extinction-events".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())).replace("{"+"branch"+"}", encodeURIComponent(branch.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create repository
     * Create a repository with the specified name.
     * @param repositoryPost 
     * @return RepositoryRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postRepository(repositoryPost: RepositoryPost) : RepositoryRep {
        val localVarResponse = postRepositoryWithHttpInfo(repositoryPost = repositoryPost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RepositoryRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create repository
     * Create a repository with the specified name.
     * @param repositoryPost 
     * @return ApiResponse<RepositoryRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postRepositoryWithHttpInfo(repositoryPost: RepositoryPost) : ApiResponse<RepositoryRep?> {
        val localVariableConfig = postRepositoryRequestConfig(repositoryPost = repositoryPost)

        return request<RepositoryPost, RepositoryRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postRepository
     *
     * @param repositoryPost 
     * @return RequestConfig
     */
    fun postRepositoryRequestConfig(repositoryPost: RepositoryPost) : RequestConfig<RepositoryPost> {
        val localVariableBody = repositoryPost
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/code-refs/repositories",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Upsert branch
     * Create a new branch if it doesn&#39;t exist, or update the branch if it already exists.
     * @param repo The repository name
     * @param branch The URL-encoded branch name
     * @param putBranch 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putBranch(repo: kotlin.String, branch: kotlin.String, putBranch: PutBranch) : Unit {
        val localVarResponse = putBranchWithHttpInfo(repo = repo, branch = branch, putBranch = putBranch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Upsert branch
     * Create a new branch if it doesn&#39;t exist, or update the branch if it already exists.
     * @param repo The repository name
     * @param branch The URL-encoded branch name
     * @param putBranch 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun putBranchWithHttpInfo(repo: kotlin.String, branch: kotlin.String, putBranch: PutBranch) : ApiResponse<Unit?> {
        val localVariableConfig = putBranchRequestConfig(repo = repo, branch = branch, putBranch = putBranch)

        return request<PutBranch, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putBranch
     *
     * @param repo The repository name
     * @param branch The URL-encoded branch name
     * @param putBranch 
     * @return RequestConfig
     */
    fun putBranchRequestConfig(repo: kotlin.String, branch: kotlin.String, putBranch: PutBranch) : RequestConfig<PutBranch> {
        val localVariableBody = putBranch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/code-refs/repositories/{repo}/branches/{branch}".replace("{"+"repo"+"}", encodeURIComponent(repo.toString())).replace("{"+"branch"+"}", encodeURIComponent(branch.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
