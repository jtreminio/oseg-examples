/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.HoldoutDetailRep
import com.launchdarkly.client.models.HoldoutPatchInput
import com.launchdarkly.client.models.HoldoutPostRequest
import com.launchdarkly.client.models.HoldoutRep
import com.launchdarkly.client.models.HoldoutsCollectionRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class HoldoutsBetaApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Get all holdouts
     * 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param limit The number of holdouts to return in the response. Defaults to 20 (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an &#x60;offset&#x60; of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return HoldoutsCollectionRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAllHoldouts(projectKey: kotlin.String, environmentKey: kotlin.String, limit: kotlin.Long? = null, offset: kotlin.Long? = null) : HoldoutsCollectionRep {
        val localVarResponse = getAllHoldoutsWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HoldoutsCollectionRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all holdouts
     * 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param limit The number of holdouts to return in the response. Defaults to 20 (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an &#x60;offset&#x60; of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ApiResponse<HoldoutsCollectionRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllHoldoutsWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, limit: kotlin.Long?, offset: kotlin.Long?) : ApiResponse<HoldoutsCollectionRep?> {
        val localVariableConfig = getAllHoldoutsRequestConfig(projectKey = projectKey, environmentKey = environmentKey, limit = limit, offset = offset)

        return request<Unit, HoldoutsCollectionRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllHoldouts
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param limit The number of holdouts to return in the response. Defaults to 20 (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an &#x60;offset&#x60; of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return RequestConfig
     */
    fun getAllHoldoutsRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, limit: kotlin.Long?, offset: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get holdout
     * Get details about a holdout.  ### Expanding the holdout response  LaunchDarkly supports the following fields for expanding the \&quot;Get holdout\&quot; response. By default, these fields are **not** included in the response.  To expand the response, append the &#x60;expand&#x60; query parameter and add a comma-separated list with any of the following fields:  - &#x60;draftIteration&#x60; includes the iteration which has not been started yet, if any, for this holdout. - &#x60;previousIterations&#x60; includes all iterations prior to the current iteration, for this holdout. By default only the current iteration is included in the response. - &#x60;rel-draftIteration&#x60; includes the iteration which has not been started yet, if any, for the experiments related to this holdout. - &#x60;rel-metrics&#x60; includes metrics for experiments related to this holdout. - &#x60;rel-previousIterations&#x60; includes all iterations prior to the current iteration, for the experiments related to this holdout. - &#x60;rel-secondaryMetrics&#x60; includes secondary metrics for experiments related to this holdout. - &#x60;rel-treatments&#x60; includes all treatment and parameter details for experiments related to this holdout. - &#x60;secondaryMetrics&#x60; includes secondary metrics for this holdout. By default only the primary metric is included in the response. - &#x60;treatments&#x60; includes all treatment and parameter details for this holdout. By default treatment data is not included in the response.  For example, &#x60;expand&#x3D;draftIteration,rel-draftIteration&#x60; includes the &#x60;draftIteration&#x60; and &#x60;rel-draftIteration&#x60; fields in the response. If fields that you request with the &#x60;expand&#x60; query parameter are empty, they are not included in the response. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutKey The holdout experiment key
     * @param expand A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above. Holdout experiment expansion fields have no prefix. Related experiment expansion fields have &#x60;rel-&#x60; as a prefix. (optional)
     * @return HoldoutDetailRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getHoldout(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutKey: kotlin.String, expand: kotlin.String? = null) : HoldoutDetailRep {
        val localVarResponse = getHoldoutWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, holdoutKey = holdoutKey, expand = expand)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HoldoutDetailRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get holdout
     * Get details about a holdout.  ### Expanding the holdout response  LaunchDarkly supports the following fields for expanding the \&quot;Get holdout\&quot; response. By default, these fields are **not** included in the response.  To expand the response, append the &#x60;expand&#x60; query parameter and add a comma-separated list with any of the following fields:  - &#x60;draftIteration&#x60; includes the iteration which has not been started yet, if any, for this holdout. - &#x60;previousIterations&#x60; includes all iterations prior to the current iteration, for this holdout. By default only the current iteration is included in the response. - &#x60;rel-draftIteration&#x60; includes the iteration which has not been started yet, if any, for the experiments related to this holdout. - &#x60;rel-metrics&#x60; includes metrics for experiments related to this holdout. - &#x60;rel-previousIterations&#x60; includes all iterations prior to the current iteration, for the experiments related to this holdout. - &#x60;rel-secondaryMetrics&#x60; includes secondary metrics for experiments related to this holdout. - &#x60;rel-treatments&#x60; includes all treatment and parameter details for experiments related to this holdout. - &#x60;secondaryMetrics&#x60; includes secondary metrics for this holdout. By default only the primary metric is included in the response. - &#x60;treatments&#x60; includes all treatment and parameter details for this holdout. By default treatment data is not included in the response.  For example, &#x60;expand&#x3D;draftIteration,rel-draftIteration&#x60; includes the &#x60;draftIteration&#x60; and &#x60;rel-draftIteration&#x60; fields in the response. If fields that you request with the &#x60;expand&#x60; query parameter are empty, they are not included in the response. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutKey The holdout experiment key
     * @param expand A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above. Holdout experiment expansion fields have no prefix. Related experiment expansion fields have &#x60;rel-&#x60; as a prefix. (optional)
     * @return ApiResponse<HoldoutDetailRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getHoldoutWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutKey: kotlin.String, expand: kotlin.String?) : ApiResponse<HoldoutDetailRep?> {
        val localVariableConfig = getHoldoutRequestConfig(projectKey = projectKey, environmentKey = environmentKey, holdoutKey = holdoutKey, expand = expand)

        return request<Unit, HoldoutDetailRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getHoldout
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutKey The holdout experiment key
     * @param expand A comma-separated list of properties that can reveal additional information in the response. Supported fields are explained above. Holdout experiment expansion fields have no prefix. Related experiment expansion fields have &#x60;rel-&#x60; as a prefix. (optional)
     * @return RequestConfig
     */
    fun getHoldoutRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutKey: kotlin.String, expand: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (expand != null) {
                    put("expand", listOf(expand.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/{holdoutKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"holdoutKey"+"}", encodeURIComponent(holdoutKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get Holdout by Id
     * 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutId The holdout experiment ID
     * @return HoldoutRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getHoldoutById(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutId: kotlin.String) : HoldoutRep {
        val localVarResponse = getHoldoutByIdWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, holdoutId = holdoutId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HoldoutRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get Holdout by Id
     * 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutId The holdout experiment ID
     * @return ApiResponse<HoldoutRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getHoldoutByIdWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutId: kotlin.String) : ApiResponse<HoldoutRep?> {
        val localVariableConfig = getHoldoutByIdRequestConfig(projectKey = projectKey, environmentKey = environmentKey, holdoutId = holdoutId)

        return request<Unit, HoldoutRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getHoldoutById
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutId The holdout experiment ID
     * @return RequestConfig
     */
    fun getHoldoutByIdRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/id/{holdoutId}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"holdoutId"+"}", encodeURIComponent(holdoutId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Patch holdout
     * Updates an existing holdout, and returns the updated holdout. Updating holdouts uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating holdouts.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating holdouts&lt;/strong&gt;&lt;/summary&gt;  #### endHoldout  Ends a holdout.  ##### Parameters  None.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing why the holdout is ending\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;endHoldout\&quot;   }] } &#x60;&#x60;&#x60;  #### removeExperiment  Removes an experiment from a holdout.  ##### Parameters  - &#x60;value&#x60;: The key of the experiment to remove  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing the change\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExperiment\&quot;,     \&quot;value\&quot;: \&quot;experiment-key\&quot;   }] } &#x60;&#x60;&#x60;  #### updateDescription  Updates the description of the holdout.  ##### Parameters  - &#x60;value&#x60;: The new description.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing the update\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateDescription\&quot;,     \&quot;value\&quot;: \&quot;Updated holdout description\&quot;   }] } &#x60;&#x60;&#x60;  #### updateName  Updates the name of the holdout.  ##### Parameters  - &#x60;value&#x60;: The new name.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing the update\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateName\&quot;,     \&quot;value\&quot;: \&quot;Updated holdout name\&quot;   }] } &#x60;&#x60;&#x60;  &lt;/details&gt; 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutKey The holdout key
     * @param holdoutPatchInput 
     * @return HoldoutRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchHoldout(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutKey: kotlin.String, holdoutPatchInput: HoldoutPatchInput) : HoldoutRep {
        val localVarResponse = patchHoldoutWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, holdoutKey = holdoutKey, holdoutPatchInput = holdoutPatchInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HoldoutRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Patch holdout
     * Updates an existing holdout, and returns the updated holdout. Updating holdouts uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating holdouts.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating holdouts&lt;/strong&gt;&lt;/summary&gt;  #### endHoldout  Ends a holdout.  ##### Parameters  None.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing why the holdout is ending\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;endHoldout\&quot;   }] } &#x60;&#x60;&#x60;  #### removeExperiment  Removes an experiment from a holdout.  ##### Parameters  - &#x60;value&#x60;: The key of the experiment to remove  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing the change\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExperiment\&quot;,     \&quot;value\&quot;: \&quot;experiment-key\&quot;   }] } &#x60;&#x60;&#x60;  #### updateDescription  Updates the description of the holdout.  ##### Parameters  - &#x60;value&#x60;: The new description.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing the update\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateDescription\&quot;,     \&quot;value\&quot;: \&quot;Updated holdout description\&quot;   }] } &#x60;&#x60;&#x60;  #### updateName  Updates the name of the holdout.  ##### Parameters  - &#x60;value&#x60;: The new name.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;comment\&quot;: \&quot;Optional comment describing the update\&quot;,   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateName\&quot;,     \&quot;value\&quot;: \&quot;Updated holdout name\&quot;   }] } &#x60;&#x60;&#x60;  &lt;/details&gt; 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutKey The holdout key
     * @param holdoutPatchInput 
     * @return ApiResponse<HoldoutRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchHoldoutWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutKey: kotlin.String, holdoutPatchInput: HoldoutPatchInput) : ApiResponse<HoldoutRep?> {
        val localVariableConfig = patchHoldoutRequestConfig(projectKey = projectKey, environmentKey = environmentKey, holdoutKey = holdoutKey, holdoutPatchInput = holdoutPatchInput)

        return request<HoldoutPatchInput, HoldoutRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchHoldout
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutKey The holdout key
     * @param holdoutPatchInput 
     * @return RequestConfig
     */
    fun patchHoldoutRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutKey: kotlin.String, holdoutPatchInput: HoldoutPatchInput) : RequestConfig<HoldoutPatchInput> {
        val localVariableBody = holdoutPatchInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts/{holdoutKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"holdoutKey"+"}", encodeURIComponent(holdoutKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create holdout
     * Create a new holdout in the specified project.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutPostRequest 
     * @return HoldoutRep
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postHoldout(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutPostRequest: HoldoutPostRequest) : HoldoutRep {
        val localVarResponse = postHoldoutWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, holdoutPostRequest = holdoutPostRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as HoldoutRep
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create holdout
     * Create a new holdout in the specified project.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutPostRequest 
     * @return ApiResponse<HoldoutRep?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postHoldoutWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutPostRequest: HoldoutPostRequest) : ApiResponse<HoldoutRep?> {
        val localVariableConfig = postHoldoutRequestConfig(projectKey = projectKey, environmentKey = environmentKey, holdoutPostRequest = holdoutPostRequest)

        return request<HoldoutPostRequest, HoldoutRep>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postHoldout
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param holdoutPostRequest 
     * @return RequestConfig
     */
    fun postHoldoutRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, holdoutPostRequest: HoldoutPostRequest) : RequestConfig<HoldoutPostRequest> {
        val localVariableBody = holdoutPostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/holdouts".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
