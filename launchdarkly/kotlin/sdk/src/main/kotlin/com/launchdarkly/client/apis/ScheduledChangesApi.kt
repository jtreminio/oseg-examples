/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.FeatureFlagScheduledChange
import com.launchdarkly.client.models.FeatureFlagScheduledChanges
import com.launchdarkly.client.models.FlagScheduledChangesInput
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.MethodNotAllowedErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.PostFlagScheduledChangesInput
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.StatusConflictErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class ScheduledChangesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Delete scheduled changes workflow
     * Delete a scheduled changes workflow.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteFlagConfigScheduledChanges(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String) : Unit {
        val localVarResponse = deleteFlagConfigScheduledChangesWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete scheduled changes workflow
     * Delete a scheduled changes workflow.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteFlagConfigScheduledChangesWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteFlagConfigScheduledChangesRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteFlagConfigScheduledChanges
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change id
     * @return RequestConfig
     */
    fun deleteFlagConfigScheduledChangesRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get a scheduled change
     * Get a scheduled change that will be applied to the feature flag by ID.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change id
     * @return FeatureFlagScheduledChange
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFeatureFlagScheduledChange(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String) : FeatureFlagScheduledChange {
        val localVarResponse = getFeatureFlagScheduledChangeWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeatureFlagScheduledChange
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get a scheduled change
     * Get a scheduled change that will be applied to the feature flag by ID.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change id
     * @return ApiResponse<FeatureFlagScheduledChange?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFeatureFlagScheduledChangeWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String) : ApiResponse<FeatureFlagScheduledChange?> {
        val localVariableConfig = getFeatureFlagScheduledChangeRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, id = id)

        return request<Unit, FeatureFlagScheduledChange>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFeatureFlagScheduledChange
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change id
     * @return RequestConfig
     */
    fun getFeatureFlagScheduledChangeRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List scheduled changes
     * Get a list of scheduled changes that will be applied to the feature flag.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @return FeatureFlagScheduledChanges
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFlagConfigScheduledChanges(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String) : FeatureFlagScheduledChanges {
        val localVarResponse = getFlagConfigScheduledChangesWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeatureFlagScheduledChanges
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List scheduled changes
     * Get a list of scheduled changes that will be applied to the feature flag.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @return ApiResponse<FeatureFlagScheduledChanges?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFlagConfigScheduledChangesWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String) : ApiResponse<FeatureFlagScheduledChanges?> {
        val localVariableConfig = getFlagConfigScheduledChangesRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey)

        return request<Unit, FeatureFlagScheduledChanges>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFlagConfigScheduledChanges
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @return RequestConfig
     */
    fun getFlagConfigScheduledChangesRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update scheduled changes workflow
     *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating scheduled changes.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating scheduled changes&lt;/strong&gt;&lt;/summary&gt;  #### deleteScheduledChange  Removes the scheduled change.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{ \&quot;kind\&quot;: \&quot;deleteScheduledChange\&quot; }] } &#x60;&#x60;&#x60;  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - &#x60;value&#x60;: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are &#x60;turnFlagOn&#x60; and &#x60;turnFlagOff&#x60;.  Here&#39;s an example that replaces the scheduled changes with new instructions to turn flag targeting off:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [     {       \&quot;kind\&quot;: \&quot;replaceScheduledChangesInstructions\&quot;,       \&quot;value\&quot;: [ {\&quot;kind\&quot;: \&quot;turnFlagOff\&quot;} ]     }   ] } &#x60;&#x60;&#x60;  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - &#x60;value&#x60;: the new execution date, in Unix milliseconds.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [     {       \&quot;kind\&quot;: \&quot;updateScheduledChangesExecutionDate\&quot;,       \&quot;value\&quot;: 1754092860000     }   ] } &#x60;&#x60;&#x60;  &lt;/details&gt; 
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change ID
     * @param flagScheduledChangesInput 
     * @param ignoreConflicts Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes (optional)
     * @return FeatureFlagScheduledChange
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchFlagConfigScheduledChange(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts: kotlin.Boolean? = null) : FeatureFlagScheduledChange {
        val localVarResponse = patchFlagConfigScheduledChangeWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, id = id, flagScheduledChangesInput = flagScheduledChangesInput, ignoreConflicts = ignoreConflicts)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeatureFlagScheduledChange
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update scheduled changes workflow
     *  Update a scheduled change, overriding existing instructions with the new ones. Updating a scheduled change uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating scheduled changes.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating scheduled changes&lt;/strong&gt;&lt;/summary&gt;  #### deleteScheduledChange  Removes the scheduled change.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{ \&quot;kind\&quot;: \&quot;deleteScheduledChange\&quot; }] } &#x60;&#x60;&#x60;  #### replaceScheduledChangesInstructions  Removes the existing scheduled changes and replaces them with the new instructions.  ##### Parameters  - &#x60;value&#x60;: An array of the new actions to perform when the execution date for these scheduled changes arrives. Supported scheduled actions are &#x60;turnFlagOn&#x60; and &#x60;turnFlagOff&#x60;.  Here&#39;s an example that replaces the scheduled changes with new instructions to turn flag targeting off:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [     {       \&quot;kind\&quot;: \&quot;replaceScheduledChangesInstructions\&quot;,       \&quot;value\&quot;: [ {\&quot;kind\&quot;: \&quot;turnFlagOff\&quot;} ]     }   ] } &#x60;&#x60;&#x60;  #### updateScheduledChangesExecutionDate  Updates the execution date for the scheduled changes.  ##### Parameters  - &#x60;value&#x60;: the new execution date, in Unix milliseconds.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [     {       \&quot;kind\&quot;: \&quot;updateScheduledChangesExecutionDate\&quot;,       \&quot;value\&quot;: 1754092860000     }   ] } &#x60;&#x60;&#x60;  &lt;/details&gt; 
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change ID
     * @param flagScheduledChangesInput 
     * @param ignoreConflicts Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes (optional)
     * @return ApiResponse<FeatureFlagScheduledChange?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchFlagConfigScheduledChangeWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts: kotlin.Boolean?) : ApiResponse<FeatureFlagScheduledChange?> {
        val localVariableConfig = patchFlagConfigScheduledChangeRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, id = id, flagScheduledChangesInput = flagScheduledChangesInput, ignoreConflicts = ignoreConflicts)

        return request<FlagScheduledChangesInput, FeatureFlagScheduledChange>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchFlagConfigScheduledChange
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param id The scheduled change ID
     * @param flagScheduledChangesInput 
     * @param ignoreConflicts Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these new instructions conflict with existing scheduled changes (optional)
     * @return RequestConfig
     */
    fun patchFlagConfigScheduledChangeRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, id: kotlin.String, flagScheduledChangesInput: FlagScheduledChangesInput, ignoreConflicts: kotlin.Boolean?) : RequestConfig<FlagScheduledChangesInput> {
        val localVariableBody = flagScheduledChangesInput
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ignoreConflicts != null) {
                    put("ignoreConflicts", listOf(ignoreConflicts.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes/{id}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create scheduled changes workflow
     * Create scheduled changes for a feature flag. If the &#x60;ignoreConficts&#x60; query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param postFlagScheduledChangesInput 
     * @param ignoreConflicts Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes (optional)
     * @return FeatureFlagScheduledChange
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postFlagConfigScheduledChanges(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts: kotlin.Boolean? = null) : FeatureFlagScheduledChange {
        val localVarResponse = postFlagConfigScheduledChangesWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, postFlagScheduledChangesInput = postFlagScheduledChangesInput, ignoreConflicts = ignoreConflicts)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FeatureFlagScheduledChange
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create scheduled changes workflow
     * Create scheduled changes for a feature flag. If the &#x60;ignoreConficts&#x60; query parameter is false and there are conflicts between these instructions and existing scheduled changes, the request will fail. If the parameter is true and there are conflicts, the request will succeed.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param postFlagScheduledChangesInput 
     * @param ignoreConflicts Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes (optional)
     * @return ApiResponse<FeatureFlagScheduledChange?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postFlagConfigScheduledChangesWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts: kotlin.Boolean?) : ApiResponse<FeatureFlagScheduledChange?> {
        val localVariableConfig = postFlagConfigScheduledChangesRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, postFlagScheduledChangesInput = postFlagScheduledChangesInput, ignoreConflicts = ignoreConflicts)

        return request<PostFlagScheduledChangesInput, FeatureFlagScheduledChange>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postFlagConfigScheduledChanges
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param postFlagScheduledChangesInput 
     * @param ignoreConflicts Whether to succeed (&#x60;true&#x60;) or fail (&#x60;false&#x60;) when these instructions conflict with existing scheduled changes (optional)
     * @return RequestConfig
     */
    fun postFlagConfigScheduledChangesRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, postFlagScheduledChangesInput: PostFlagScheduledChangesInput, ignoreConflicts: kotlin.Boolean?) : RequestConfig<PostFlagScheduledChangesInput> {
        val localVariableBody = postFlagScheduledChangesInput
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ignoreConflicts != null) {
                    put("ignoreConflicts", listOf(ignoreConflicts.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/scheduled-changes".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
