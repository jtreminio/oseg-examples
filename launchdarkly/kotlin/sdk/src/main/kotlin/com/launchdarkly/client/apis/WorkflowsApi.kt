/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.CustomWorkflowInput
import com.launchdarkly.client.models.CustomWorkflowOutput
import com.launchdarkly.client.models.CustomWorkflowsListingOutput
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class WorkflowsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Delete workflow
     * Delete a workflow from a feature flag.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param workflowId The workflow id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteWorkflow(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, workflowId: kotlin.String) : Unit {
        val localVarResponse = deleteWorkflowWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, workflowId = workflowId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete workflow
     * Delete a workflow from a feature flag.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param workflowId The workflow id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteWorkflowWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, workflowId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteWorkflowRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, workflowId = workflowId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteWorkflow
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param workflowId The workflow id
     * @return RequestConfig
     */
    fun deleteWorkflowRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, workflowId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"workflowId"+"}", encodeURIComponent(workflowId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get custom workflow
     * Get a specific workflow by ID.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param workflowId The workflow ID
     * @return CustomWorkflowOutput
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCustomWorkflow(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, workflowId: kotlin.String) : CustomWorkflowOutput {
        val localVarResponse = getCustomWorkflowWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, workflowId = workflowId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomWorkflowOutput
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get custom workflow
     * Get a specific workflow by ID.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param workflowId The workflow ID
     * @return ApiResponse<CustomWorkflowOutput?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCustomWorkflowWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, workflowId: kotlin.String) : ApiResponse<CustomWorkflowOutput?> {
        val localVariableConfig = getCustomWorkflowRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, workflowId = workflowId)

        return request<Unit, CustomWorkflowOutput>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCustomWorkflow
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param workflowId The workflow ID
     * @return RequestConfig
     */
    fun getCustomWorkflowRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, workflowId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows/{workflowId}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"workflowId"+"}", encodeURIComponent(workflowId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get workflows
     * Display workflows associated with a feature flag.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param status Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;. (optional)
     * @param sort A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;. (optional)
     * @param limit The maximum number of workflows to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return CustomWorkflowsListingOutput
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getWorkflows(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, status: kotlin.String? = null, sort: kotlin.String? = null, limit: kotlin.Long? = null, offset: kotlin.Long? = null) : CustomWorkflowsListingOutput {
        val localVarResponse = getWorkflowsWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, status = status, sort = sort, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomWorkflowsListingOutput
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get workflows
     * Display workflows associated with a feature flag.
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param status Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;. (optional)
     * @param sort A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;. (optional)
     * @param limit The maximum number of workflows to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ApiResponse<CustomWorkflowsListingOutput?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getWorkflowsWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, status: kotlin.String?, sort: kotlin.String?, limit: kotlin.Long?, offset: kotlin.Long?) : ApiResponse<CustomWorkflowsListingOutput?> {
        val localVariableConfig = getWorkflowsRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, status = status, sort = sort, limit = limit, offset = offset)

        return request<Unit, CustomWorkflowsListingOutput>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getWorkflows
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param status Filter results by workflow status. Valid status filters are &#x60;active&#x60;, &#x60;completed&#x60;, and &#x60;failed&#x60;. (optional)
     * @param sort A field to sort the items by. Prefix field by a dash ( - ) to sort in descending order. This endpoint supports sorting by &#x60;creationDate&#x60; or &#x60;stopDate&#x60;. (optional)
     * @param limit The maximum number of workflows to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return RequestConfig
     */
    fun getWorkflowsRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, status: kotlin.String?, sort: kotlin.String?, limit: kotlin.Long?, offset: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create workflow
     * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a &#x60;stages&#x60; array to the request body.  For each stage, define the &#x60;name&#x60;, &#x60;conditions&#x60; when the stage should be executed, and &#x60;action&#x60; that describes the stage.  &lt;details&gt; &lt;summary&gt;Click to expand example&lt;/summary&gt;  _Example request body_ &#x60;&#x60;&#x60;json {   \&quot;name\&quot;: \&quot;Progressive rollout starting in two days\&quot;,   \&quot;description\&quot;: \&quot;Turn flag targeting on and increase feature rollout in 10% increments each day\&quot;,   \&quot;stages\&quot;: [     {       \&quot;name\&quot;: \&quot;10% rollout on day 1\&quot;,       \&quot;conditions\&quot;: [         {           \&quot;kind\&quot;: \&quot;schedule\&quot;,           \&quot;scheduleKind\&quot;: \&quot;relative\&quot;, // or \&quot;absolute\&quot;               //  If \&quot;scheduleKind\&quot; is \&quot;absolute\&quot;, set \&quot;executionDate\&quot;;               // \&quot;waitDuration\&quot; and \&quot;waitDurationUnit\&quot; will be ignored           \&quot;waitDuration\&quot;: 2,           \&quot;waitDurationUnit\&quot;: \&quot;calendarDay\&quot;         },         {           \&quot;kind\&quot;: \&quot;ld-approval\&quot;,           \&quot;notifyMemberIds\&quot;: [ \&quot;507f1f77bcf86cd799439011\&quot; ],           \&quot;notifyTeamKeys\&quot;: [ \&quot;team-key-123abc\&quot; ]         }       ],       \&quot;action\&quot;: {         \&quot;instructions\&quot;: [           {             \&quot;kind\&quot;: \&quot;turnFlagOn\&quot;           },           {             \&quot;kind\&quot;: \&quot;updateFallthroughVariationOrRollout\&quot;,             \&quot;rolloutWeights\&quot;: {               \&quot;452f5fb5-7320-4ba3-81a1-8f4324f79d49\&quot;: 90000,               \&quot;fc15f6a4-05d3-4aa4-a997-446be461345d\&quot;: 10000             }           }         ]       }     }   ] } &#x60;&#x60;&#x60; &lt;/details&gt;  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the &#x60;templateKey&#x60; query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a &#x60;dryRun&#x60; query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the &#x60;dryRun&#x60; query parameter is present the response body includes a &#x60;meta&#x60; property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a &#x60;valid&#x60; field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the &#x60;parameters&#x60; property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the &#x60;parameters&#x60; property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  &lt;details&gt; &lt;summary&gt;Click to expand example&lt;/summary&gt;  _Example request body_ &#x60;&#x60;&#x60;json {  \&quot;name\&quot;: \&quot;workflow created from my-template\&quot;,  \&quot;description\&quot;: \&quot;description of my workflow\&quot;,  \&quot;parameters\&quot;: [   {    \&quot;_id\&quot;: \&quot;62cf2bc4cadbeb7697943f3b\&quot;,    \&quot;path\&quot;: \&quot;/clauses/0/values\&quot;,    \&quot;default\&quot;: {     \&quot;value\&quot;: [\&quot;updated-segment\&quot;]    }   },   {    \&quot;_id\&quot;: \&quot;62cf2bc4cadbeb7697943f3d\&quot;,    \&quot;path\&quot;: \&quot;/variationId\&quot;,    \&quot;default\&quot;: {     \&quot;value\&quot;: \&quot;abcd1234-abcd-1234-abcd-1234abcd12\&quot;    }   }  ] } &#x60;&#x60;&#x60; &lt;/details&gt;  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the &#x60;meta&#x60; property will be included in the response body detailing which parameters need to be updated. 
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param customWorkflowInput 
     * @param templateKey The template key to apply as a starting point for the new workflow (optional)
     * @param dryRun Whether to call the endpoint in dry-run mode (optional)
     * @return CustomWorkflowOutput
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postWorkflow(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, customWorkflowInput: CustomWorkflowInput, templateKey: kotlin.String? = null, dryRun: kotlin.Boolean? = null) : CustomWorkflowOutput {
        val localVarResponse = postWorkflowWithHttpInfo(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, customWorkflowInput = customWorkflowInput, templateKey = templateKey, dryRun = dryRun)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomWorkflowOutput
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create workflow
     * Create a workflow for a feature flag. You can create a workflow directly, or you can apply a template to create a new workflow.  ### Creating a workflow  You can use the create workflow endpoint to create a workflow directly by adding a &#x60;stages&#x60; array to the request body.  For each stage, define the &#x60;name&#x60;, &#x60;conditions&#x60; when the stage should be executed, and &#x60;action&#x60; that describes the stage.  &lt;details&gt; &lt;summary&gt;Click to expand example&lt;/summary&gt;  _Example request body_ &#x60;&#x60;&#x60;json {   \&quot;name\&quot;: \&quot;Progressive rollout starting in two days\&quot;,   \&quot;description\&quot;: \&quot;Turn flag targeting on and increase feature rollout in 10% increments each day\&quot;,   \&quot;stages\&quot;: [     {       \&quot;name\&quot;: \&quot;10% rollout on day 1\&quot;,       \&quot;conditions\&quot;: [         {           \&quot;kind\&quot;: \&quot;schedule\&quot;,           \&quot;scheduleKind\&quot;: \&quot;relative\&quot;, // or \&quot;absolute\&quot;               //  If \&quot;scheduleKind\&quot; is \&quot;absolute\&quot;, set \&quot;executionDate\&quot;;               // \&quot;waitDuration\&quot; and \&quot;waitDurationUnit\&quot; will be ignored           \&quot;waitDuration\&quot;: 2,           \&quot;waitDurationUnit\&quot;: \&quot;calendarDay\&quot;         },         {           \&quot;kind\&quot;: \&quot;ld-approval\&quot;,           \&quot;notifyMemberIds\&quot;: [ \&quot;507f1f77bcf86cd799439011\&quot; ],           \&quot;notifyTeamKeys\&quot;: [ \&quot;team-key-123abc\&quot; ]         }       ],       \&quot;action\&quot;: {         \&quot;instructions\&quot;: [           {             \&quot;kind\&quot;: \&quot;turnFlagOn\&quot;           },           {             \&quot;kind\&quot;: \&quot;updateFallthroughVariationOrRollout\&quot;,             \&quot;rolloutWeights\&quot;: {               \&quot;452f5fb5-7320-4ba3-81a1-8f4324f79d49\&quot;: 90000,               \&quot;fc15f6a4-05d3-4aa4-a997-446be461345d\&quot;: 10000             }           }         ]       }     }   ] } &#x60;&#x60;&#x60; &lt;/details&gt;  ### Creating a workflow by applying a workflow template  You can also create a workflow by applying a workflow template. If you pass a valid workflow template key as the &#x60;templateKey&#x60; query parameter with the request, the API will attempt to create a new workflow with the stages defined in the workflow template with the corresponding key.  #### Applicability of stages Templates are created in the context of a particular flag in a particular environment in a particular project. However, because workflows created from a template can be applied to any project, environment, and flag, some steps of the workflow may need to be updated in order to be applicable for the target resource.  You can pass a &#x60;dryRun&#x60; query parameter to tell the API to return a report of which steps of the workflow template are applicable in the target project/environment/flag, and which will need to be updated. When the &#x60;dryRun&#x60; query parameter is present the response body includes a &#x60;meta&#x60; property that holds a list of parameters that could potentially be inapplicable for the target resource. Each of these parameters will include a &#x60;valid&#x60; field. You will need to update any invalid parameters in order to create the new workflow. You can do this using the &#x60;parameters&#x60; property, which overrides the workflow template parameters.  #### Overriding template parameters You can use the &#x60;parameters&#x60; property in the request body to tell the API to override the specified workflow template parameters with new values that are specific to your target project/environment/flag.  &lt;details&gt; &lt;summary&gt;Click to expand example&lt;/summary&gt;  _Example request body_ &#x60;&#x60;&#x60;json {  \&quot;name\&quot;: \&quot;workflow created from my-template\&quot;,  \&quot;description\&quot;: \&quot;description of my workflow\&quot;,  \&quot;parameters\&quot;: [   {    \&quot;_id\&quot;: \&quot;62cf2bc4cadbeb7697943f3b\&quot;,    \&quot;path\&quot;: \&quot;/clauses/0/values\&quot;,    \&quot;default\&quot;: {     \&quot;value\&quot;: [\&quot;updated-segment\&quot;]    }   },   {    \&quot;_id\&quot;: \&quot;62cf2bc4cadbeb7697943f3d\&quot;,    \&quot;path\&quot;: \&quot;/variationId\&quot;,    \&quot;default\&quot;: {     \&quot;value\&quot;: \&quot;abcd1234-abcd-1234-abcd-1234abcd12\&quot;    }   }  ] } &#x60;&#x60;&#x60; &lt;/details&gt;  If there are any steps in the template that are not applicable to the target resource, the workflow will not be created, and the &#x60;meta&#x60; property will be included in the response body detailing which parameters need to be updated. 
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param customWorkflowInput 
     * @param templateKey The template key to apply as a starting point for the new workflow (optional)
     * @param dryRun Whether to call the endpoint in dry-run mode (optional)
     * @return ApiResponse<CustomWorkflowOutput?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postWorkflowWithHttpInfo(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, customWorkflowInput: CustomWorkflowInput, templateKey: kotlin.String?, dryRun: kotlin.Boolean?) : ApiResponse<CustomWorkflowOutput?> {
        val localVariableConfig = postWorkflowRequestConfig(projectKey = projectKey, featureFlagKey = featureFlagKey, environmentKey = environmentKey, customWorkflowInput = customWorkflowInput, templateKey = templateKey, dryRun = dryRun)

        return request<CustomWorkflowInput, CustomWorkflowOutput>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postWorkflow
     *
     * @param projectKey The project key
     * @param featureFlagKey The feature flag key
     * @param environmentKey The environment key
     * @param customWorkflowInput 
     * @param templateKey The template key to apply as a starting point for the new workflow (optional)
     * @param dryRun Whether to call the endpoint in dry-run mode (optional)
     * @return RequestConfig
     */
    fun postWorkflowRequestConfig(projectKey: kotlin.String, featureFlagKey: kotlin.String, environmentKey: kotlin.String, customWorkflowInput: CustomWorkflowInput, templateKey: kotlin.String?, dryRun: kotlin.Boolean?) : RequestConfig<CustomWorkflowInput> {
        val localVariableBody = customWorkflowInput
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (templateKey != null) {
                    put("templateKey", listOf(templateKey.toString()))
                }
                if (dryRun != null) {
                    put("dryRun", listOf(dryRun.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/flags/{featureFlagKey}/environments/{environmentKey}/workflows".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
