/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.BigSegmentStoreIntegration
import com.launchdarkly.client.models.BigSegmentStoreIntegrationCollection
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.IntegrationDeliveryConfigurationPost
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.PatchOperation
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.StatusConflictErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class PersistentStoreIntegrationsBetaApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Create big segment store integration
     *  Create a persistent store integration.  If you are using server-side SDKs, segments synced from external tools and larger list-based segments require a persistent store within your infrastructure. LaunchDarkly keeps the persistent store up to date and consults it during flag evaluation.  You can use either Redis or DynamoDB as your persistent store. When you create a persistent store integration, the fields in the &#x60;config&#x60; object in the request vary depending on which persistent store you use.  If you are using Redis to create your persistent store integration, you will need to know:  * Your Redis host * Your Redis port * Your Redis username * Your Redis password * Whether or not LaunchDarkly should connect using TLS  If you are using DynamoDB to create your persistent store integration, you will need to know:  * Your DynamoDB table name. The table must have the following schema:   * Partition key: &#x60;namespace&#x60; (string)   * Sort key: &#x60;key&#x60; (string) * Your DynamoDB Amazon Web Services (AWS) region. * Your AWS role Amazon Resource Name (ARN). This is the role that LaunchDarkly will assume to manage your DynamoDB table. * The External ID you specified when creating your Amazon Resource Name (ARN).  To learn more, read [Segment configuration](https://docs.launchdarkly.com/home/flags/segment-config). 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationDeliveryConfigurationPost 
     * @return BigSegmentStoreIntegration
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBigSegmentStoreIntegration(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost) : BigSegmentStoreIntegration {
        val localVarResponse = createBigSegmentStoreIntegrationWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationDeliveryConfigurationPost = integrationDeliveryConfigurationPost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigSegmentStoreIntegration
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create big segment store integration
     *  Create a persistent store integration.  If you are using server-side SDKs, segments synced from external tools and larger list-based segments require a persistent store within your infrastructure. LaunchDarkly keeps the persistent store up to date and consults it during flag evaluation.  You can use either Redis or DynamoDB as your persistent store. When you create a persistent store integration, the fields in the &#x60;config&#x60; object in the request vary depending on which persistent store you use.  If you are using Redis to create your persistent store integration, you will need to know:  * Your Redis host * Your Redis port * Your Redis username * Your Redis password * Whether or not LaunchDarkly should connect using TLS  If you are using DynamoDB to create your persistent store integration, you will need to know:  * Your DynamoDB table name. The table must have the following schema:   * Partition key: &#x60;namespace&#x60; (string)   * Sort key: &#x60;key&#x60; (string) * Your DynamoDB Amazon Web Services (AWS) region. * Your AWS role Amazon Resource Name (ARN). This is the role that LaunchDarkly will assume to manage your DynamoDB table. * The External ID you specified when creating your Amazon Resource Name (ARN).  To learn more, read [Segment configuration](https://docs.launchdarkly.com/home/flags/segment-config). 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationDeliveryConfigurationPost 
     * @return ApiResponse<BigSegmentStoreIntegration?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createBigSegmentStoreIntegrationWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost) : ApiResponse<BigSegmentStoreIntegration?> {
        val localVariableConfig = createBigSegmentStoreIntegrationRequestConfig(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationDeliveryConfigurationPost = integrationDeliveryConfigurationPost)

        return request<IntegrationDeliveryConfigurationPost, BigSegmentStoreIntegration>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBigSegmentStoreIntegration
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationDeliveryConfigurationPost 
     * @return RequestConfig
     */
    fun createBigSegmentStoreIntegrationRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationDeliveryConfigurationPost: IntegrationDeliveryConfigurationPost) : RequestConfig<IntegrationDeliveryConfigurationPost> {
        val localVariableBody = integrationDeliveryConfigurationPost
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"integrationKey"+"}", encodeURIComponent(integrationKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete big segment store integration
     * Delete a persistent store integration. Each integration uses either Redis or DynamoDB.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBigSegmentStoreIntegration(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String) : Unit {
        val localVarResponse = deleteBigSegmentStoreIntegrationWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationId = integrationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete big segment store integration
     * Delete a persistent store integration. Each integration uses either Redis or DynamoDB.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBigSegmentStoreIntegrationWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteBigSegmentStoreIntegrationRequestConfig(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationId = integrationId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBigSegmentStoreIntegration
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @return RequestConfig
     */
    fun deleteBigSegmentStoreIntegrationRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"integrationKey"+"}", encodeURIComponent(integrationKey.toString())).replace("{"+"integrationId"+"}", encodeURIComponent(integrationId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get big segment store integration by ID
     * Get a big segment store integration by ID.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @return BigSegmentStoreIntegration
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBigSegmentStoreIntegration(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String) : BigSegmentStoreIntegration {
        val localVarResponse = getBigSegmentStoreIntegrationWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationId = integrationId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigSegmentStoreIntegration
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get big segment store integration by ID
     * Get a big segment store integration by ID.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @return ApiResponse<BigSegmentStoreIntegration?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBigSegmentStoreIntegrationWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String) : ApiResponse<BigSegmentStoreIntegration?> {
        val localVariableConfig = getBigSegmentStoreIntegrationRequestConfig(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationId = integrationId)

        return request<Unit, BigSegmentStoreIntegration>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBigSegmentStoreIntegration
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @return RequestConfig
     */
    fun getBigSegmentStoreIntegrationRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"integrationKey"+"}", encodeURIComponent(integrationKey.toString())).replace("{"+"integrationId"+"}", encodeURIComponent(integrationId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List all big segment store integrations
     * List all big segment store integrations.
     * @return BigSegmentStoreIntegrationCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBigSegmentStoreIntegrations() : BigSegmentStoreIntegrationCollection {
        val localVarResponse = getBigSegmentStoreIntegrationsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigSegmentStoreIntegrationCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List all big segment store integrations
     * List all big segment store integrations.
     * @return ApiResponse<BigSegmentStoreIntegrationCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBigSegmentStoreIntegrationsWithHttpInfo() : ApiResponse<BigSegmentStoreIntegrationCollection?> {
        val localVariableConfig = getBigSegmentStoreIntegrationsRequestConfig()

        return request<Unit, BigSegmentStoreIntegrationCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBigSegmentStoreIntegrations
     *
     * @return RequestConfig
     */
    fun getBigSegmentStoreIntegrationsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/integration-capabilities/big-segment-store",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update big segment store integration
     * Update a big segment store integration. Updating a big segment store requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @param patchOperation 
     * @return BigSegmentStoreIntegration
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchBigSegmentStoreIntegration(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String, patchOperation: kotlin.collections.List<PatchOperation>) : BigSegmentStoreIntegration {
        val localVarResponse = patchBigSegmentStoreIntegrationWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationId = integrationId, patchOperation = patchOperation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigSegmentStoreIntegration
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update big segment store integration
     * Update a big segment store integration. Updating a big segment store requires a [JSON Patch](https://datatracker.ietf.org/doc/html/rfc6902) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @param patchOperation 
     * @return ApiResponse<BigSegmentStoreIntegration?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchBigSegmentStoreIntegrationWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String, patchOperation: kotlin.collections.List<PatchOperation>) : ApiResponse<BigSegmentStoreIntegration?> {
        val localVariableConfig = patchBigSegmentStoreIntegrationRequestConfig(projectKey = projectKey, environmentKey = environmentKey, integrationKey = integrationKey, integrationId = integrationId, patchOperation = patchOperation)

        return request<kotlin.collections.List<PatchOperation>, BigSegmentStoreIntegration>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchBigSegmentStoreIntegration
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param integrationKey The integration key, either &#x60;redis&#x60; or &#x60;dynamodb&#x60;
     * @param integrationId The integration ID
     * @param patchOperation 
     * @return RequestConfig
     */
    fun patchBigSegmentStoreIntegrationRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, integrationKey: kotlin.String, integrationId: kotlin.String, patchOperation: kotlin.collections.List<PatchOperation>) : RequestConfig<kotlin.collections.List<PatchOperation>> {
        val localVariableBody = patchOperation
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/integration-capabilities/big-segment-store/{projectKey}/{environmentKey}/{integrationKey}/{integrationId}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"integrationKey"+"}", encodeURIComponent(integrationKey.toString())).replace("{"+"integrationId"+"}", encodeURIComponent(integrationId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
