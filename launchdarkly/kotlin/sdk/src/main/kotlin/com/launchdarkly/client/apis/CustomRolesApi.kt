/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.CustomRole
import com.launchdarkly.client.models.CustomRolePost
import com.launchdarkly.client.models.CustomRoles
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.PatchWithComment
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.StatusConflictErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class CustomRolesApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Delete custom role
     * Delete a custom role by key
     * @param customRoleKey The custom role key
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteCustomRole(customRoleKey: kotlin.String) : Unit {
        val localVarResponse = deleteCustomRoleWithHttpInfo(customRoleKey = customRoleKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete custom role
     * Delete a custom role by key
     * @param customRoleKey The custom role key
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteCustomRoleWithHttpInfo(customRoleKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteCustomRoleRequestConfig(customRoleKey = customRoleKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteCustomRole
     *
     * @param customRoleKey The custom role key
     * @return RequestConfig
     */
    fun deleteCustomRoleRequestConfig(customRoleKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/roles/{customRoleKey}".replace("{"+"customRoleKey"+"}", encodeURIComponent(customRoleKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get custom role
     * Get a single custom role by key or ID
     * @param customRoleKey The custom role key or ID
     * @return CustomRole
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCustomRole(customRoleKey: kotlin.String) : CustomRole {
        val localVarResponse = getCustomRoleWithHttpInfo(customRoleKey = customRoleKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomRole
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get custom role
     * Get a single custom role by key or ID
     * @param customRoleKey The custom role key or ID
     * @return ApiResponse<CustomRole?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCustomRoleWithHttpInfo(customRoleKey: kotlin.String) : ApiResponse<CustomRole?> {
        val localVariableConfig = getCustomRoleRequestConfig(customRoleKey = customRoleKey)

        return request<Unit, CustomRole>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCustomRole
     *
     * @param customRoleKey The custom role key or ID
     * @return RequestConfig
     */
    fun getCustomRoleRequestConfig(customRoleKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/roles/{customRoleKey}".replace("{"+"customRoleKey"+"}", encodeURIComponent(customRoleKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List custom roles
     * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it&#39;s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you&#39;re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
     * @param limit The maximum number of custom roles to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return CustomRoles
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCustomRoles(limit: kotlin.Long? = null, offset: kotlin.Long? = null) : CustomRoles {
        val localVarResponse = getCustomRolesWithHttpInfo(limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomRoles
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List custom roles
     * Get a complete list of custom roles. Custom roles let you create flexible policies providing fine-grained access control to everything in LaunchDarkly, from feature flags to goals, environments, and teams. With custom roles, it&#39;s possible to enforce access policies that meet your exact workflow needs. Custom roles are available to customers on our enterprise plans. If you&#39;re interested in learning more about our enterprise plans, contact sales@launchdarkly.com.
     * @param limit The maximum number of custom roles to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ApiResponse<CustomRoles?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCustomRolesWithHttpInfo(limit: kotlin.Long?, offset: kotlin.Long?) : ApiResponse<CustomRoles?> {
        val localVariableConfig = getCustomRolesRequestConfig(limit = limit, offset = offset)

        return request<Unit, CustomRoles>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCustomRoles
     *
     * @param limit The maximum number of custom roles to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return RequestConfig
     */
    fun getCustomRolesRequestConfig(limit: kotlin.Long?, offset: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/roles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update custom role
     * Update a single custom role. Updating a custom role uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).&lt;br/&gt;&lt;br/&gt;To add an element to the &#x60;policy&#x60; array, set the &#x60;path&#x60; to &#x60;/policy&#x60; and then append &#x60;/&lt;array index&gt;&#x60;. Use &#x60;/0&#x60; to add to the beginning of the array. Use &#x60;/-&#x60; to add to the end of the array.
     * @param customRoleKey The custom role key
     * @param patchWithComment 
     * @return CustomRole
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchCustomRole(customRoleKey: kotlin.String, patchWithComment: PatchWithComment) : CustomRole {
        val localVarResponse = patchCustomRoleWithHttpInfo(customRoleKey = customRoleKey, patchWithComment = patchWithComment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomRole
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update custom role
     * Update a single custom role. Updating a custom role uses a [JSON patch](https://datatracker.ietf.org/doc/html/rfc6902) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes. To learn more, read [Updates](/#section/Overview/Updates).&lt;br/&gt;&lt;br/&gt;To add an element to the &#x60;policy&#x60; array, set the &#x60;path&#x60; to &#x60;/policy&#x60; and then append &#x60;/&lt;array index&gt;&#x60;. Use &#x60;/0&#x60; to add to the beginning of the array. Use &#x60;/-&#x60; to add to the end of the array.
     * @param customRoleKey The custom role key
     * @param patchWithComment 
     * @return ApiResponse<CustomRole?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchCustomRoleWithHttpInfo(customRoleKey: kotlin.String, patchWithComment: PatchWithComment) : ApiResponse<CustomRole?> {
        val localVariableConfig = patchCustomRoleRequestConfig(customRoleKey = customRoleKey, patchWithComment = patchWithComment)

        return request<PatchWithComment, CustomRole>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchCustomRole
     *
     * @param customRoleKey The custom role key
     * @param patchWithComment 
     * @return RequestConfig
     */
    fun patchCustomRoleRequestConfig(customRoleKey: kotlin.String, patchWithComment: PatchWithComment) : RequestConfig<PatchWithComment> {
        val localVariableBody = patchWithComment
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/roles/{customRoleKey}".replace("{"+"customRoleKey"+"}", encodeURIComponent(customRoleKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create custom role
     * Create a new custom role
     * @param customRolePost 
     * @return CustomRole
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postCustomRole(customRolePost: CustomRolePost) : CustomRole {
        val localVarResponse = postCustomRoleWithHttpInfo(customRolePost = customRolePost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CustomRole
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create custom role
     * Create a new custom role
     * @param customRolePost 
     * @return ApiResponse<CustomRole?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postCustomRoleWithHttpInfo(customRolePost: CustomRolePost) : ApiResponse<CustomRole?> {
        val localVariableConfig = postCustomRoleRequestConfig(customRolePost = customRolePost)

        return request<CustomRolePost, CustomRole>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postCustomRole
     *
     * @param customRolePost 
     * @return RequestConfig
     */
    fun postCustomRoleRequestConfig(customRolePost: CustomRolePost) : RequestConfig<CustomRolePost> {
        val localVariableBody = customRolePost
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/roles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
