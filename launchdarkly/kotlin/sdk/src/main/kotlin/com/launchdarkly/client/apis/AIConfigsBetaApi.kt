/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.AIConfig
import com.launchdarkly.client.models.AIConfigPatch
import com.launchdarkly.client.models.AIConfigPost
import com.launchdarkly.client.models.AIConfigVariation
import com.launchdarkly.client.models.AIConfigVariationPatch
import com.launchdarkly.client.models.AIConfigVariationPost
import com.launchdarkly.client.models.AIConfigVariationsResponse
import com.launchdarkly.client.models.AIConfigs
import com.launchdarkly.client.models.Error
import com.launchdarkly.client.models.MetricByVariation
import com.launchdarkly.client.models.Metrics
import com.launchdarkly.client.models.ModelConfig
import com.launchdarkly.client.models.ModelConfigPost

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class AIConfigsBetaApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionDeleteAIConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Delete AI config
     * Delete an existing AI config.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAIConfig(ldAPIVersion: LdAPIVersionDeleteAIConfig, projectKey: kotlin.String, configKey: kotlin.String) : Unit {
        val localVarResponse = deleteAIConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete AI config
     * Delete an existing AI config.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAIConfigWithHttpInfo(ldAPIVersion: LdAPIVersionDeleteAIConfig, projectKey: kotlin.String, configKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteAIConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAIConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @return RequestConfig
     */
    fun deleteAIConfigRequestConfig(ldAPIVersion: LdAPIVersionDeleteAIConfig, projectKey: kotlin.String, configKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionDeleteAIConfigVariation(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Delete AI config variation
     * Delete a specific variation of an AI config by config key and variation key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteAIConfigVariation(ldAPIVersion: LdAPIVersionDeleteAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String) : Unit {
        val localVarResponse = deleteAIConfigVariationWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, variationKey = variationKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete AI config variation
     * Delete a specific variation of an AI config by config key and variation key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteAIConfigVariationWithHttpInfo(ldAPIVersion: LdAPIVersionDeleteAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteAIConfigVariationRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, variationKey = variationKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteAIConfigVariation
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @return RequestConfig
     */
    fun deleteAIConfigVariationRequestConfig(ldAPIVersion: LdAPIVersionDeleteAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())).replace("{"+"variationKey"+"}", encodeURIComponent(variationKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionDeleteModelConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Delete an AI model config
     * Delete an AI model config.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigKey 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteModelConfig(ldAPIVersion: LdAPIVersionDeleteModelConfig, projectKey: kotlin.String, modelConfigKey: kotlin.String) : Unit {
        val localVarResponse = deleteModelConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, modelConfigKey = modelConfigKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete an AI model config
     * Delete an AI model config.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigKey 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteModelConfigWithHttpInfo(ldAPIVersion: LdAPIVersionDeleteModelConfig, projectKey: kotlin.String, modelConfigKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteModelConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, modelConfigKey = modelConfigKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteModelConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigKey 
     * @return RequestConfig
     */
    fun deleteModelConfigRequestConfig(ldAPIVersion: LdAPIVersionDeleteModelConfig, projectKey: kotlin.String, modelConfigKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/projects/{projectKey}/ai-configs/model-configs/{modelConfigKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"modelConfigKey"+"}", encodeURIComponent(modelConfigKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionGetAIConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get AI config
     * Retrieve a specific AI config by its key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @return AIConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAIConfig(ldAPIVersion: LdAPIVersionGetAIConfig, projectKey: kotlin.String, configKey: kotlin.String) : AIConfig {
        val localVarResponse = getAIConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get AI config
     * Retrieve a specific AI config by its key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @return ApiResponse<AIConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAIConfigWithHttpInfo(ldAPIVersion: LdAPIVersionGetAIConfig, projectKey: kotlin.String, configKey: kotlin.String) : ApiResponse<AIConfig?> {
        val localVariableConfig = getAIConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey)

        return request<Unit, AIConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAIConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @return RequestConfig
     */
    fun getAIConfigRequestConfig(ldAPIVersion: LdAPIVersionGetAIConfig, projectKey: kotlin.String, configKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionGetAIConfigMetrics(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get AI config metrics
     * Retrieve usage metrics for an AI config by config key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param from The starting time, as milliseconds since epoch (inclusive).
     * @param to The ending time, as milliseconds since epoch (exclusive). May not be more than 100 days after &#x60;from&#x60;.
     * @param env An environment key. Only metrics from this environment will be included.
     * @return Metrics
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAIConfigMetrics(ldAPIVersion: LdAPIVersionGetAIConfigMetrics, projectKey: kotlin.String, configKey: kotlin.String, from: kotlin.Int, to: kotlin.Int, env: kotlin.String) : Metrics {
        val localVarResponse = getAIConfigMetricsWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, from = from, to = to, env = env)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Metrics
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get AI config metrics
     * Retrieve usage metrics for an AI config by config key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param from The starting time, as milliseconds since epoch (inclusive).
     * @param to The ending time, as milliseconds since epoch (exclusive). May not be more than 100 days after &#x60;from&#x60;.
     * @param env An environment key. Only metrics from this environment will be included.
     * @return ApiResponse<Metrics?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAIConfigMetricsWithHttpInfo(ldAPIVersion: LdAPIVersionGetAIConfigMetrics, projectKey: kotlin.String, configKey: kotlin.String, from: kotlin.Int, to: kotlin.Int, env: kotlin.String) : ApiResponse<Metrics?> {
        val localVariableConfig = getAIConfigMetricsRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, from = from, to = to, env = env)

        return request<Unit, Metrics>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAIConfigMetrics
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param from The starting time, as milliseconds since epoch (inclusive).
     * @param to The ending time, as milliseconds since epoch (exclusive). May not be more than 100 days after &#x60;from&#x60;.
     * @param env An environment key. Only metrics from this environment will be included.
     * @return RequestConfig
     */
    fun getAIConfigMetricsRequestConfig(ldAPIVersion: LdAPIVersionGetAIConfigMetrics, projectKey: kotlin.String, configKey: kotlin.String, from: kotlin.Int, to: kotlin.Int, env: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("from", listOf(from.toString()))
                put("to", listOf(to.toString()))
                put("env", listOf(env.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/metrics".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionGetAIConfigMetricsByVariation(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get AI config metrics by variation
     * Retrieve usage metrics for an AI config by config key, with results split by variation.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param from The starting time, as milliseconds since epoch (inclusive).
     * @param to The ending time, as milliseconds since epoch (exclusive). May not be more than 100 days after &#x60;from&#x60;.
     * @param env An environment key. Only metrics from this environment will be included.
     * @return kotlin.collections.List<MetricByVariation>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAIConfigMetricsByVariation(ldAPIVersion: LdAPIVersionGetAIConfigMetricsByVariation, projectKey: kotlin.String, configKey: kotlin.String, from: kotlin.Int, to: kotlin.Int, env: kotlin.String) : kotlin.collections.List<MetricByVariation> {
        val localVarResponse = getAIConfigMetricsByVariationWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, from = from, to = to, env = env)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<MetricByVariation>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get AI config metrics by variation
     * Retrieve usage metrics for an AI config by config key, with results split by variation.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param from The starting time, as milliseconds since epoch (inclusive).
     * @param to The ending time, as milliseconds since epoch (exclusive). May not be more than 100 days after &#x60;from&#x60;.
     * @param env An environment key. Only metrics from this environment will be included.
     * @return ApiResponse<kotlin.collections.List<MetricByVariation>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAIConfigMetricsByVariationWithHttpInfo(ldAPIVersion: LdAPIVersionGetAIConfigMetricsByVariation, projectKey: kotlin.String, configKey: kotlin.String, from: kotlin.Int, to: kotlin.Int, env: kotlin.String) : ApiResponse<kotlin.collections.List<MetricByVariation>?> {
        val localVariableConfig = getAIConfigMetricsByVariationRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, from = from, to = to, env = env)

        return request<Unit, kotlin.collections.List<MetricByVariation>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAIConfigMetricsByVariation
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param from The starting time, as milliseconds since epoch (inclusive).
     * @param to The ending time, as milliseconds since epoch (exclusive). May not be more than 100 days after &#x60;from&#x60;.
     * @param env An environment key. Only metrics from this environment will be included.
     * @return RequestConfig
     */
    fun getAIConfigMetricsByVariationRequestConfig(ldAPIVersion: LdAPIVersionGetAIConfigMetricsByVariation, projectKey: kotlin.String, configKey: kotlin.String, from: kotlin.Int, to: kotlin.Int, env: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("from", listOf(from.toString()))
                put("to", listOf(to.toString()))
                put("env", listOf(env.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/metrics-by-variation".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionGetAIConfigVariation(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get AI config variation
     * Get an AI config variation by key. The response includes all variation versions for the given variation key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @return AIConfigVariationsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAIConfigVariation(ldAPIVersion: LdAPIVersionGetAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String) : AIConfigVariationsResponse {
        val localVarResponse = getAIConfigVariationWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, variationKey = variationKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfigVariationsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get AI config variation
     * Get an AI config variation by key. The response includes all variation versions for the given variation key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @return ApiResponse<AIConfigVariationsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAIConfigVariationWithHttpInfo(ldAPIVersion: LdAPIVersionGetAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String) : ApiResponse<AIConfigVariationsResponse?> {
        val localVariableConfig = getAIConfigVariationRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, variationKey = variationKey)

        return request<Unit, AIConfigVariationsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAIConfigVariation
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @return RequestConfig
     */
    fun getAIConfigVariationRequestConfig(ldAPIVersion: LdAPIVersionGetAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())).replace("{"+"variationKey"+"}", encodeURIComponent(variationKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionGetAIConfigs(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * List AI configs
     * Get a list of all AI configs in the given project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param sort A sort to apply to the list of AI configs. (optional)
     * @param limit The number of AI configs to return. (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @param filter A filter to apply to the list of AI configs. (optional)
     * @return AIConfigs
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAIConfigs(ldAPIVersion: LdAPIVersionGetAIConfigs, projectKey: kotlin.String, sort: kotlin.String? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null, filter: kotlin.String? = null) : AIConfigs {
        val localVarResponse = getAIConfigsWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, sort = sort, limit = limit, offset = offset, filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfigs
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List AI configs
     * Get a list of all AI configs in the given project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param sort A sort to apply to the list of AI configs. (optional)
     * @param limit The number of AI configs to return. (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @param filter A filter to apply to the list of AI configs. (optional)
     * @return ApiResponse<AIConfigs?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAIConfigsWithHttpInfo(ldAPIVersion: LdAPIVersionGetAIConfigs, projectKey: kotlin.String, sort: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, filter: kotlin.String?) : ApiResponse<AIConfigs?> {
        val localVariableConfig = getAIConfigsRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, sort = sort, limit = limit, offset = offset, filter = filter)

        return request<Unit, AIConfigs>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAIConfigs
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param sort A sort to apply to the list of AI configs. (optional)
     * @param limit The number of AI configs to return. (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @param filter A filter to apply to the list of AI configs. (optional)
     * @return RequestConfig
     */
    fun getAIConfigsRequestConfig(ldAPIVersion: LdAPIVersionGetAIConfigs, projectKey: kotlin.String, sort: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, filter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionGetModelConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get AI model config
     * Get an AI model config by key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigKey 
     * @return ModelConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getModelConfig(ldAPIVersion: LdAPIVersionGetModelConfig, projectKey: kotlin.String, modelConfigKey: kotlin.String) : ModelConfig {
        val localVarResponse = getModelConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, modelConfigKey = modelConfigKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get AI model config
     * Get an AI model config by key.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigKey 
     * @return ApiResponse<ModelConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getModelConfigWithHttpInfo(ldAPIVersion: LdAPIVersionGetModelConfig, projectKey: kotlin.String, modelConfigKey: kotlin.String) : ApiResponse<ModelConfig?> {
        val localVariableConfig = getModelConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, modelConfigKey = modelConfigKey)

        return request<Unit, ModelConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getModelConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigKey 
     * @return RequestConfig
     */
    fun getModelConfigRequestConfig(ldAPIVersion: LdAPIVersionGetModelConfig, projectKey: kotlin.String, modelConfigKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs/model-configs/{modelConfigKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"modelConfigKey"+"}", encodeURIComponent(modelConfigKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionListModelConfigs(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * List AI model configs
     * Get all AI model configs for a project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @return kotlin.collections.List<ModelConfig>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listModelConfigs(ldAPIVersion: LdAPIVersionListModelConfigs, projectKey: kotlin.String) : kotlin.collections.List<ModelConfig> {
        val localVarResponse = listModelConfigsWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ModelConfig>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List AI model configs
     * Get all AI model configs for a project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @return ApiResponse<kotlin.collections.List<ModelConfig>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listModelConfigsWithHttpInfo(ldAPIVersion: LdAPIVersionListModelConfigs, projectKey: kotlin.String) : ApiResponse<kotlin.collections.List<ModelConfig>?> {
        val localVariableConfig = listModelConfigsRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey)

        return request<Unit, kotlin.collections.List<ModelConfig>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listModelConfigs
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @return RequestConfig
     */
    fun listModelConfigsRequestConfig(ldAPIVersion: LdAPIVersionListModelConfigs, projectKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/ai-configs/model-configs".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionPatchAIConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Update AI config
     * Edit an existing AI config.  The request body must be a JSON object of the fields to update. The values you include replace the existing values for the fields.  Here&#39;s an example:   &#x60;&#x60;&#x60;     {       \&quot;description\&quot;: \&quot;Example updated description\&quot;,       \&quot;tags\&quot;: [\&quot;new-tag\&quot;]     }   &#x60;&#x60;&#x60; 
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param aiConfigPatch AI config object to update (optional)
     * @return AIConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchAIConfig(ldAPIVersion: LdAPIVersionPatchAIConfig, projectKey: kotlin.String, configKey: kotlin.String, aiConfigPatch: AIConfigPatch? = null) : AIConfig {
        val localVarResponse = patchAIConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, aiConfigPatch = aiConfigPatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update AI config
     * Edit an existing AI config.  The request body must be a JSON object of the fields to update. The values you include replace the existing values for the fields.  Here&#39;s an example:   &#x60;&#x60;&#x60;     {       \&quot;description\&quot;: \&quot;Example updated description\&quot;,       \&quot;tags\&quot;: [\&quot;new-tag\&quot;]     }   &#x60;&#x60;&#x60; 
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param aiConfigPatch AI config object to update (optional)
     * @return ApiResponse<AIConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchAIConfigWithHttpInfo(ldAPIVersion: LdAPIVersionPatchAIConfig, projectKey: kotlin.String, configKey: kotlin.String, aiConfigPatch: AIConfigPatch?) : ApiResponse<AIConfig?> {
        val localVariableConfig = patchAIConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, aiConfigPatch = aiConfigPatch)

        return request<AIConfigPatch, AIConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchAIConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param aiConfigPatch AI config object to update (optional)
     * @return RequestConfig
     */
    fun patchAIConfigRequestConfig(ldAPIVersion: LdAPIVersionPatchAIConfig, projectKey: kotlin.String, configKey: kotlin.String, aiConfigPatch: AIConfigPatch?) : RequestConfig<AIConfigPatch> {
        val localVariableBody = aiConfigPatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionPatchAIConfigVariation(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Update AI config variation
     * Edit an existing variation of an AI config. This creates a new version of the variation.  The request body must be a JSON object of the fields to update. The values you include replace the existing values for the fields.  Here&#39;s an example: &#x60;&#x60;&#x60;   {     \&quot;messages\&quot;: [       {         \&quot;role\&quot;: \&quot;system\&quot;,         \&quot;content\&quot;: \&quot;The new message\&quot;       }     ]   } &#x60;&#x60;&#x60; 
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @param aiConfigVariationPatch AI config variation object to update (optional)
     * @return AIConfigVariation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchAIConfigVariation(ldAPIVersion: LdAPIVersionPatchAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String, aiConfigVariationPatch: AIConfigVariationPatch? = null) : AIConfigVariation {
        val localVarResponse = patchAIConfigVariationWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, variationKey = variationKey, aiConfigVariationPatch = aiConfigVariationPatch)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfigVariation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update AI config variation
     * Edit an existing variation of an AI config. This creates a new version of the variation.  The request body must be a JSON object of the fields to update. The values you include replace the existing values for the fields.  Here&#39;s an example: &#x60;&#x60;&#x60;   {     \&quot;messages\&quot;: [       {         \&quot;role\&quot;: \&quot;system\&quot;,         \&quot;content\&quot;: \&quot;The new message\&quot;       }     ]   } &#x60;&#x60;&#x60; 
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @param aiConfigVariationPatch AI config variation object to update (optional)
     * @return ApiResponse<AIConfigVariation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchAIConfigVariationWithHttpInfo(ldAPIVersion: LdAPIVersionPatchAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String, aiConfigVariationPatch: AIConfigVariationPatch?) : ApiResponse<AIConfigVariation?> {
        val localVariableConfig = patchAIConfigVariationRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, variationKey = variationKey, aiConfigVariationPatch = aiConfigVariationPatch)

        return request<AIConfigVariationPatch, AIConfigVariation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchAIConfigVariation
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param variationKey 
     * @param aiConfigVariationPatch AI config variation object to update (optional)
     * @return RequestConfig
     */
    fun patchAIConfigVariationRequestConfig(ldAPIVersion: LdAPIVersionPatchAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, variationKey: kotlin.String, aiConfigVariationPatch: AIConfigVariationPatch?) : RequestConfig<AIConfigVariationPatch> {
        val localVariableBody = aiConfigVariationPatch
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations/{variationKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())).replace("{"+"variationKey"+"}", encodeURIComponent(variationKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionPostAIConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Create new AI config
     * Create a new AI config within the given project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param aiConfigPost AI config object to create
     * @return AIConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postAIConfig(ldAPIVersion: LdAPIVersionPostAIConfig, projectKey: kotlin.String, aiConfigPost: AIConfigPost) : AIConfig {
        val localVarResponse = postAIConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, aiConfigPost = aiConfigPost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create new AI config
     * Create a new AI config within the given project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param aiConfigPost AI config object to create
     * @return ApiResponse<AIConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postAIConfigWithHttpInfo(ldAPIVersion: LdAPIVersionPostAIConfig, projectKey: kotlin.String, aiConfigPost: AIConfigPost) : ApiResponse<AIConfig?> {
        val localVariableConfig = postAIConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, aiConfigPost = aiConfigPost)

        return request<AIConfigPost, AIConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postAIConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param aiConfigPost AI config object to create
     * @return RequestConfig
     */
    fun postAIConfigRequestConfig(ldAPIVersion: LdAPIVersionPostAIConfig, projectKey: kotlin.String, aiConfigPost: AIConfigPost) : RequestConfig<AIConfigPost> {
        val localVariableBody = aiConfigPost
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/ai-configs".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionPostAIConfigVariation(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Create AI config variation
     * Create a new variation for a given AI config.  The &lt;code&gt;model&lt;/code&gt; in the request body requires a &lt;code&gt;modelName&lt;/code&gt; and &lt;code&gt;parameters&lt;/code&gt;, for example:  &#x60;&#x60;&#x60;   \&quot;model\&quot;: {     \&quot;modelName\&quot;: \&quot;claude-3-opus-20240229\&quot;,     \&quot;parameters\&quot;: {       \&quot;max_tokens\&quot;: 1024     }   } &#x60;&#x60;&#x60; 
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param aiConfigVariationPost AI config variation object to create
     * @return AIConfigVariation
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postAIConfigVariation(ldAPIVersion: LdAPIVersionPostAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, aiConfigVariationPost: AIConfigVariationPost) : AIConfigVariation {
        val localVarResponse = postAIConfigVariationWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, aiConfigVariationPost = aiConfigVariationPost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AIConfigVariation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create AI config variation
     * Create a new variation for a given AI config.  The &lt;code&gt;model&lt;/code&gt; in the request body requires a &lt;code&gt;modelName&lt;/code&gt; and &lt;code&gt;parameters&lt;/code&gt;, for example:  &#x60;&#x60;&#x60;   \&quot;model\&quot;: {     \&quot;modelName\&quot;: \&quot;claude-3-opus-20240229\&quot;,     \&quot;parameters\&quot;: {       \&quot;max_tokens\&quot;: 1024     }   } &#x60;&#x60;&#x60; 
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param aiConfigVariationPost AI config variation object to create
     * @return ApiResponse<AIConfigVariation?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postAIConfigVariationWithHttpInfo(ldAPIVersion: LdAPIVersionPostAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, aiConfigVariationPost: AIConfigVariationPost) : ApiResponse<AIConfigVariation?> {
        val localVariableConfig = postAIConfigVariationRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, configKey = configKey, aiConfigVariationPost = aiConfigVariationPost)

        return request<AIConfigVariationPost, AIConfigVariation>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postAIConfigVariation
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param configKey 
     * @param aiConfigVariationPost AI config variation object to create
     * @return RequestConfig
     */
    fun postAIConfigVariationRequestConfig(ldAPIVersion: LdAPIVersionPostAIConfigVariation, projectKey: kotlin.String, configKey: kotlin.String, aiConfigVariationPost: AIConfigVariationPost) : RequestConfig<AIConfigVariationPost> {
        val localVariableBody = aiConfigVariationPost
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/ai-configs/{configKey}/variations".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"configKey"+"}", encodeURIComponent(configKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ldAPIVersion
     */
     enum class LdAPIVersionPostModelConfig(val value: kotlin.String) {
         @Json(name = "beta") beta("beta");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Create an AI model config
     * Create an AI model config. You can use this in any variation for any AI config in your project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigPost AI model config object to create
     * @return ModelConfig
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postModelConfig(ldAPIVersion: LdAPIVersionPostModelConfig, projectKey: kotlin.String, modelConfigPost: ModelConfigPost) : ModelConfig {
        val localVarResponse = postModelConfigWithHttpInfo(ldAPIVersion = ldAPIVersion, projectKey = projectKey, modelConfigPost = modelConfigPost)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ModelConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create an AI model config
     * Create an AI model config. You can use this in any variation for any AI config in your project.
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigPost AI model config object to create
     * @return ApiResponse<ModelConfig?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postModelConfigWithHttpInfo(ldAPIVersion: LdAPIVersionPostModelConfig, projectKey: kotlin.String, modelConfigPost: ModelConfigPost) : ApiResponse<ModelConfig?> {
        val localVariableConfig = postModelConfigRequestConfig(ldAPIVersion = ldAPIVersion, projectKey = projectKey, modelConfigPost = modelConfigPost)

        return request<ModelConfigPost, ModelConfig>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postModelConfig
     *
     * @param ldAPIVersion Version of the endpoint.
     * @param projectKey 
     * @param modelConfigPost AI model config object to create
     * @return RequestConfig
     */
    fun postModelConfigRequestConfig(ldAPIVersion: LdAPIVersionPostModelConfig, projectKey: kotlin.String, modelConfigPost: ModelConfigPost) : RequestConfig<ModelConfigPost> {
        val localVariableBody = modelConfigPost
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        ldAPIVersion.apply { localVariableHeaders["LD-API-Version"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/ai-configs/model-configs".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
