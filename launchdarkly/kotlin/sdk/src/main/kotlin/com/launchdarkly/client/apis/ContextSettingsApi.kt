/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep
import com.launchdarkly.client.models.ValuePut

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class ContextSettingsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Update flag settings for context
     *  Enable or disable a feature flag for a context based on its context kind and key.  Omitting the &#x60;setting&#x60; attribute from the request body, or including a &#x60;setting&#x60; of &#x60;null&#x60;, erases the current setting for a context.  If you previously patched the flag, and the patch included the context&#39;s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the combination of the context&#39;s key and kind before, it calculates the flag values based on the context kind and key. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param contextKind The context kind
     * @param contextKey The context key
     * @param featureFlagKey The feature flag key
     * @param valuePut 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putContextFlagSetting(projectKey: kotlin.String, environmentKey: kotlin.String, contextKind: kotlin.String, contextKey: kotlin.String, featureFlagKey: kotlin.String, valuePut: ValuePut) : Unit {
        val localVarResponse = putContextFlagSettingWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, contextKind = contextKind, contextKey = contextKey, featureFlagKey = featureFlagKey, valuePut = valuePut)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update flag settings for context
     *  Enable or disable a feature flag for a context based on its context kind and key.  Omitting the &#x60;setting&#x60; attribute from the request body, or including a &#x60;setting&#x60; of &#x60;null&#x60;, erases the current setting for a context.  If you previously patched the flag, and the patch included the context&#39;s data, LaunchDarkly continues to use that data. If LaunchDarkly has never encountered the combination of the context&#39;s key and kind before, it calculates the flag values based on the context kind and key. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param contextKind The context kind
     * @param contextKey The context key
     * @param featureFlagKey The feature flag key
     * @param valuePut 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun putContextFlagSettingWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, contextKind: kotlin.String, contextKey: kotlin.String, featureFlagKey: kotlin.String, valuePut: ValuePut) : ApiResponse<Unit?> {
        val localVariableConfig = putContextFlagSettingRequestConfig(projectKey = projectKey, environmentKey = environmentKey, contextKind = contextKind, contextKey = contextKey, featureFlagKey = featureFlagKey, valuePut = valuePut)

        return request<ValuePut, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putContextFlagSetting
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param contextKind The context kind
     * @param contextKey The context key
     * @param featureFlagKey The feature flag key
     * @param valuePut 
     * @return RequestConfig
     */
    fun putContextFlagSettingRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, contextKind: kotlin.String, contextKey: kotlin.String, featureFlagKey: kotlin.String, valuePut: ValuePut) : RequestConfig<ValuePut> {
        val localVariableBody = valuePut
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/contexts/{contextKind}/{contextKey}/flags/{featureFlagKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"contextKind"+"}", encodeURIComponent(contextKind.toString())).replace("{"+"contextKey"+"}", encodeURIComponent(contextKey.toString())).replace("{"+"featureFlagKey"+"}", encodeURIComponent(featureFlagKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
