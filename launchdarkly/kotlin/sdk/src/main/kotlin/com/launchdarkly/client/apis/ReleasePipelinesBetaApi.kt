/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.CreateReleasePipelineInput
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.ReleasePipeline
import com.launchdarkly.client.models.ReleasePipelineCollection
import com.launchdarkly.client.models.ReleaseProgressionCollection
import com.launchdarkly.client.models.StatusConflictErrorRep
import com.launchdarkly.client.models.UpdateReleasePipelineInput

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class ReleasePipelinesBetaApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Delete release pipeline
     * Deletes a release pipeline.  You cannot delete the default release pipeline.  If you want to delete a release pipeline that is currently the default, create a second release pipeline and set it as the default. Then delete the first release pipeline. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the &#x60;defaultReleasePipelineKey&#x60;. 
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteReleasePipeline(projectKey: kotlin.String, pipelineKey: kotlin.String) : Unit {
        val localVarResponse = deleteReleasePipelineWithHttpInfo(projectKey = projectKey, pipelineKey = pipelineKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete release pipeline
     * Deletes a release pipeline.  You cannot delete the default release pipeline.  If you want to delete a release pipeline that is currently the default, create a second release pipeline and set it as the default. Then delete the first release pipeline. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the &#x60;defaultReleasePipelineKey&#x60;. 
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteReleasePipelineWithHttpInfo(projectKey: kotlin.String, pipelineKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteReleasePipelineRequestConfig(projectKey = projectKey, pipelineKey = pipelineKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteReleasePipeline
     *
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @return RequestConfig
     */
    fun deleteReleasePipelineRequestConfig(projectKey: kotlin.String, pipelineKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"pipelineKey"+"}", encodeURIComponent(pipelineKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get all release pipelines
     * Get all release pipelines for a project.  ### Filtering release pipelines  LaunchDarkly supports the following fields for filters:  - &#x60;query&#x60; is a string that matches against the release pipeline &#x60;key&#x60;, &#x60;name&#x60;, and &#x60;description&#x60;. It is not case sensitive. For example: &#x60;?filter&#x3D;query:examplePipeline&#x60;.  - &#x60;env&#x60; is a string that matches an environment key. For example: &#x60;?filter&#x3D;env:production&#x60;. 
     * @param projectKey The project key
     * @param filter A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields. (optional)
     * @param limit The maximum number of items to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ReleasePipelineCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAllReleasePipelines(projectKey: kotlin.String, filter: kotlin.String? = null, limit: kotlin.Long? = null, offset: kotlin.Long? = null) : ReleasePipelineCollection {
        val localVarResponse = getAllReleasePipelinesWithHttpInfo(projectKey = projectKey, filter = filter, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReleasePipelineCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get all release pipelines
     * Get all release pipelines for a project.  ### Filtering release pipelines  LaunchDarkly supports the following fields for filters:  - &#x60;query&#x60; is a string that matches against the release pipeline &#x60;key&#x60;, &#x60;name&#x60;, and &#x60;description&#x60;. It is not case sensitive. For example: &#x60;?filter&#x3D;query:examplePipeline&#x60;.  - &#x60;env&#x60; is a string that matches an environment key. For example: &#x60;?filter&#x3D;env:production&#x60;. 
     * @param projectKey The project key
     * @param filter A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields. (optional)
     * @param limit The maximum number of items to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ApiResponse<ReleasePipelineCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllReleasePipelinesWithHttpInfo(projectKey: kotlin.String, filter: kotlin.String?, limit: kotlin.Long?, offset: kotlin.Long?) : ApiResponse<ReleasePipelineCollection?> {
        val localVariableConfig = getAllReleasePipelinesRequestConfig(projectKey = projectKey, filter = filter, limit = limit, offset = offset)

        return request<Unit, ReleasePipelineCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllReleasePipelines
     *
     * @param projectKey The project key
     * @param filter A comma-separated list of filters. Each filter is of the form field:value. Read the endpoint description for a full list of available filter fields. (optional)
     * @param limit The maximum number of items to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return RequestConfig
     */
    fun getAllReleasePipelinesRequestConfig(projectKey: kotlin.String, filter: kotlin.String?, limit: kotlin.Long?, offset: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/release-pipelines".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get release progressions for release pipeline
     * Get details on the progression of all releases, across all flags, for a release pipeline
     * @param projectKey The project key
     * @param pipelineKey The pipeline key
     * @param filter Accepts filter by &#x60;status&#x60; and &#x60;activePhaseId&#x60;. &#x60;status&#x60; can take a value of &#x60;completed&#x60; or &#x60;active&#x60;. &#x60;activePhaseId&#x60; takes a UUID and will filter results down to releases active on the specified phase. Providing &#x60;status equals completed&#x60; along with an &#x60;activePhaseId&#x60; filter will return an error as they are disjoint sets of data. The combination of &#x60;status equals active&#x60; and &#x60;activePhaseId&#x60; will return the same results as &#x60;activePhaseId&#x60; alone. (optional)
     * @param limit The maximum number of items to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ReleaseProgressionCollection
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAllReleaseProgressionsForReleasePipeline(projectKey: kotlin.String, pipelineKey: kotlin.String, filter: kotlin.String? = null, limit: kotlin.Long? = null, offset: kotlin.Long? = null) : ReleaseProgressionCollection {
        val localVarResponse = getAllReleaseProgressionsForReleasePipelineWithHttpInfo(projectKey = projectKey, pipelineKey = pipelineKey, filter = filter, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReleaseProgressionCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get release progressions for release pipeline
     * Get details on the progression of all releases, across all flags, for a release pipeline
     * @param projectKey The project key
     * @param pipelineKey The pipeline key
     * @param filter Accepts filter by &#x60;status&#x60; and &#x60;activePhaseId&#x60;. &#x60;status&#x60; can take a value of &#x60;completed&#x60; or &#x60;active&#x60;. &#x60;activePhaseId&#x60; takes a UUID and will filter results down to releases active on the specified phase. Providing &#x60;status equals completed&#x60; along with an &#x60;activePhaseId&#x60; filter will return an error as they are disjoint sets of data. The combination of &#x60;status equals active&#x60; and &#x60;activePhaseId&#x60; will return the same results as &#x60;activePhaseId&#x60; alone. (optional)
     * @param limit The maximum number of items to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return ApiResponse<ReleaseProgressionCollection?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllReleaseProgressionsForReleasePipelineWithHttpInfo(projectKey: kotlin.String, pipelineKey: kotlin.String, filter: kotlin.String?, limit: kotlin.Long?, offset: kotlin.Long?) : ApiResponse<ReleaseProgressionCollection?> {
        val localVariableConfig = getAllReleaseProgressionsForReleasePipelineRequestConfig(projectKey = projectKey, pipelineKey = pipelineKey, filter = filter, limit = limit, offset = offset)

        return request<Unit, ReleaseProgressionCollection>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getAllReleaseProgressionsForReleasePipeline
     *
     * @param projectKey The project key
     * @param pipelineKey The pipeline key
     * @param filter Accepts filter by &#x60;status&#x60; and &#x60;activePhaseId&#x60;. &#x60;status&#x60; can take a value of &#x60;completed&#x60; or &#x60;active&#x60;. &#x60;activePhaseId&#x60; takes a UUID and will filter results down to releases active on the specified phase. Providing &#x60;status equals completed&#x60; along with an &#x60;activePhaseId&#x60; filter will return an error as they are disjoint sets of data. The combination of &#x60;status equals active&#x60; and &#x60;activePhaseId&#x60; will return the same results as &#x60;activePhaseId&#x60; alone. (optional)
     * @param limit The maximum number of items to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Defaults to 0. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @return RequestConfig
     */
    fun getAllReleaseProgressionsForReleasePipelineRequestConfig(projectKey: kotlin.String, pipelineKey: kotlin.String, filter: kotlin.String?, limit: kotlin.Long?, offset: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}/releases".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"pipelineKey"+"}", encodeURIComponent(pipelineKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get release pipeline by key
     * Get a release pipeline by key
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @return ReleasePipeline
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getReleasePipelineByKey(projectKey: kotlin.String, pipelineKey: kotlin.String) : ReleasePipeline {
        val localVarResponse = getReleasePipelineByKeyWithHttpInfo(projectKey = projectKey, pipelineKey = pipelineKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReleasePipeline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get release pipeline by key
     * Get a release pipeline by key
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @return ApiResponse<ReleasePipeline?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getReleasePipelineByKeyWithHttpInfo(projectKey: kotlin.String, pipelineKey: kotlin.String) : ApiResponse<ReleasePipeline?> {
        val localVariableConfig = getReleasePipelineByKeyRequestConfig(projectKey = projectKey, pipelineKey = pipelineKey)

        return request<Unit, ReleasePipeline>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getReleasePipelineByKey
     *
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @return RequestConfig
     */
    fun getReleasePipelineByKeyRequestConfig(projectKey: kotlin.String, pipelineKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"pipelineKey"+"}", encodeURIComponent(pipelineKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create a release pipeline
     * Creates a new release pipeline.  The first release pipeline you create is automatically set as the default release pipeline for your project. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the &#x60;defaultReleasePipelineKey&#x60;.  You can create up to 20 release pipelines per project. 
     * @param projectKey The project key
     * @param createReleasePipelineInput 
     * @return ReleasePipeline
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postReleasePipeline(projectKey: kotlin.String, createReleasePipelineInput: CreateReleasePipelineInput) : ReleasePipeline {
        val localVarResponse = postReleasePipelineWithHttpInfo(projectKey = projectKey, createReleasePipelineInput = createReleasePipelineInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReleasePipeline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create a release pipeline
     * Creates a new release pipeline.  The first release pipeline you create is automatically set as the default release pipeline for your project. To change the default release pipeline, use the [Update project](/tag/Projects#operation/patchProject) API to set the &#x60;defaultReleasePipelineKey&#x60;.  You can create up to 20 release pipelines per project. 
     * @param projectKey The project key
     * @param createReleasePipelineInput 
     * @return ApiResponse<ReleasePipeline?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postReleasePipelineWithHttpInfo(projectKey: kotlin.String, createReleasePipelineInput: CreateReleasePipelineInput) : ApiResponse<ReleasePipeline?> {
        val localVariableConfig = postReleasePipelineRequestConfig(projectKey = projectKey, createReleasePipelineInput = createReleasePipelineInput)

        return request<CreateReleasePipelineInput, ReleasePipeline>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postReleasePipeline
     *
     * @param projectKey The project key
     * @param createReleasePipelineInput 
     * @return RequestConfig
     */
    fun postReleasePipelineRequestConfig(projectKey: kotlin.String, createReleasePipelineInput: CreateReleasePipelineInput) : RequestConfig<CreateReleasePipelineInput> {
        val localVariableBody = createReleasePipelineInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/release-pipelines".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update a release pipeline
     * Updates a release pipeline.
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @param updateReleasePipelineInput 
     * @return ReleasePipeline
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun putReleasePipeline(projectKey: kotlin.String, pipelineKey: kotlin.String, updateReleasePipelineInput: UpdateReleasePipelineInput) : ReleasePipeline {
        val localVarResponse = putReleasePipelineWithHttpInfo(projectKey = projectKey, pipelineKey = pipelineKey, updateReleasePipelineInput = updateReleasePipelineInput)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReleasePipeline
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update a release pipeline
     * Updates a release pipeline.
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @param updateReleasePipelineInput 
     * @return ApiResponse<ReleasePipeline?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun putReleasePipelineWithHttpInfo(projectKey: kotlin.String, pipelineKey: kotlin.String, updateReleasePipelineInput: UpdateReleasePipelineInput) : ApiResponse<ReleasePipeline?> {
        val localVariableConfig = putReleasePipelineRequestConfig(projectKey = projectKey, pipelineKey = pipelineKey, updateReleasePipelineInput = updateReleasePipelineInput)

        return request<UpdateReleasePipelineInput, ReleasePipeline>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation putReleasePipeline
     *
     * @param projectKey The project key
     * @param pipelineKey The release pipeline key
     * @param updateReleasePipelineInput 
     * @return RequestConfig
     */
    fun putReleasePipelineRequestConfig(projectKey: kotlin.String, pipelineKey: kotlin.String, updateReleasePipelineInput: UpdateReleasePipelineInput) : RequestConfig<UpdateReleasePipelineInput> {
        val localVariableBody = updateReleasePipelineInput
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v2/projects/{projectKey}/release-pipelines/{pipelineKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"pipelineKey"+"}", encodeURIComponent(pipelineKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
