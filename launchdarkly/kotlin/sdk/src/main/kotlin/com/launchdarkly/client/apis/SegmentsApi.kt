/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.launchdarkly.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import com.launchdarkly.client.models.BigSegmentTarget
import com.launchdarkly.client.models.ContextInstanceSegmentMemberships
import com.launchdarkly.client.models.ExpiringTargetGetResponse
import com.launchdarkly.client.models.ExpiringTargetPatchResponse
import com.launchdarkly.client.models.ExpiringUserTargetGetResponse
import com.launchdarkly.client.models.ExpiringUserTargetPatchResponse
import com.launchdarkly.client.models.Export
import com.launchdarkly.client.models.ForbiddenErrorRep
import com.launchdarkly.client.models.Import
import com.launchdarkly.client.models.InvalidRequestErrorRep
import com.launchdarkly.client.models.NotFoundErrorRep
import com.launchdarkly.client.models.PatchSegmentExpiringTargetInputRep
import com.launchdarkly.client.models.PatchSegmentRequest
import com.launchdarkly.client.models.PatchWithComment
import com.launchdarkly.client.models.RateLimitedErrorRep
import com.launchdarkly.client.models.SegmentBody
import com.launchdarkly.client.models.SegmentUserState
import com.launchdarkly.client.models.StatusConflictErrorRep
import com.launchdarkly.client.models.UnauthorizedErrorRep
import com.launchdarkly.client.models.UserSegment
import com.launchdarkly.client.models.UserSegments

import com.squareup.moshi.Json

import com.launchdarkly.client.infrastructure.ApiClient
import com.launchdarkly.client.infrastructure.ApiResponse
import com.launchdarkly.client.infrastructure.ClientException
import com.launchdarkly.client.infrastructure.ClientError
import com.launchdarkly.client.infrastructure.ServerException
import com.launchdarkly.client.infrastructure.ServerError
import com.launchdarkly.client.infrastructure.MultiValueMap
import com.launchdarkly.client.infrastructure.PartConfig
import com.launchdarkly.client.infrastructure.RequestConfig
import com.launchdarkly.client.infrastructure.RequestMethod
import com.launchdarkly.client.infrastructure.ResponseType
import com.launchdarkly.client.infrastructure.Success
import com.launchdarkly.client.infrastructure.toMultiValue

class SegmentsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://app.launchdarkly.com")
        }
    }

    /**
     * Create big segment export
     * Starts a new export process for a big segment. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBigSegmentExport(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : Unit {
        val localVarResponse = createBigSegmentExportWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create big segment export
     * Starts a new export process for a big segment. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun createBigSegmentExportWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = createBigSegmentExportRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBigSegmentExport
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return RequestConfig
     */
    fun createBigSegmentExportRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create big segment import
     * Start a new import process for a big segment. This is an import for a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param file CSV file containing keys (optional)
     * @param mode Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60; (optional)
     * @param waitOnApprovals Whether to wait for approvals before processing the import (optional)
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createBigSegmentImport(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, file: java.io.File? = null, mode: kotlin.String? = null, waitOnApprovals: kotlin.Boolean? = null) : Unit {
        val localVarResponse = createBigSegmentImportWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, file = file, mode = mode, waitOnApprovals = waitOnApprovals)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create big segment import
     * Start a new import process for a big segment. This is an import for a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param file CSV file containing keys (optional)
     * @param mode Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60; (optional)
     * @param waitOnApprovals Whether to wait for approvals before processing the import (optional)
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun createBigSegmentImportWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, file: java.io.File?, mode: kotlin.String?, waitOnApprovals: kotlin.Boolean?) : ApiResponse<Unit?> {
        val localVariableConfig = createBigSegmentImportRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, file = file, mode = mode, waitOnApprovals = waitOnApprovals)

        return request<Map<String, PartConfig<*>>, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation createBigSegmentImport
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param file CSV file containing keys (optional)
     * @param mode Import mode. Use either &#x60;merge&#x60; or &#x60;replace&#x60; (optional)
     * @param waitOnApprovals Whether to wait for approvals before processing the import (optional)
     * @return RequestConfig
     */
    fun createBigSegmentImportRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, file: java.io.File?, mode: kotlin.String?, waitOnApprovals: kotlin.Boolean?) : RequestConfig<Map<String, PartConfig<*>>> {
        val localVariableBody = mapOf(
            "file" to PartConfig(body = file, headers = mutableMapOf()),
            "mode" to PartConfig(body = mode, headers = mutableMapOf()),
            "waitOnApprovals" to PartConfig(body = waitOnApprovals, headers = mutableMapOf()),)
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf("Content-Type" to "multipart/form-data")
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Delete segment
     * Delete a segment.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : Unit {
        val localVarResponse = deleteSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete segment
     * Delete a segment.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = deleteSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return RequestConfig
     */
    fun deleteSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get big segment export
     * Returns information about a big segment export process. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param exportID The export ID
     * @return Export
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBigSegmentExport(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, exportID: kotlin.String) : Export {
        val localVarResponse = getBigSegmentExportWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, exportID = exportID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Export
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get big segment export
     * Returns information about a big segment export process. This is an export for a synced segment or a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param exportID The export ID
     * @return ApiResponse<Export?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBigSegmentExportWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, exportID: kotlin.String) : ApiResponse<Export?> {
        val localVariableConfig = getBigSegmentExportRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, exportID = exportID)

        return request<Unit, Export>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBigSegmentExport
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param exportID The export ID
     * @return RequestConfig
     */
    fun getBigSegmentExportRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, exportID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/exports/{exportID}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())).replace("{"+"exportID"+"}", encodeURIComponent(exportID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get big segment import
     * Returns information about a big segment import process. This is the import of a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param importID The import ID
     * @return Import
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBigSegmentImport(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, importID: kotlin.String) : Import {
        val localVarResponse = getBigSegmentImportWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, importID = importID)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Import
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get big segment import
     * Returns information about a big segment import process. This is the import of a list-based segment that can include more than 15,000 entries.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param importID The import ID
     * @return ApiResponse<Import?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBigSegmentImportWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, importID: kotlin.String) : ApiResponse<Import?> {
        val localVariableConfig = getBigSegmentImportRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, importID = importID)

        return request<Unit, Import>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBigSegmentImport
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param importID The import ID
     * @return RequestConfig
     */
    fun getBigSegmentImportRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, importID: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/imports/{importID}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())).replace("{"+"importID"+"}", encodeURIComponent(importID.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List segment memberships for context instance
     * For a given context instance with attributes, get membership details for all segments. In the request body, pass in the context instance.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param requestBody 
     * @return ContextInstanceSegmentMemberships
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getContextInstanceSegmentsMembershipByEnv(projectKey: kotlin.String, environmentKey: kotlin.String, requestBody: kotlin.collections.Map<kotlin.String, kotlin.Any>) : ContextInstanceSegmentMemberships {
        val localVarResponse = getContextInstanceSegmentsMembershipByEnvWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, requestBody = requestBody)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ContextInstanceSegmentMemberships
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List segment memberships for context instance
     * For a given context instance with attributes, get membership details for all segments. In the request body, pass in the context instance.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param requestBody 
     * @return ApiResponse<ContextInstanceSegmentMemberships?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getContextInstanceSegmentsMembershipByEnvWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, requestBody: kotlin.collections.Map<kotlin.String, kotlin.Any>) : ApiResponse<ContextInstanceSegmentMemberships?> {
        val localVariableConfig = getContextInstanceSegmentsMembershipByEnvRequestConfig(projectKey = projectKey, environmentKey = environmentKey, requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, kotlin.Any>, ContextInstanceSegmentMemberships>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getContextInstanceSegmentsMembershipByEnv
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param requestBody 
     * @return RequestConfig
     */
    fun getContextInstanceSegmentsMembershipByEnvRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, requestBody: kotlin.collections.Map<kotlin.String, kotlin.Any>) : RequestConfig<kotlin.collections.Map<kotlin.String, kotlin.Any>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/projects/{projectKey}/environments/{environmentKey}/segments/evaluate".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get expiring targets for segment
     * Get a list of a segment&#39;s context targets that are scheduled for removal.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ExpiringTargetGetResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExpiringTargetsForSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ExpiringTargetGetResponse {
        val localVarResponse = getExpiringTargetsForSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpiringTargetGetResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get expiring targets for segment
     * Get a list of a segment&#39;s context targets that are scheduled for removal.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ApiResponse<ExpiringTargetGetResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExpiringTargetsForSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ApiResponse<ExpiringTargetGetResponse?> {
        val localVariableConfig = getExpiringTargetsForSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return request<Unit, ExpiringTargetGetResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getExpiringTargetsForSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return RequestConfig
     */
    fun getExpiringTargetsForSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get expiring user targets for segment
     * &gt; ### Contexts are now available &gt; &gt; After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/observability/contexts).  Get a list of a segment&#39;s user targets that are scheduled for removal. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ExpiringUserTargetGetResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getExpiringUserTargetsForSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ExpiringUserTargetGetResponse {
        val localVarResponse = getExpiringUserTargetsForSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpiringUserTargetGetResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get expiring user targets for segment
     * &gt; ### Contexts are now available &gt; &gt; After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/observability/contexts).  Get a list of a segment&#39;s user targets that are scheduled for removal. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ApiResponse<ExpiringUserTargetGetResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getExpiringUserTargetsForSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ApiResponse<ExpiringUserTargetGetResponse?> {
        val localVariableConfig = getExpiringUserTargetsForSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return request<Unit, ExpiringUserTargetGetResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getExpiringUserTargetsForSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return RequestConfig
     */
    fun getExpiringUserTargetsForSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get segment
     * Get a single segment by key.&lt;br/&gt;&lt;br/&gt;Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return UserSegment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : UserSegment {
        val localVarResponse = getSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSegment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get segment
     * Get a single segment by key.&lt;br/&gt;&lt;br/&gt;Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return ApiResponse<UserSegment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : ApiResponse<UserSegment?> {
        val localVariableConfig = getSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey)

        return request<Unit, UserSegment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @return RequestConfig
     */
    fun getSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get big segment membership for context
     * Get the membership status (included/excluded) for a given context in this big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param contextKey The context key
     * @return BigSegmentTarget
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSegmentMembershipForContext(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, contextKey: kotlin.String) : BigSegmentTarget {
        val localVarResponse = getSegmentMembershipForContextWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, contextKey = contextKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigSegmentTarget
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get big segment membership for context
     * Get the membership status (included/excluded) for a given context in this big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param contextKey The context key
     * @return ApiResponse<BigSegmentTarget?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSegmentMembershipForContextWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, contextKey: kotlin.String) : ApiResponse<BigSegmentTarget?> {
        val localVariableConfig = getSegmentMembershipForContextRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, contextKey = contextKey)

        return request<Unit, BigSegmentTarget>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSegmentMembershipForContext
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param contextKey The context key
     * @return RequestConfig
     */
    fun getSegmentMembershipForContextRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, contextKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts/{contextKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())).replace("{"+"contextKey"+"}", encodeURIComponent(contextKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get big segment membership for user
     * &gt; ### Contexts are now available &gt; &gt; After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/observability/contexts).  Get the membership status (included/excluded) for a given user in this big segment. This operation does not support standard segments. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param userKey The user key
     * @return BigSegmentTarget
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSegmentMembershipForUser(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, userKey: kotlin.String) : BigSegmentTarget {
        val localVarResponse = getSegmentMembershipForUserWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, userKey = userKey)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BigSegmentTarget
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get big segment membership for user
     * &gt; ### Contexts are now available &gt; &gt; After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Get expiring targets for segment](/tag/Segments#operation/getExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/observability/contexts).  Get the membership status (included/excluded) for a given user in this big segment. This operation does not support standard segments. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param userKey The user key
     * @return ApiResponse<BigSegmentTarget?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSegmentMembershipForUserWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, userKey: kotlin.String) : ApiResponse<BigSegmentTarget?> {
        val localVariableConfig = getSegmentMembershipForUserRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, userKey = userKey)

        return request<Unit, BigSegmentTarget>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSegmentMembershipForUser
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param userKey The user key
     * @return RequestConfig
     */
    fun getSegmentMembershipForUserRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, userKey: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users/{userKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())).replace("{"+"userKey"+"}", encodeURIComponent(userKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List segments
     * Get a list of all segments in the given project.  Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.  ### Filtering segments  The &#x60;filter&#x60; parameter supports the following operators: &#x60;equals&#x60;, &#x60;anyOf&#x60;, and &#x60;exists&#x60;.  You can also combine filters in the following ways:  - Use a comma (&#x60;,&#x60;) as an AND operator - Use a vertical bar (&#x60;|&#x60;) as an OR operator - Use parentheses (&#x60;()&#x60;) to group filters  #### Supported fields and operators  You can only filter certain fields in segments when using the &#x60;filter&#x60; parameter. Additionally, you can only filter some fields with certain operators.  When you search for segments, the &#x60;filter&#x60; parameter supports the following fields and operators:  |&lt;div style&#x3D;\&quot;width:120px\&quot;&gt;Field&lt;/div&gt; |Description |Supported operators | |---|---|---| | &#x60;excludedKeys&#x60; | The segment keys of segments to exclude from the results. | &#x60;anyOf&#x60; | | &#x60;external&#x60; | Whether the segment is a synced segment. | &#x60;exists&#x60; | | &#x60;includedKeys&#x60; | The segment keys of segments to include in the results. | &#x60;anyOf&#x60; | | &#x60;query&#x60; | A \&quot;fuzzy\&quot; search across segment key, name, and description. Supply a string or list of strings to the operator. | &#x60;equals&#x60; | | &#x60;tags&#x60; | The segment tags. | &#x60;anyOf&#x60; | | &#x60;unbounded&#x60; | Whether the segment is a standard segment (&#x60;false&#x60;) or a big segment (&#x60;true&#x60;). Standard segments include rule-based segments and smaller list-based segments. Big segments include larger list-based segments and synced segments. | &#x60;equals&#x60; |  Here are a few examples:  * The filter &#x60;?filter&#x3D;tags anyOf [\&quot;enterprise\&quot;, \&quot;beta\&quot;],query equals \&quot;toggle\&quot;&#x60; matches segments with \&quot;toggle\&quot; in their key, name, or description that also have \&quot;enterprise\&quot; or \&quot;beta\&quot; as a tag. * The filter &#x60;?filter&#x3D;excludedKeys anyOf [\&quot;segmentKey1\&quot;, \&quot;segmentKey2\&quot;]&#x60; excludes the segments with those keys from the results. * The filter &#x60;?filter&#x3D;unbounded equals true&#x60; matches larger list-based segments and synced segments.  The documented values for &#x60;filter&#x60; query parameters are prior to URL encoding. For example, the &#x60;[&#x60; in &#x60;?filter&#x3D;tags anyOf [\&quot;enterprise\&quot;, \&quot;beta\&quot;]&#x60; must be encoded to &#x60;%5B&#x60;. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param limit The number of segments to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @param sort Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#39;creationDate&#39;, &#39;name&#39;, &#39;lastModified&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending. (optional)
     * @param filter Accepts filter by &#x60;excludedKeys&#x60;, &#x60;external&#x60;, &#x60;includedKeys&#x60;, &#x60;query&#x60;, &#x60;tags&#x60;, &#x60;unbounded&#x60;. To learn more about the filter syntax, read the  &#39;Filtering segments&#39; section above. (optional)
     * @return UserSegments
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSegments(projectKey: kotlin.String, environmentKey: kotlin.String, limit: kotlin.Long? = null, offset: kotlin.Long? = null, sort: kotlin.String? = null, filter: kotlin.String? = null) : UserSegments {
        val localVarResponse = getSegmentsWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, limit = limit, offset = offset, sort = sort, filter = filter)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSegments
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List segments
     * Get a list of all segments in the given project.  Segments can be rule-based, list-based, or synced. Big segments include larger list-based segments and synced segments. Some fields in the response only apply to big segments.  ### Filtering segments  The &#x60;filter&#x60; parameter supports the following operators: &#x60;equals&#x60;, &#x60;anyOf&#x60;, and &#x60;exists&#x60;.  You can also combine filters in the following ways:  - Use a comma (&#x60;,&#x60;) as an AND operator - Use a vertical bar (&#x60;|&#x60;) as an OR operator - Use parentheses (&#x60;()&#x60;) to group filters  #### Supported fields and operators  You can only filter certain fields in segments when using the &#x60;filter&#x60; parameter. Additionally, you can only filter some fields with certain operators.  When you search for segments, the &#x60;filter&#x60; parameter supports the following fields and operators:  |&lt;div style&#x3D;\&quot;width:120px\&quot;&gt;Field&lt;/div&gt; |Description |Supported operators | |---|---|---| | &#x60;excludedKeys&#x60; | The segment keys of segments to exclude from the results. | &#x60;anyOf&#x60; | | &#x60;external&#x60; | Whether the segment is a synced segment. | &#x60;exists&#x60; | | &#x60;includedKeys&#x60; | The segment keys of segments to include in the results. | &#x60;anyOf&#x60; | | &#x60;query&#x60; | A \&quot;fuzzy\&quot; search across segment key, name, and description. Supply a string or list of strings to the operator. | &#x60;equals&#x60; | | &#x60;tags&#x60; | The segment tags. | &#x60;anyOf&#x60; | | &#x60;unbounded&#x60; | Whether the segment is a standard segment (&#x60;false&#x60;) or a big segment (&#x60;true&#x60;). Standard segments include rule-based segments and smaller list-based segments. Big segments include larger list-based segments and synced segments. | &#x60;equals&#x60; |  Here are a few examples:  * The filter &#x60;?filter&#x3D;tags anyOf [\&quot;enterprise\&quot;, \&quot;beta\&quot;],query equals \&quot;toggle\&quot;&#x60; matches segments with \&quot;toggle\&quot; in their key, name, or description that also have \&quot;enterprise\&quot; or \&quot;beta\&quot; as a tag. * The filter &#x60;?filter&#x3D;excludedKeys anyOf [\&quot;segmentKey1\&quot;, \&quot;segmentKey2\&quot;]&#x60; excludes the segments with those keys from the results. * The filter &#x60;?filter&#x3D;unbounded equals true&#x60; matches larger list-based segments and synced segments.  The documented values for &#x60;filter&#x60; query parameters are prior to URL encoding. For example, the &#x60;[&#x60; in &#x60;?filter&#x3D;tags anyOf [\&quot;enterprise\&quot;, \&quot;beta\&quot;]&#x60; must be encoded to &#x60;%5B&#x60;. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param limit The number of segments to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @param sort Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#39;creationDate&#39;, &#39;name&#39;, &#39;lastModified&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending. (optional)
     * @param filter Accepts filter by &#x60;excludedKeys&#x60;, &#x60;external&#x60;, &#x60;includedKeys&#x60;, &#x60;query&#x60;, &#x60;tags&#x60;, &#x60;unbounded&#x60;. To learn more about the filter syntax, read the  &#39;Filtering segments&#39; section above. (optional)
     * @return ApiResponse<UserSegments?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSegmentsWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, limit: kotlin.Long?, offset: kotlin.Long?, sort: kotlin.String?, filter: kotlin.String?) : ApiResponse<UserSegments?> {
        val localVariableConfig = getSegmentsRequestConfig(projectKey = projectKey, environmentKey = environmentKey, limit = limit, offset = offset, sort = sort, filter = filter)

        return request<Unit, UserSegments>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSegments
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param limit The number of segments to return. Defaults to 20. (optional)
     * @param offset Where to start in the list. Use this with pagination. For example, an offset of 10 skips the first ten items and then returns the next items in the list, up to the query &#x60;limit&#x60;. (optional)
     * @param sort Accepts sorting order and fields. Fields can be comma separated. Possible fields are &#39;creationDate&#39;, &#39;name&#39;, &#39;lastModified&#39;. Example: &#x60;sort&#x3D;name&#x60; sort by names ascending or &#x60;sort&#x3D;-name,creationDate&#x60; sort by names descending and creationDate ascending. (optional)
     * @param filter Accepts filter by &#x60;excludedKeys&#x60;, &#x60;external&#x60;, &#x60;includedKeys&#x60;, &#x60;query&#x60;, &#x60;tags&#x60;, &#x60;unbounded&#x60;. To learn more about the filter syntax, read the  &#39;Filtering segments&#39; section above. (optional)
     * @return RequestConfig
     */
    fun getSegmentsRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, limit: kotlin.Long?, offset: kotlin.Long?, sort: kotlin.String?, filter: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
                if (filter != null) {
                    put("filter", listOf(filter.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v2/segments/{projectKey}/{environmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update expiring targets for segment
     *  Update expiring context targets for a segment. Updating a context target expiration uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code &#x60;200&#x60;. In this case, the response &#x60;errors&#x60; array will be non-empty.  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating expiring context targets.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating expiring context targets&lt;/strong&gt;&lt;/summary&gt;  #### addExpiringTarget  Schedules a date and time when LaunchDarkly will remove a context from segment targeting. The segment must already have the context as an individual target.  ##### Parameters  - &#x60;targetType&#x60;: The type of individual target for this context. Must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;contextKey&#x60;: The context key. - &#x60;contextKind&#x60;: The kind of context being targeted. - &#x60;value&#x60;: The date when the context should expire from the segment targeting, in Unix milliseconds.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addExpiringTarget\&quot;,     \&quot;targetType\&quot;: \&quot;included\&quot;,     \&quot;contextKey\&quot;: \&quot;user-key-123abc\&quot;,     \&quot;contextKind\&quot;: \&quot;user\&quot;,     \&quot;value\&quot;: 1754092860000   }] } &#x60;&#x60;&#x60;  #### updateExpiringTarget  Updates the date and time when LaunchDarkly will remove a context from segment targeting.  ##### Parameters  - &#x60;targetType&#x60;: The type of individual target for this context. Must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;contextKey&#x60;: The context key. - &#x60;contextKind&#x60;: The kind of context being targeted. - &#x60;value&#x60;: The new date when the context should expire from the segment targeting, in Unix milliseconds. - &#x60;version&#x60;: (Optional) The version of the expiring target to update. If included, update will fail if version doesn&#39;t match current version of the expiring target.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateExpiringTarget\&quot;,     \&quot;targetType\&quot;: \&quot;included\&quot;,     \&quot;contextKey\&quot;: \&quot;user-key-123abc\&quot;,     \&quot;contextKind\&quot;: \&quot;user\&quot;,     \&quot;value\&quot;: 1754179260000   }] } &#x60;&#x60;&#x60;  #### removeExpiringTarget  Removes the scheduled expiration for the context in the segment.  ##### Parameters  - &#x60;targetType&#x60;: The type of individual target for this context. Must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;contextKey&#x60;: The context key. - &#x60;contextKind&#x60;: The kind of context being targeted.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExpiringTarget\&quot;,     \&quot;targetType\&quot;: \&quot;included\&quot;,     \&quot;contextKey\&quot;: \&quot;user-key-123abc\&quot;,     \&quot;contextKind\&quot;: \&quot;user\&quot;,   }] } &#x60;&#x60;&#x60;  &lt;/details&gt; 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchSegmentExpiringTargetInputRep 
     * @return ExpiringTargetPatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchExpiringTargetsForSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep) : ExpiringTargetPatchResponse {
        val localVarResponse = patchExpiringTargetsForSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, patchSegmentExpiringTargetInputRep = patchSegmentExpiringTargetInputRep)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpiringTargetPatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update expiring targets for segment
     *  Update expiring context targets for a segment. Updating a context target expiration uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code &#x60;200&#x60;. In this case, the response &#x60;errors&#x60; array will be non-empty.  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating expiring context targets.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating expiring context targets&lt;/strong&gt;&lt;/summary&gt;  #### addExpiringTarget  Schedules a date and time when LaunchDarkly will remove a context from segment targeting. The segment must already have the context as an individual target.  ##### Parameters  - &#x60;targetType&#x60;: The type of individual target for this context. Must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;contextKey&#x60;: The context key. - &#x60;contextKind&#x60;: The kind of context being targeted. - &#x60;value&#x60;: The date when the context should expire from the segment targeting, in Unix milliseconds.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addExpiringTarget\&quot;,     \&quot;targetType\&quot;: \&quot;included\&quot;,     \&quot;contextKey\&quot;: \&quot;user-key-123abc\&quot;,     \&quot;contextKind\&quot;: \&quot;user\&quot;,     \&quot;value\&quot;: 1754092860000   }] } &#x60;&#x60;&#x60;  #### updateExpiringTarget  Updates the date and time when LaunchDarkly will remove a context from segment targeting.  ##### Parameters  - &#x60;targetType&#x60;: The type of individual target for this context. Must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;contextKey&#x60;: The context key. - &#x60;contextKind&#x60;: The kind of context being targeted. - &#x60;value&#x60;: The new date when the context should expire from the segment targeting, in Unix milliseconds. - &#x60;version&#x60;: (Optional) The version of the expiring target to update. If included, update will fail if version doesn&#39;t match current version of the expiring target.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateExpiringTarget\&quot;,     \&quot;targetType\&quot;: \&quot;included\&quot;,     \&quot;contextKey\&quot;: \&quot;user-key-123abc\&quot;,     \&quot;contextKind\&quot;: \&quot;user\&quot;,     \&quot;value\&quot;: 1754179260000   }] } &#x60;&#x60;&#x60;  #### removeExpiringTarget  Removes the scheduled expiration for the context in the segment.  ##### Parameters  - &#x60;targetType&#x60;: The type of individual target for this context. Must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;contextKey&#x60;: The context key. - &#x60;contextKind&#x60;: The kind of context being targeted.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExpiringTarget\&quot;,     \&quot;targetType\&quot;: \&quot;included\&quot;,     \&quot;contextKey\&quot;: \&quot;user-key-123abc\&quot;,     \&quot;contextKind\&quot;: \&quot;user\&quot;,   }] } &#x60;&#x60;&#x60;  &lt;/details&gt; 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchSegmentExpiringTargetInputRep 
     * @return ApiResponse<ExpiringTargetPatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchExpiringTargetsForSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep) : ApiResponse<ExpiringTargetPatchResponse?> {
        val localVariableConfig = patchExpiringTargetsForSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, patchSegmentExpiringTargetInputRep = patchSegmentExpiringTargetInputRep)

        return request<PatchSegmentExpiringTargetInputRep, ExpiringTargetPatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchExpiringTargetsForSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchSegmentExpiringTargetInputRep 
     * @return RequestConfig
     */
    fun patchExpiringTargetsForSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchSegmentExpiringTargetInputRep: PatchSegmentExpiringTargetInputRep) : RequestConfig<PatchSegmentExpiringTargetInputRep> {
        val localVariableBody = patchSegmentExpiringTargetInputRep
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-targets/{environmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update expiring user targets for segment
     *  &gt; ### Contexts are now available &gt; &gt; After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring targets for segment](/tag/Segments#operation/patchExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/observability/contexts).  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code &#x60;200&#x60;. In this case, the response &#x60;errors&#x60; array will be non-empty.  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating expiring user targets.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating expiring user targets&lt;/strong&gt;&lt;/summary&gt;  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - &#x60;targetType&#x60;: A segment&#39;s target type, must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;userKey&#x60;: The user key. - &#x60;value&#x60;: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - &#x60;targetType&#x60;: A segment&#39;s target type, must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;userKey&#x60;: The user key. - &#x60;value&#x60;: The new date when the user should expire from the segment targeting, in Unix milliseconds. - &#x60;version&#x60;: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - &#x60;targetType&#x60;: A segment&#39;s target type, must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;userKey&#x60;: The user key.  &lt;/details&gt; 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchSegmentRequest 
     * @return ExpiringUserTargetPatchResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchExpiringUserTargetsForSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchSegmentRequest: PatchSegmentRequest) : ExpiringUserTargetPatchResponse {
        val localVarResponse = patchExpiringUserTargetsForSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, patchSegmentRequest = patchSegmentRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ExpiringUserTargetPatchResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update expiring user targets for segment
     *  &gt; ### Contexts are now available &gt; &gt; After you have upgraded your LaunchDarkly SDK to use contexts instead of users, you should use [Update expiring targets for segment](/tag/Segments#operation/patchExpiringTargetsForSegment) instead of this endpoint. To learn more, read [Contexts](https://docs.launchdarkly.com/home/observability/contexts).  Update expiring user targets for a segment. Updating a user target expiration uses the semantic patch format.  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  If the request is well-formed but any of its instructions failed to process, this operation returns status code &#x60;200&#x60;. In this case, the response &#x60;errors&#x60; array will be non-empty.  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating expiring user targets.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating expiring user targets&lt;/strong&gt;&lt;/summary&gt;  #### addExpireUserTargetDate  Schedules a date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - &#x60;targetType&#x60;: A segment&#39;s target type, must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;userKey&#x60;: The user key. - &#x60;value&#x60;: The date when the user should expire from the segment targeting, in Unix milliseconds.  #### updateExpireUserTargetDate  Updates the date and time when LaunchDarkly will remove a user from segment targeting.  ##### Parameters  - &#x60;targetType&#x60;: A segment&#39;s target type, must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;userKey&#x60;: The user key. - &#x60;value&#x60;: The new date when the user should expire from the segment targeting, in Unix milliseconds. - &#x60;version&#x60;: The segment version.  #### removeExpireUserTargetDate  Removes the scheduled expiration for the user in the segment.  ##### Parameters  - &#x60;targetType&#x60;: A segment&#39;s target type, must be either &#x60;included&#x60; or &#x60;excluded&#x60;. - &#x60;userKey&#x60;: The user key.  &lt;/details&gt; 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchSegmentRequest 
     * @return ApiResponse<ExpiringUserTargetPatchResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchExpiringUserTargetsForSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchSegmentRequest: PatchSegmentRequest) : ApiResponse<ExpiringUserTargetPatchResponse?> {
        val localVariableConfig = patchExpiringUserTargetsForSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, patchSegmentRequest = patchSegmentRequest)

        return request<PatchSegmentRequest, ExpiringUserTargetPatchResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchExpiringUserTargetsForSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchSegmentRequest 
     * @return RequestConfig
     */
    fun patchExpiringUserTargetsForSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchSegmentRequest: PatchSegmentRequest) : RequestConfig<PatchSegmentRequest> {
        val localVariableBody = patchSegmentRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/segments/{projectKey}/{segmentKey}/expiring-user-targets/{environmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Patch segment
     * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a segment  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an &#x60;environmentKey&#x60; in addition to &#x60;instructions&#x60; and an optional &#x60;comment&#x60;. The body of the request takes the following properties:  * &#x60;comment&#x60; (string): (Optional) A description of the update. * &#x60;environmentKey&#x60; (string): (Required) The key of the LaunchDarkly environment. * &#x60;instructions&#x60; (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a &#x60;kind&#x60; property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating segments.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating segment details and settings&lt;/strong&gt;&lt;/summary&gt;  #### addTags  Adds tags to the segment.  ##### Parameters  - &#x60;values&#x60;: A list of tags to add.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addTags\&quot;,     \&quot;values\&quot;: [\&quot;tag1\&quot;, \&quot;tag2\&quot;]   }] } &#x60;&#x60;&#x60;  #### removeTags  Removes tags from the segment.  ##### Parameters  - &#x60;values&#x60;: A list of tags to remove.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeTags\&quot;,     \&quot;values\&quot;: [\&quot;tag1\&quot;, \&quot;tag2\&quot;]   }] } &#x60;&#x60;&#x60;  #### updateName  Updates the name of the segment.  ##### Parameters  - &#x60;value&#x60;: Name of the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateName\&quot;,     \&quot;value\&quot;: \&quot;Updated segment name\&quot;   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating segment individual targets&lt;/strong&gt;&lt;/summary&gt;  #### addExcludedTargets  Adds context keys to the individual context targets excluded from the segment for the specified &#x60;contextKind&#x60;. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be added to. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addExcludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use &#x60;addExcludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addExcludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addIncludedTargets  Adds context keys to the individual context targets included in the segment for the specified &#x60;contextKind&#x60;. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be added to. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addIncludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use &#x60;addIncludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addIncludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeExcludedTargets  Removes context keys from the individual context targets excluded from the segment for the specified &#x60;contextKind&#x60;.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be removed from. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExcludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use &#x60;removeExcludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExcludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeIncludedTargets  Removes context keys from the individual context targets included in the segment for the specified &#x60;contextKind&#x60;.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be removed from. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeIncludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment. If you are working with contexts, use &#x60;removeIncludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeIncludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating segment targeting rules&lt;/strong&gt;&lt;/summary&gt;  #### addClauses  Adds the given clauses to the rule indicated by &#x60;ruleId&#x60;.  ##### Parameters  - &#x60;clauses&#x60;: Array of clause objects, with &#x60;contextKind&#x60; (string), &#x60;attribute&#x60; (string), &#x60;op&#x60; (string), &#x60;negate&#x60; (boolean), and &#x60;values&#x60; (array of strings, numbers, or dates) properties. The &#x60;contextKind&#x60;, if not provided, defaults to &#x60;user&#x60;. The &#x60;contextKind&#x60;, &#x60;attribute&#x60;, and &#x60;values&#x60; are case sensitive. The &#x60;op&#x60; must be lower-case. - &#x60;ruleId&#x60;: ID of a rule in the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addClauses\&quot;,     \&quot;clauses\&quot;: [       {         \&quot;attribute\&quot;: \&quot;email\&quot;,         \&quot;negate\&quot;: false,         \&quot;op\&quot;: \&quot;contains\&quot;,         \&quot;values\&quot;: [\&quot;value1\&quot;]       }     ],     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,   }] } &#x60;&#x60;&#x60;  #### addRule  Adds a new targeting rule to the segment. The rule may contain &#x60;clauses&#x60;.  ##### Parameters  - &#x60;clauses&#x60;: Array of clause objects, with &#x60;contextKind&#x60; (string), &#x60;attribute&#x60; (string), &#x60;op&#x60; (string), &#x60;negate&#x60; (boolean), and &#x60;values&#x60; (array of strings, numbers, or dates) properties. The &#x60;contextKind&#x60;, if not provided, defaults to &#x60;user&#x60;. The &#x60;contextKind&#x60;, &#x60;attribute&#x60;, and &#x60;values&#x60; are case sensitive. The &#x60;op&#x60; must be lower-case. - &#x60;description&#x60;: A description of the rule.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addRule\&quot;,     \&quot;clauses\&quot;: [       {         \&quot;attribute\&quot;: \&quot;email\&quot;,         \&quot;op\&quot;: \&quot;contains\&quot;,         \&quot;negate\&quot;: false,         \&quot;values\&quot;: [\&quot;@launchdarkly.com\&quot;]       }     ],     \&quot;description\&quot;: \&quot;Targeting rule for LaunchDarkly employees\&quot;,   }] } &#x60;&#x60;&#x60;  #### addValuesToClause  Adds &#x60;values&#x60; to the values of the clause that &#x60;ruleId&#x60; and &#x60;clauseId&#x60; indicate. Does not update the context kind, attribute, or operator.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseId&#x60;: ID of a clause in that rule. - &#x60;values&#x60;: Array of strings, case sensitive.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addValuesToClause\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseId\&quot;: \&quot;10a58772-3121-400f-846b-b8a04e8944ed\&quot;,     \&quot;values\&quot;: [\&quot;beta_testers\&quot;]   }] } &#x60;&#x60;&#x60;  #### removeClauses  Removes the clauses specified by &#x60;clauseIds&#x60; from the rule indicated by &#x60;ruleId&#x60;.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseIds&#x60;: Array of IDs of clauses in the rule.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeClauses\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseIds\&quot;: [\&quot;10a58772-3121-400f-846b-b8a04e8944ed\&quot;, \&quot;36a461dc-235e-4b08-97b9-73ce9365873e\&quot;]   }] } &#x60;&#x60;&#x60;  #### removeRule  Removes the targeting rule specified by &#x60;ruleId&#x60;. Does nothing if the rule does not exist.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeRule\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;   }] } &#x60;&#x60;&#x60;  #### removeValuesFromClause  Removes &#x60;values&#x60; from the values of the clause indicated by &#x60;ruleId&#x60; and &#x60;clauseId&#x60;. Does not update the context kind, attribute, or operator.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseId&#x60;: ID of a clause in that rule. - &#x60;values&#x60;: Array of strings, case sensitive.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeValuesFromClause\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseId\&quot;: \&quot;10a58772-3121-400f-846b-b8a04e8944ed\&quot;,     \&quot;values\&quot;: [\&quot;beta_testers\&quot;]   }] } &#x60;&#x60;&#x60;  #### reorderRules  Rearranges the rules to match the order given in &#x60;ruleIds&#x60;. Returns an error if &#x60;ruleIds&#x60; does not match the current set of rules in the segment.  ##### Parameters  - &#x60;ruleIds&#x60;: Array of IDs of all targeting rules in the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;reorderRules\&quot;,     \&quot;ruleIds\&quot;: [\&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;, \&quot;63c238d1-835d-435e-8f21-c8d5e40b2a3d\&quot;]   }] } &#x60;&#x60;&#x60;  #### updateClause  Replaces the clause indicated by &#x60;ruleId&#x60; and &#x60;clauseId&#x60; with &#x60;clause&#x60;.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseId&#x60;: ID of a clause in that rule. - &#x60;clause&#x60;: New &#x60;clause&#x60; object, with &#x60;contextKind&#x60; (string), &#x60;attribute&#x60; (string), &#x60;op&#x60; (string), &#x60;negate&#x60; (boolean), and &#x60;values&#x60; (array of strings, numbers, or dates) properties. The &#x60;contextKind&#x60;, if not provided, defaults to &#x60;user&#x60;. The &#x60;contextKind&#x60;, &#x60;attribute&#x60;, and &#x60;values&#x60; are case sensitive. The &#x60;op&#x60; must be lower-case.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateClause\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseId\&quot;: \&quot;10c7462a-2062-45ba-a8bb-dfb3de0f8af5\&quot;,     \&quot;clause\&quot;: {       \&quot;contextKind\&quot;: \&quot;user\&quot;,       \&quot;attribute\&quot;: \&quot;country\&quot;,       \&quot;op\&quot;: \&quot;in\&quot;,       \&quot;negate\&quot;: false,       \&quot;values\&quot;: [\&quot;Mexico\&quot;, \&quot;Canada\&quot;]     }   }] } &#x60;&#x60;&#x60;  #### updateRuleDescription  Updates the description of the segment targeting rule.  ##### Parameters  - &#x60;description&#x60;: The new human-readable description for this rule. - &#x60;ruleId&#x60;: The ID of the rule. You can retrieve this by making a GET request for the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateRuleDescription\&quot;,     \&quot;description\&quot;: \&quot;New rule description\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;   }] } &#x60;&#x60;&#x60;  #### updateRuleRolloutAndContextKind  For a rule that includes a percentage of targets, updates the percentage and the context kind of the targets to include.  ##### Parameters  - &#x60;ruleId&#x60;: The ID of a targeting rule in the segment that includes a percentage of targets. - &#x60;weight&#x60;: The weight, in thousandths of a percent (0-100000). - &#x60;contextKind&#x60;: The context kind.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;reorderRules\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;weight\&quot;: \&quot;20000\&quot;,     \&quot;contextKind\&quot;: \&quot;device\&quot;   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;working with Big Segments&lt;/strong&gt;&lt;/summary&gt;  A \&quot;big segment\&quot; is a segment that is either a synced segment, or a list-based segment with more than 15,000 entries that includes only one targeted context kind. LaunchDarkly uses different implementations for different types of segments so that all of your segments have good performance.  The following semantic patch instructions apply only to these [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments).  #### addBigSegmentExcludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Adds context keys to the context targets excluded from the segment. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addBigSegmentExcludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addBigSegmentIncludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Adds context keys to the context targets included in the segment. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addBigSegmentIncludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### processBigSegmentImport  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Processes a segment import.  ##### Parameters  - &#x60;importId&#x60;: The ID of the import. The import ID is returned in the &#x60;Location&#x60; header as part of the [Create big segment import](https://apidocs.launchdarkly.com/tag/Segments-(beta)#operation/createBigSegmentImport) request.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;processBigSegmentImport\&quot;,     \&quot;importId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;   }] } &#x60;&#x60;&#x60;   #### removeBigSegmentExcludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Removes context keys from the context targets excluded from the segment.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeBigSegmentExcludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeBigSegmentIncludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Removes context keys from the context targets included in the segment.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeBigSegmentIncludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  ### Using JSON patches on a segment  If you do not include the header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  For example, to update the description for a segment with a JSON patch, use the following request body:  &#x60;&#x60;&#x60;json {   \&quot;patch\&quot;: [     {       \&quot;op\&quot;: \&quot;replace\&quot;,       \&quot;path\&quot;: \&quot;/description\&quot;,       \&quot;value\&quot;: \&quot;new description\&quot;     }   ] } &#x60;&#x60;&#x60;  To update fields in the segment that are arrays, set the &#x60;path&#x60; to the name of the field and then append &#x60;/&lt;array index&gt;&#x60;. Use &#x60;/0&#x60; to add the new entry to the beginning of the array. Use &#x60;/-&#x60; to add the new entry to the end of the array.  For example, to add a rule to a segment, use the following request body:  &#x60;&#x60;&#x60;json {   \&quot;patch\&quot;:[     {       \&quot;op\&quot;: \&quot;add\&quot;,       \&quot;path\&quot;: \&quot;/rules/0\&quot;,       \&quot;value\&quot;: {         \&quot;clauses\&quot;: [{ \&quot;contextKind\&quot;: \&quot;user\&quot;, \&quot;attribute\&quot;: \&quot;email\&quot;, \&quot;op\&quot;: \&quot;endsWith\&quot;, \&quot;values\&quot;: [\&quot;.edu\&quot;], \&quot;negate\&quot;: false }]       }     }   ] } &#x60;&#x60;&#x60;  To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchWithComment 
     * @return UserSegment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun patchSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchWithComment: PatchWithComment) : UserSegment {
        val localVarResponse = patchSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, patchWithComment = patchWithComment)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSegment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Patch segment
     * Update a segment. The request body must be a valid semantic patch, JSON patch, or JSON merge patch. To learn more the different formats, read [Updates](/#section/Overview/Updates).  ### Using semantic patches on a segment  To make a semantic patch request, you must append &#x60;domain-model&#x3D;launchdarkly.semanticpatch&#x60; to your &#x60;Content-Type&#x60; header. To learn more, read [Updates using semantic patch](/reference#updates-using-semantic-patch).  The body of a semantic patch request for updating segments requires an &#x60;environmentKey&#x60; in addition to &#x60;instructions&#x60; and an optional &#x60;comment&#x60;. The body of the request takes the following properties:  * &#x60;comment&#x60; (string): (Optional) A description of the update. * &#x60;environmentKey&#x60; (string): (Required) The key of the LaunchDarkly environment. * &#x60;instructions&#x60; (array): (Required) A list of actions the update should perform. Each action in the list must be an object with a &#x60;kind&#x60; property that indicates the instruction. If the action requires parameters, you must include those parameters as additional fields in the object.  ### Instructions  Semantic patch requests support the following &#x60;kind&#x60; instructions for updating segments.  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating segment details and settings&lt;/strong&gt;&lt;/summary&gt;  #### addTags  Adds tags to the segment.  ##### Parameters  - &#x60;values&#x60;: A list of tags to add.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addTags\&quot;,     \&quot;values\&quot;: [\&quot;tag1\&quot;, \&quot;tag2\&quot;]   }] } &#x60;&#x60;&#x60;  #### removeTags  Removes tags from the segment.  ##### Parameters  - &#x60;values&#x60;: A list of tags to remove.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeTags\&quot;,     \&quot;values\&quot;: [\&quot;tag1\&quot;, \&quot;tag2\&quot;]   }] } &#x60;&#x60;&#x60;  #### updateName  Updates the name of the segment.  ##### Parameters  - &#x60;value&#x60;: Name of the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateName\&quot;,     \&quot;value\&quot;: \&quot;Updated segment name\&quot;   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating segment individual targets&lt;/strong&gt;&lt;/summary&gt;  #### addExcludedTargets  Adds context keys to the individual context targets excluded from the segment for the specified &#x60;contextKind&#x60;. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be added to. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addExcludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addExcludedUsers  Adds user keys to the individual user targets excluded from the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use &#x60;addExcludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addExcludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addIncludedTargets  Adds context keys to the individual context targets included in the segment for the specified &#x60;contextKind&#x60;. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be added to. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addIncludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addIncludedUsers  Adds user keys to the individual user targets included in the segment. Returns an error if this causes the same user key to be both included and excluded. If you are working with contexts, use &#x60;addIncludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addIncludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeExcludedTargets  Removes context keys from the individual context targets excluded from the segment for the specified &#x60;contextKind&#x60;.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be removed from. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExcludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeExcludedUsers  Removes user keys from the individual user targets excluded from the segment. If you are working with contexts, use &#x60;removeExcludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeExcludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeIncludedTargets  Removes context keys from the individual context targets included in the segment for the specified &#x60;contextKind&#x60;.  ##### Parameters  - &#x60;contextKind&#x60;: The context kind the targets should be removed from. - &#x60;values&#x60;: List of keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeIncludedTargets\&quot;,     \&quot;contextKind\&quot;: \&quot;org\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeIncludedUsers  Removes user keys from the individual user targets included in the segment. If you are working with contexts, use &#x60;removeIncludedTargets&#x60; instead of this instruction.  ##### Parameters  - &#x60;values&#x60;: List of user keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeIncludedUsers\&quot;,     \&quot;values\&quot;: [ \&quot;user-key-123abc\&quot;, \&quot;user-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;updating segment targeting rules&lt;/strong&gt;&lt;/summary&gt;  #### addClauses  Adds the given clauses to the rule indicated by &#x60;ruleId&#x60;.  ##### Parameters  - &#x60;clauses&#x60;: Array of clause objects, with &#x60;contextKind&#x60; (string), &#x60;attribute&#x60; (string), &#x60;op&#x60; (string), &#x60;negate&#x60; (boolean), and &#x60;values&#x60; (array of strings, numbers, or dates) properties. The &#x60;contextKind&#x60;, if not provided, defaults to &#x60;user&#x60;. The &#x60;contextKind&#x60;, &#x60;attribute&#x60;, and &#x60;values&#x60; are case sensitive. The &#x60;op&#x60; must be lower-case. - &#x60;ruleId&#x60;: ID of a rule in the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addClauses\&quot;,     \&quot;clauses\&quot;: [       {         \&quot;attribute\&quot;: \&quot;email\&quot;,         \&quot;negate\&quot;: false,         \&quot;op\&quot;: \&quot;contains\&quot;,         \&quot;values\&quot;: [\&quot;value1\&quot;]       }     ],     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,   }] } &#x60;&#x60;&#x60;  #### addRule  Adds a new targeting rule to the segment. The rule may contain &#x60;clauses&#x60;.  ##### Parameters  - &#x60;clauses&#x60;: Array of clause objects, with &#x60;contextKind&#x60; (string), &#x60;attribute&#x60; (string), &#x60;op&#x60; (string), &#x60;negate&#x60; (boolean), and &#x60;values&#x60; (array of strings, numbers, or dates) properties. The &#x60;contextKind&#x60;, if not provided, defaults to &#x60;user&#x60;. The &#x60;contextKind&#x60;, &#x60;attribute&#x60;, and &#x60;values&#x60; are case sensitive. The &#x60;op&#x60; must be lower-case. - &#x60;description&#x60;: A description of the rule.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addRule\&quot;,     \&quot;clauses\&quot;: [       {         \&quot;attribute\&quot;: \&quot;email\&quot;,         \&quot;op\&quot;: \&quot;contains\&quot;,         \&quot;negate\&quot;: false,         \&quot;values\&quot;: [\&quot;@launchdarkly.com\&quot;]       }     ],     \&quot;description\&quot;: \&quot;Targeting rule for LaunchDarkly employees\&quot;,   }] } &#x60;&#x60;&#x60;  #### addValuesToClause  Adds &#x60;values&#x60; to the values of the clause that &#x60;ruleId&#x60; and &#x60;clauseId&#x60; indicate. Does not update the context kind, attribute, or operator.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseId&#x60;: ID of a clause in that rule. - &#x60;values&#x60;: Array of strings, case sensitive.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addValuesToClause\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseId\&quot;: \&quot;10a58772-3121-400f-846b-b8a04e8944ed\&quot;,     \&quot;values\&quot;: [\&quot;beta_testers\&quot;]   }] } &#x60;&#x60;&#x60;  #### removeClauses  Removes the clauses specified by &#x60;clauseIds&#x60; from the rule indicated by &#x60;ruleId&#x60;.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseIds&#x60;: Array of IDs of clauses in the rule.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeClauses\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseIds\&quot;: [\&quot;10a58772-3121-400f-846b-b8a04e8944ed\&quot;, \&quot;36a461dc-235e-4b08-97b9-73ce9365873e\&quot;]   }] } &#x60;&#x60;&#x60;  #### removeRule  Removes the targeting rule specified by &#x60;ruleId&#x60;. Does nothing if the rule does not exist.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeRule\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;   }] } &#x60;&#x60;&#x60;  #### removeValuesFromClause  Removes &#x60;values&#x60; from the values of the clause indicated by &#x60;ruleId&#x60; and &#x60;clauseId&#x60;. Does not update the context kind, attribute, or operator.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseId&#x60;: ID of a clause in that rule. - &#x60;values&#x60;: Array of strings, case sensitive.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeValuesFromClause\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseId\&quot;: \&quot;10a58772-3121-400f-846b-b8a04e8944ed\&quot;,     \&quot;values\&quot;: [\&quot;beta_testers\&quot;]   }] } &#x60;&#x60;&#x60;  #### reorderRules  Rearranges the rules to match the order given in &#x60;ruleIds&#x60;. Returns an error if &#x60;ruleIds&#x60; does not match the current set of rules in the segment.  ##### Parameters  - &#x60;ruleIds&#x60;: Array of IDs of all targeting rules in the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;reorderRules\&quot;,     \&quot;ruleIds\&quot;: [\&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;, \&quot;63c238d1-835d-435e-8f21-c8d5e40b2a3d\&quot;]   }] } &#x60;&#x60;&#x60;  #### updateClause  Replaces the clause indicated by &#x60;ruleId&#x60; and &#x60;clauseId&#x60; with &#x60;clause&#x60;.  ##### Parameters  - &#x60;ruleId&#x60;: ID of a rule in the segment. - &#x60;clauseId&#x60;: ID of a clause in that rule. - &#x60;clause&#x60;: New &#x60;clause&#x60; object, with &#x60;contextKind&#x60; (string), &#x60;attribute&#x60; (string), &#x60;op&#x60; (string), &#x60;negate&#x60; (boolean), and &#x60;values&#x60; (array of strings, numbers, or dates) properties. The &#x60;contextKind&#x60;, if not provided, defaults to &#x60;user&#x60;. The &#x60;contextKind&#x60;, &#x60;attribute&#x60;, and &#x60;values&#x60; are case sensitive. The &#x60;op&#x60; must be lower-case.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateClause\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;clauseId\&quot;: \&quot;10c7462a-2062-45ba-a8bb-dfb3de0f8af5\&quot;,     \&quot;clause\&quot;: {       \&quot;contextKind\&quot;: \&quot;user\&quot;,       \&quot;attribute\&quot;: \&quot;country\&quot;,       \&quot;op\&quot;: \&quot;in\&quot;,       \&quot;negate\&quot;: false,       \&quot;values\&quot;: [\&quot;Mexico\&quot;, \&quot;Canada\&quot;]     }   }] } &#x60;&#x60;&#x60;  #### updateRuleDescription  Updates the description of the segment targeting rule.  ##### Parameters  - &#x60;description&#x60;: The new human-readable description for this rule. - &#x60;ruleId&#x60;: The ID of the rule. You can retrieve this by making a GET request for the segment.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;updateRuleDescription\&quot;,     \&quot;description\&quot;: \&quot;New rule description\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;   }] } &#x60;&#x60;&#x60;  #### updateRuleRolloutAndContextKind  For a rule that includes a percentage of targets, updates the percentage and the context kind of the targets to include.  ##### Parameters  - &#x60;ruleId&#x60;: The ID of a targeting rule in the segment that includes a percentage of targets. - &#x60;weight&#x60;: The weight, in thousandths of a percent (0-100000). - &#x60;contextKind&#x60;: The context kind.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;reorderRules\&quot;,     \&quot;ruleId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;,     \&quot;weight\&quot;: \&quot;20000\&quot;,     \&quot;contextKind\&quot;: \&quot;device\&quot;   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  &lt;details&gt; &lt;summary&gt;Click to expand instructions for &lt;strong&gt;working with Big Segments&lt;/strong&gt;&lt;/summary&gt;  A \&quot;big segment\&quot; is a segment that is either a synced segment, or a list-based segment with more than 15,000 entries that includes only one targeted context kind. LaunchDarkly uses different implementations for different types of segments so that all of your segments have good performance.  The following semantic patch instructions apply only to these [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments).  #### addBigSegmentExcludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Adds context keys to the context targets excluded from the segment. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addBigSegmentExcludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### addBigSegmentIncludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Adds context keys to the context targets included in the segment. Returns an error if this causes the same context key to be both included and excluded.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;addBigSegmentIncludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### processBigSegmentImport  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Processes a segment import.  ##### Parameters  - &#x60;importId&#x60;: The ID of the import. The import ID is returned in the &#x60;Location&#x60; header as part of the [Create big segment import](https://apidocs.launchdarkly.com/tag/Segments-(beta)#operation/createBigSegmentImport) request.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;processBigSegmentImport\&quot;,     \&quot;importId\&quot;: \&quot;a902ef4a-2faf-4eaf-88e1-ecc356708a29\&quot;   }] } &#x60;&#x60;&#x60;   #### removeBigSegmentExcludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Removes context keys from the context targets excluded from the segment.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeBigSegmentExcludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  #### removeBigSegmentIncludedTargets  For use with [larger list-based segments](https://docs.launchdarkly.com/home/flags/segments-create#create-larger-list-based-segments) ONLY. Removes context keys from the context targets included in the segment.  ##### Parameters  - &#x60;values&#x60;: List of context keys.  Here&#39;s an example:  &#x60;&#x60;&#x60;json {   \&quot;instructions\&quot;: [{     \&quot;kind\&quot;: \&quot;removeBigSegmentIncludedTargets\&quot;,     \&quot;values\&quot;: [ \&quot;org-key-123abc\&quot;, \&quot;org-key-456def\&quot; ]   }] } &#x60;&#x60;&#x60;  &lt;/details&gt;  ### Using JSON patches on a segment  If you do not include the header described above, you can use a [JSON patch](/reference#updates-using-json-patch) or [JSON merge patch](https://datatracker.ietf.org/doc/html/rfc7386) representation of the desired changes.  For example, to update the description for a segment with a JSON patch, use the following request body:  &#x60;&#x60;&#x60;json {   \&quot;patch\&quot;: [     {       \&quot;op\&quot;: \&quot;replace\&quot;,       \&quot;path\&quot;: \&quot;/description\&quot;,       \&quot;value\&quot;: \&quot;new description\&quot;     }   ] } &#x60;&#x60;&#x60;  To update fields in the segment that are arrays, set the &#x60;path&#x60; to the name of the field and then append &#x60;/&lt;array index&gt;&#x60;. Use &#x60;/0&#x60; to add the new entry to the beginning of the array. Use &#x60;/-&#x60; to add the new entry to the end of the array.  For example, to add a rule to a segment, use the following request body:  &#x60;&#x60;&#x60;json {   \&quot;patch\&quot;:[     {       \&quot;op\&quot;: \&quot;add\&quot;,       \&quot;path\&quot;: \&quot;/rules/0\&quot;,       \&quot;value\&quot;: {         \&quot;clauses\&quot;: [{ \&quot;contextKind\&quot;: \&quot;user\&quot;, \&quot;attribute\&quot;: \&quot;email\&quot;, \&quot;op\&quot;: \&quot;endsWith\&quot;, \&quot;values\&quot;: [\&quot;.edu\&quot;], \&quot;negate\&quot;: false }]       }     }   ] } &#x60;&#x60;&#x60;  To add or remove targets from segments, we recommend using semantic patch. Semantic patch for segments includes specific instructions for adding and removing both included and excluded targets. 
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchWithComment 
     * @return ApiResponse<UserSegment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun patchSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchWithComment: PatchWithComment) : ApiResponse<UserSegment?> {
        val localVariableConfig = patchSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, patchWithComment = patchWithComment)

        return request<PatchWithComment, UserSegment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation patchSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param patchWithComment 
     * @return RequestConfig
     */
    fun patchSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, patchWithComment: PatchWithComment) : RequestConfig<PatchWithComment> {
        val localVariableBody = patchWithComment
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PATCH,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Create segment
     * Create a new segment.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentBody 
     * @return UserSegment
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun postSegment(projectKey: kotlin.String, environmentKey: kotlin.String, segmentBody: SegmentBody) : UserSegment {
        val localVarResponse = postSegmentWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentBody = segmentBody)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSegment
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Create segment
     * Create a new segment.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentBody 
     * @return ApiResponse<UserSegment?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun postSegmentWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentBody: SegmentBody) : ApiResponse<UserSegment?> {
        val localVariableConfig = postSegmentRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentBody = segmentBody)

        return request<SegmentBody, UserSegment>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation postSegment
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentBody 
     * @return RequestConfig
     */
    fun postSegmentRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentBody: SegmentBody) : RequestConfig<SegmentBody> {
        val localVariableBody = segmentBody
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/segments/{projectKey}/{environmentKey}".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update context targets on a big segment
     * Update context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param segmentUserState 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBigSegmentContextTargets(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, segmentUserState: SegmentUserState) : Unit {
        val localVarResponse = updateBigSegmentContextTargetsWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, segmentUserState = segmentUserState)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update context targets on a big segment
     * Update context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param segmentUserState 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBigSegmentContextTargetsWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, segmentUserState: SegmentUserState) : ApiResponse<Unit?> {
        val localVariableConfig = updateBigSegmentContextTargetsRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, segmentUserState = segmentUserState)

        return request<SegmentUserState, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBigSegmentContextTargets
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param segmentUserState 
     * @return RequestConfig
     */
    fun updateBigSegmentContextTargetsRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, segmentUserState: SegmentUserState) : RequestConfig<SegmentUserState> {
        val localVariableBody = segmentUserState
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/contexts".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Update user context targets on a big segment
     * Update user context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param segmentUserState 
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBigSegmentTargets(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, segmentUserState: SegmentUserState) : Unit {
        val localVarResponse = updateBigSegmentTargetsWithHttpInfo(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, segmentUserState = segmentUserState)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update user context targets on a big segment
     * Update user context targets included or excluded in a big segment. Big segments include larger list-based segments and synced segments. This operation does not support standard segments.
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param segmentUserState 
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBigSegmentTargetsWithHttpInfo(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, segmentUserState: SegmentUserState) : ApiResponse<Unit?> {
        val localVariableConfig = updateBigSegmentTargetsRequestConfig(projectKey = projectKey, environmentKey = environmentKey, segmentKey = segmentKey, segmentUserState = segmentUserState)

        return request<SegmentUserState, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBigSegmentTargets
     *
     * @param projectKey The project key
     * @param environmentKey The environment key
     * @param segmentKey The segment key
     * @param segmentUserState 
     * @return RequestConfig
     */
    fun updateBigSegmentTargetsRequestConfig(projectKey: kotlin.String, environmentKey: kotlin.String, segmentKey: kotlin.String, segmentUserState: SegmentUserState) : RequestConfig<SegmentUserState> {
        val localVariableBody = segmentUserState
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v2/segments/{projectKey}/{environmentKey}/{segmentKey}/users".replace("{"+"projectKey"+"}", encodeURIComponent(projectKey.toString())).replace("{"+"environmentKey"+"}", encodeURIComponent(environmentKey.toString())).replace("{"+"segmentKey"+"}", encodeURIComponent(segmentKey.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
